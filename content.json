[{"title":"关于java.lang.UnsupportedOperationException异常","date":"2018-04-05T03:37:56.000Z","path":"2018/04/05/asListException/","text":"引言： 这里感谢我们的组长提出这个问题，然后我去查看源码后发现了导致这个问题的原因。 1. 是什么，原因在调用Arrays类的aslist函数把数组转换成List集合不能对其进行添加删除等操作，否则抛出UnsupportedOperationException的异常，代码如下： 123456789101112131415zzz.javapackage Test;import java.util.Arrays;import java.util.List;public class zzz &#123; public static void main(String[] args) &#123; Integer[] arr = &#123;1, 2, 3, 4&#125;; List&lt;Integer&gt; list = Arrays.asList(arr); list.add(3); //error list.remove(2); //error &#125;&#125; 运行代码将抛出一下错误： 1234Exception in thread \"main\" java.lang.UnsupportedOperationException at java.base/java.util.AbstractList.add(AbstractList.java:153) at java.base/java.util.AbstractList.add(AbstractList.java:111) at Test.zzz.main(zzz.java:10) 根据字面意思，unsupportedOperationException就是对该实例不支持相应的函数操作。 也许有人问，list接口明明提供相应的接口，并且ArrayList明明实现了add等操作函数，为什么不支持。问题就在这，aslist返回的ArrayList实例并不是我们之前学的Arraylist的实例，而是Arrays类的静态内部类的实例，看源码 12345Arrays.java public static &lt;T&gt; List&lt;T&gt; asList(T... a) &#123; return new ArrayList&lt;&gt;(a); &#125; asList的源码，跟踪ArrayList的创建方法，继续看源码。只需要注意继承和实现类和接口还有实现的相关函数，直接跳到解析部分： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126Arrays.java /** * @serial include */ private static class ArrayList&lt;E&gt; extends AbstractList&lt;E&gt; implements RandomAccess, java.io.Serializable &#123; private static final long serialVersionUID = -2764017481108945198L; private final E[] a; ArrayList(E[] array) &#123; a = Objects.requireNonNull(array); &#125; @Override public int size() &#123; return a.length; &#125; @Override public Object[] toArray() &#123; return Arrays.copyOf(a, a.length, Object[].class); &#125; @Override @SuppressWarnings(\"unchecked\") public &lt;T&gt; T[] toArray(T[] a) &#123; int size = size(); if (a.length &lt; size) return Arrays.copyOf(this.a, size, (Class&lt;? extends T[]&gt;) a.getClass()); System.arraycopy(this.a, 0, a, 0, size); if (a.length &gt; size) a[size] = null; return a; &#125; @Override public E get(int index) &#123; return a[index]; &#125; @Override public E set(int index, E element) &#123; E oldValue = a[index]; a[index] = element; return oldValue; &#125; @Override public int indexOf(Object o) &#123; E[] a = this.a; if (o == null) &#123; for (int i = 0; i &lt; a.length; i++) if (a[i] == null) return i; &#125; else &#123; for (int i = 0; i &lt; a.length; i++) if (o.equals(a[i])) return i; &#125; return -1; &#125; @Override public boolean contains(Object o) &#123; return indexOf(o) &gt;= 0; &#125; @Override public Spliterator&lt;E&gt; spliterator() &#123; return Spliterators.spliterator(a, Spliterator.ORDERED); &#125; @Override public void forEach(Consumer&lt;? super E&gt; action) &#123; Objects.requireNonNull(action); for (E e : a) &#123; action.accept(e); &#125; &#125; @Override public void replaceAll(UnaryOperator&lt;E&gt; operator) &#123; Objects.requireNonNull(operator); E[] a = this.a; for (int i = 0; i &lt; a.length; i++) &#123; a[i] = operator.apply(a[i]); &#125; &#125; @Override public void sort(Comparator&lt;? super E&gt; c) &#123; Arrays.sort(a, c); &#125; @Override public Iterator&lt;E&gt; iterator() &#123; return new ArrayItr&lt;&gt;(a); &#125; &#125; private static class ArrayItr&lt;E&gt; implements Iterator&lt;E&gt; &#123; private int cursor; private final E[] a; ArrayItr(E[] a) &#123; this.a = a; &#125; @Override public boolean hasNext() &#123; return cursor &lt; a.length; &#125; @Override public E next() &#123; int i = cursor; if (i &gt;= a.length) &#123; throw new NoSuchElementException(); &#125; cursor = i + 1; return a[i]; &#125; &#125; 调用的是Arrays.java内部类的构造方法ArrayList，然而这个静态内部类并没有实现add等相关的方法，怀着好奇心，继续研究源码，发现这个内部类并没有直接实现List接口，而是通过继承AbstractList来间接实现List接口，我们来看看AbstractList的add和remove源码部分： 123456789AbstractList.java public void add(int index, E element) &#123; throw new UnsupportedOperationException(); &#125; public E remove(int index) &#123; throw new UnsupportedOperationException(); &#125; 真相大白有没有，Arrays的静态内部类ArrayList并没有改写从AbstractList继承的源码，那么调用add和remove等相关函数时，就会调用AbstractList实现的相关方法，然而内容只有抛出异常，没有其它相关的实现操作。 2. 那么如何操作转换呢我这里知道的有两种，欢迎━(｀∀´)ノ亻!补充 使用Iterator迭代器，迭代访问赋值 直接使用new ArrayList(Collection&lt;? extends E&gt; c)构造方法，这里注意，ArrayList并没有提供集合以外的参数构造，所以一开始的Integer类型的数组老老实实的迭代添加吧(偷笑), 为什么迭代器，而不是for， get来，效率问题，谷歌去。 总结asList调用的是Arrays.java的静态内部类的构造方法，然而那个方法并没有实现add等相关修改数量大小的方法，也许这就是他们想要的目的，但是内容还是能通过set修改。","tags":[{"name":"随笔","slug":"随笔","permalink":"http://yoursite.com/tags/随笔/"}]},{"title":"javaIO流的总结（更新中）","date":"2018-04-03T14:11:28.000Z","path":"2018/04/03/javaIO-summary/","text":"注意：original Stream（也称为节点流） 和 wrapper Stream（也称为处理流）未包装类和包装类。 java可分为输出流和输入流，根据流类型，可分为字符流和字节流，如下表： 分类 字节流 字符流 输入流 InputStream Reader 输出流 OutputStream Writer 实际使用中我们一般不会用到上面说的四类，而是使用继承它们的子类，不同的子类负责着不同的功能，以便于我开发不同的应用。用途主要有以下几种： 文件访问 网络访问 内存缓存访问 线程内部通信 缓冲 过滤 解析 读写文本，基本数据类型，对象 Java IO 类概述表 该表使用自并发编程网的javaIO 各做基类流继承下去的分为两类，节点的流和处理流：字节节点流只具有读取字节内容的方法，比如FileInputStream流和FileOutputStream流只能向文件中读取或者向文件中写入字节，对于各种类型的数据，如果是写入文件，必须转换成字节数组后写入文件，若是读取，那么就得转换成相应的类型。 而处理流，例如DataOutputStream提供了各种对象中写入类型的方法，方便编程人员。 1. 字节流1.1 InputStream作为基类1.1.1 ByteArrayInputStream 是什么 内部通过建立字节数组buf缓冲区来读取保存数据 适用场景 此流是内存操作流【1】，这个流可实现类似内存虚拟文件的功能，将数据暂存在缓存区中，可以使程序不需要产生相应的临时文件，避免从存储介质上读取，提升效率。 注意 此流不会自动关闭，当没有对其的强引用时，就会自动被GC，但是也会导致内存溢出，可以使用org.apache.commons.io.IoUtiles关闭流 1.1.2 FileInputStream1.1.3 SocketInputStream1.1.4 PipeInputStream1.1.5 BufferedInputStream1.1.6 DataInputStream1.1.7 PushbackInputStream1.1.8 ObjectInputStream1.1.9 SequenceInputStream1.2 OutputStream作为基类1.2.1 PrintStream2. 字符流2.1 Reader作为基类2.1.1 CharArrayReader2.1.2 InputStreamReader2.1.3 FileReader2.1.4 PipedReader2.1.5 StringReader2.1.6 BufferedReader2.1.7 LinNumberReader2.1.8 PushBackReader2.2 Writer作为基类2.2.1 PrintWriter3. RandomAccessFile4. 字符和字节流的转换5.一般使用规则(输入和输出类似)1.按数据来源分类： 文件：FileInputStream, FileReader byte[]: ByteArrayInputStream char[]: CharArrayReader String: StringBufferInputStream, StringReader 网络数据流: InputStream, Reader 2.按是否格式化输出 格式化输出： PrintStream, PrintWriter 3.按是否要缓冲 BufferedInputStream, BufferedReader 4.按数据格式： 字节流： InputStream和OutputStream以及它们的子类 字符流： Reader和Writer以及它们的子类 5.按输入输出： 不用写，都懂 6.特别的： Stream到Reader和Writer的转换类： InputStreamReader和OutputStreamWriter 对象输入输出： ObjectStream, ObjectStream 进程通信： PipeInputStream, PipeReader 合并输入： SequenceInputStream 其它： PushbackInputStream, PushbackReader, LineNumberInputStream, LineNumberReader 6. 构造准则决定使用哪个类以及它的构造进程的一般准则如下（不考虑特殊需要）： 首先，考虑最原始的数据格式是什么： 原则四 第二，是输入还是输出：原则五 第三，是否需要转换流：原则六第 1 点 第四，数据来源（去向）是什么：原则一 第五，是否要缓冲：原则三 （特别注明：一定要注意的是 readLine() 是否有定义，有什么比 read, write 更特殊的输入或输出方法） 第六，是否要格式化输出：原则二 借鉴远志，志在远方 【1】内存操作流： 用于处理临时存储的信息，程序结束，数据就从内存中消失。 字节数组： ByteArrayInputStream ByteArrayOutputStream 字符数组： CharArrayReader CharArrayWriter 字符串： StringReader StringWriter","tags":[{"name":"IO","slug":"IO","permalink":"http://yoursite.com/tags/IO/"}]},{"title":"getResourceAsStream和getSystemResourceAsStream等获取配置文件的路径表示","date":"2018-03-24T16:16:26.000Z","path":"2018/03/25/pro-path/","text":"解释下：包名下都有对应一样的配置文件名，方便确定配置文件的位置，测试类也一样，应该能马上看得出 1.相对路径根据我前面proper的几种读取方式中，只有ClassName.class.getResourceAsStream使用的才是相对路径。 配置文件.properties path kkk kkk/kkk.properties zzz ../../zzz/zzz.properties src ../../src.properties 1. kkk文件在与TestProperUtil同目录下的目录kkk下所以是kkk/文件 2. zzz 文件是在Testxxx上上级也就是src目录下的zzz目录中，其中..是上一级目录的意思 3. src是上上级目录下的文件 2. src下的绝对路径，不包括src的使用方式有三种： ClassLoadergetSystemResourceAsStream ClassName.class.getClassLoader().getResourceAsStream ResourceBundle.getBundle 注意：getBundle那个路径文件不加后缀名 配置文件.properties path kkk properties/test/kkk/kkk.properties zzz zzz/zzz.properties prop properties/prop.properties 1. kkk在src目录下的properties中的test目录的kkk目录下，所以path是properties/test/kkk/kkk.properties 2. zzz 同理 3.关于boot配置文件不知道怎么取得其配置，或者就取不到，希望有人告知，待更新","tags":[{"name":"properties","slug":"properties","permalink":"http://yoursite.com/tags/properties/"}]},{"title":"加载properties配置文件的六种方式","date":"2018-03-23T15:13:20.000Z","path":"2018/03/23/sixWayLoadProperties/","text":"1.是什么？1.1定义.properties是一种主要在java相关技术中用来存储应用程序的可配置参数的文件的文件扩展名。也可以存储用于国际化和本地化的字符串，这种文件被称为属性资源包。 1.2内容与格式 简单来说是类似map的键-值对存储方式，类型都是String字符串。 语法有以下几种： 以#和！号作为一行中的第一个字符表示注释 反斜杠()用于转义 键=值表示 2.适用场合？优缺点，有无可替代对比？ java下常见的几种配置文件格式(在下资历少，只说三种)，其排序。适合人类编写：properties &gt; yaml &gt; xml可以存储数据的复杂度： xml &gt; yaml &gt; properties .properties的优点怕是只有简单这一说法了，缺点就是因为其简单，所以不支持层级关系，而且其文件的编码是ISO-8859-1，又称Latin-1，导致没法加载中文。 xml: 从排序来看，xml是层次结构的，存储内容复杂，但是就拥有了强大的表达能力。缺点分析起来复杂，对人类不太友好，不易阅读，所以一般不是用来让人写的，而是机器间的自我生成和解析，比如javafx图形界面生成的xml文档。 yaml：替代xml。 比xml好的地方有： yaml可读性好 yaml和脚本语言的交互性好 yaml的语法和高级语言类似，进行简单表达 yaml有一个一致性的类型信息模型 yaml易于实现yaml与xml相同的： yaml可以基于流来处理； yaml表达能力强，存储的数据复杂度也高。 综上所述：YAML 是以数据为设计语言的重点的，而不是像 XML 以标记为重点。实事上，正是因为这样一种设计理念使得 YAML 在后来的不少应用中取代XML，成为一种可读性高，易于表达数据序列的编程语言。YAML 和 XML也许只是有其不同的应用场景和使用范围。公认的是，yaml凭借易读性成为xml的对手。 properties可以用于简单的几乎不会变动的配置，如果是一些要经常改动的业务就可以使用yaml类配置 3.怎么用？下文的配置文件路径的具体表示点击跳转链接 先声明下全局变量12private static String basePath = \"src/properties/prop.properties\";private static String name = \"\"; 3.1使用java.util.Properties类的load(InputStream)方法加载properties文件 注意：这里的basepath是src目录开始的路径 1234567891011121314public static String getPath()&#123; try (InputStream in = new BufferedInputStream(new FileInputStream( new File(basePath))))&#123; Properties pro = new Properties(); pro.load(in); name = pro.getProperty(\"name\"); &#125; catch (FileNotFoundException e)&#123; e.printStackTrace(); &#125; catch (IOException e)&#123; e.printStackTrace(); &#125; return name; &#125; 3.2使用java.util.ResourceBundle类的getBudle()方法 注意：这个getBundle()方法的参数只能写成包路径+properties文件名，否则将抛异常,并且路径是使用用src下的包名(不包括src)+文件名的方式 12345public static String getPath()&#123; ResourceBundle rb = ResourceBundle.getBundle(\"properties/test/kkk/kkk\"); name = rb.getString(\"name\"); return name; &#125; 3.3使用java.util.PropertyResourceBudle类的构造函数1234567891011public static String getPath()&#123; try (InputStream in = new BufferedInputStream(new FileInputStream(basePath))) &#123; ResourceBundle rb = new PropertyResourceBundle(in); name = rb.getString(\"name\"); &#125; catch (FileNotFoundException e)&#123; e.printStackTrace(); &#125; catch (IOException e)&#123; e.printStackTrace(); &#125; return name; &#125; 3.4使用class变量的getResourceAsStream()方法注意：getResourceAsStream()方法的参数按格式写到包路径+properties文件名+.后缀 注意：路径使用的是相对路径 123456789101112public static String getPath()&#123; Properties p = new Properties(); try (InputStream in = TestProperUtil.class .getResourceAsStream(\"../../src.properties\"))&#123; p.load(in); name = p.getProperty(\"name\"); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; return name; &#125; 3.5使用class.getClassLoader()所得到的java.lang.ClassLoader的getResourceAsStream()方法getResourceAsStream(name)方法的参数必须是包路径+文件名+.后缀否则会报空指针异常 路径名和3.2一样 1234567891011public static String getPath() &#123; try (InputStream in = TestProperUtil.class.getClassLoader() .getResourceAsStream(\"zzz/zzz.properties\"))&#123; Properties p = new Properties(); p.load(in); name = p.getProperty(\"name\"); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; return name; &#125; 3.6使用java.lang.ClassLoader类的getSystemResourceAsStream()静态方法getSystemResourceAsStream()方法的参数格式也是有固定要求的 注意： 路径名和3.2一样的表示 1234567891011public static String getPath() &#123; try (InputStream in = ClassLoader .getSystemResourceAsStream(\"src.properties\"))&#123; Properties pro = new Properties(); pro.load(in); name = pro.getProperty(\"name\"); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; return name; &#125;","tags":[{"name":"配置文件","slug":"配置文件","permalink":"http://yoursite.com/tags/配置文件/"}]},{"title":"HexoMarkdown","date":"2018-03-22T15:17:08.000Z","path":"2018/03/22/WriteTest/","text":"引言：HexoMd 的语法，基本够用，欢迎补充(能用得到的)与修正，部分细节有待修改（基于主题BlueLake)Markdown 语法版本很多，不同地方部分语法不相兼容，导致网上部分语法不能再hexo上使用，以下是整理的能在hexo的部分语法。 1.Tab字前tab会加灰框 2.#的用法用来表示几级标题 # frist title ## second title ### third title 3.超链接3.1显示链接的图片![name](url) 显示链接的图片 ![this is page](/images/keduoli.jpg) link: 3.2文字超链接[name](url) 文字超链接 [bilibili](https://www.bilibili.com/) bilibili 3.3图片超链接[![xxx](图片url)][要转移到的链接]图片超链接 [![enene](/images/keduoli.jpg)](https://nodesource.com/products/nsolid) 4.列表4.1.1无序列表 -，*，+， 两格缩进，列表与前一行的hello: - one - two - three eg: hello (没有衔接一起很神奇） one two three food bread apple pig ddd mmm 4.1.2两格缩进 （衔接在一起了） 登录微博开放平台，选择。 为了与注意风格统一，如下配置 嗯嗯嗯 （也衔接一起了） 基础设置： dsfs 样式设置： sdfa 模块设置： dsfa 4.2有序列表 序号. xxx(注意有空格） 登录微博开放平台，选择。 为了与注意风格统一，如下配置 嗯嗯嗯 5.用键代替链接，键值对匹配关键字对上跳转的意思吧，[内容]和文章最后的[内容1](链接)对上 可以变成超链接，前后内容忽略大小写，也能匹配。这里注意最后一 个，如果最后几个字也要跳转，单单加[1]没用得再加[2]来达到目 的，此时内容为1，但是跳转到的目的为2 Markdown is a lightweight markup language based on the formatting conventions that people naturally use in email. As [John Gruber] writes on the [Markdown site] Markdown is a lightweight markup language based on the formatting conventions that people naturally use in email.As John Gruber writes on the Markdown site 6.可以用来注意，引用,可以多层&gt; The overriding design goal for Markdown&apos;s &gt;&gt; formatting syntax is to make it as readable &gt; as possible. The idea is that. eg: The overriding design goal for Markdown’s formatting syntax is to make it as readableas possible. The idea is that. 7.代码块代码表示 1 123$ cd dillinger$ npm install -d$ node app eg:123$ cd dillinger$ npm install -d$ node app 123public static void main(String[] args)&#123; System.out.println(\"I think it's good\");&#125; 8.表格制表第一行和第二行列必须对应数量相等 | Plugin | README | sdflj | | ------ | ：------： | -----： | 右对齐，居中，左对齐 | Dropbox | [plugins/dropbox/README.md][PlDb] | dsf | | Github | [plugins/github/README.md][PlGh] | sdf | | Google Drive | [plugins/googledrive/README.md][PlGd] | dsfs | | OneDrive | [plugins/onedrive/README.md][PlOd] | dsfj | | Medium | [plugins/medium/README.md][PlMe] | | Google Analytics | [plugins/googleanalytics/README.md][PlGa] | eg: Plugin README sdflj Dropbox plugins/dropbox/README.md dsf Github plugins/github/README.md sdf Google Drive plugins/googledrive/README.md dsfs OneDrive plugins/onedrive/README.md dsfj Medium plugins/medium/README.md df Google Analytics plugins/googleanalytics/README.md dsdg eg：This will create the dillinger image and pull in the necessary dependencies. Be sure to swap out ${package.json.version} with the actual version of Dillinger. 9.文字9.1文字背景`xxx` 背景颜色加灰 I love `you` red line eg:I love you red line 9.2文字加粗加粗 **Software** Free Software, Hell Yeah! 9.3删除线~~xxx~~ 我喜欢javapython 待更新附录： [dill]: &lt;https://github.com/joemccann/dillinger&gt; [git-repo-url]: &lt;https://github.com/joemccann/dillinger.git&gt; [john gruber]: &lt;http://daringfireball.net&gt; [df1]: &lt;http://daringfireball.net/projects/markdown/&gt; [PlMe]: &lt;https://github.com/joemccann/dillinger/tree/master/plugins/medium/README.md&gt; [PlGa]: &lt;https://github.com/RahulHP/dillinger/blob/master/plugins/googleanalytics/README.md&gt;","tags":[{"name":"markdown","slug":"markdown","permalink":"http://yoursite.com/tags/markdown/"}]},{"title":"Hello World","date":"2018-03-22T09:34:27.055Z","path":"2018/03/22/hello-world/","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","tags":[]}]