[{"title":"抽象类和接口(非blog，Not recommended)(update ing)","date":"2018-04-12T08:54:54.000Z","path":"2018/04/12/abstract-class/","text":"抽象类什么是抽象类首先了解什么是抽象方法，抽象方法就是只声明，没有具体实现，eg如下:1abstract void zzz(); 必须用abstract进行修饰，如果一个类中含有抽象方法，那么称这个类为抽象方法，抽象方法必须也用abstract进行修饰。 注意： 抽象方法不能用来创建对象。这里来自某blog的大佬说在java编程思想中对抽象类的定义为“包含抽象方法的类”，但是后面看源码时有的抽象类其实内部什么方法都没有，然而还是声明成抽象类。算了，细节问题不要在意。 有什么用，用在哪:怎么说，按我的理解，就是为了继承实现多态的，多态的概念就不用解释了 怎么用？(不可能教你怎么用的，自己看书，自己谷歌)注意的问题 访问修饰符里虽然也有提到过，但是抽象类的方法必须为public或者protected，毕竟子类必须有能够访问的能力进行事项 如果子类继承了抽象父类，如果没有全部重写父类的所有抽象方法，那么子类依然是抽象类，依然不能实例化。 接口什么是接口怎么说，可以理解为纯粹的抽象类吧，接口泛指别人调用的方法或者函数，是对行为的抽象（下面对比的时候会解释的） 注意 接口中可以含有 变量和方法。但是要注意，接口中的变量会被隐式地指定为public static final变量（并且只能是public static final变量，用private修饰会报编译错误），而方法会被隐式地指定为public abstract方法且只能是public abstract方法（用其他关键字，比如private、protected、static、 final等修饰会报编译错误），并且接口中所有的方法不能有具体的实现，也就是说，接口中的方法必须都是抽象方法。从这里可以隐约看出接口和抽象类的区别，接口是一种极度抽象的类型，它比抽象类更加“抽象”，并且一般情况下不在接口中定义变量。 重点： 第1个注意点中，只适合老版本，jdk1.8以下的版本，在jdk1.8中接口加入了新概念，扩展了接口的含义：默认方法和静态方法，默认方法使得接口有点类似traits吧，不过要实现的目标不一样。默认方法使得开发者可以在不破坏二进制兼容性的前提下，王现存的接口中添加新的方法，即不强制实现了该接口的类也可同时实现这个新加的方法。（可以通过转换调用）可以看出，默认方法和抽象方法之间的区别在于抽象方法需要实现，而默认方法不需要。接口提供的默认方法会被接口的实现类继承或者覆写。看个简单的例子 12345678910111213141516171819202122private interface Defaulable &#123; // Interfaces now allow default methods, the implementer may or // may not implement (override) them. default String notRequired() &#123; return \"Default implementation\"; &#125; &#125; private static class DefaultableImpl implements Defaulable &#123;&#125; private static class OverridableImpl implements Defaulable &#123; @Override public String notRequired() &#123; return \"Overridden implementation\"; &#125;&#125;//例子来源：（其实是我懒得写）//作者：杜琪//链接：https://www.jianshu.com/p/5b800057f2d8//著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 此默认方法扩充了Collection的方法，比如stream(), parallelStream()等，Stream也是java8的一大亮点，专注于对集合对象进行各种流弊的操作，可以很方便写出高性能的并发程序，偏题了。 那么，抽象类和接口的区别语法层面上的区别（jdk1.8以下版本) 抽象类可以提供成员方法的实现细节，而接口中只能存在public abstract 方法； 抽象类中的成员变量可以是各种类型的，而接口中的成员变量只能是public static final类型的； 接口中不能含有静态代码块以及静态方法，而抽象类可以有静态代码块和静态方法； 一个类只能继承一个抽象类，而一个类却可以实现多个接口。 设计层面上的区别(那么多字，肯定不是我自己写的) 抽象类是对一种事物的抽象，即对类抽象，而接口是对行为的抽象。抽象类是对整个类整体进行抽象，包括属性、行为，但是接口却是对类局部（行为）进行抽象。举个简单的例子，飞机和鸟是不同类的事物，但是它们都有一个共性，就是都会飞。那么在设计的时候，可以将飞机设计为一个类Airplane，将鸟设计为一个类Bird，但是不能将 飞行 这个特性也设计为类，因此它只是一个行为特性，并不是对一类事物的抽象描述。此时可以将 飞行 设计为一个接口Fly，包含方法fly( )，然后Airplane和Bird分别根据自己的需要实现Fly这个接口。然后至于有不同种类的飞机，比如战斗机、民用飞机等直接继承Airplane即可，对于鸟也是类似的，不同种类的鸟直接继承Bird类即可。从这里可以看出，继承是一个 “是不是”的关系，而 接口 实现则是 “有没有”的关系。如果一个类继承了某个抽象类，则子类必定是抽象类的种类，而接口实现则是有没有、具备不具备的关系，比如鸟是否能飞（或者是否具备飞行这个特点），能飞行则可以实现这个接口，不能飞行就不实现这个接口。 设计层面不同，抽象类作为很多子类的父类，它是一种模板式设计。而接口是一种行为规范，它是一种辐射式设计。什么是模板式设计？最简单例子，大家都用过ppt里面的模板，如果用模板A设计了ppt B和ppt C，ppt B和ppt C公共的部分就是模板A了，如果它们的公共部分需要改动，则只需要改动模板A就可以了，不需要重新对ppt B和ppt C进行改动。而辐射式设计，比如某个电梯都装了某种报警器，一旦要更新报警器，就必须全部更新。也就是说对于抽象类，如果需要添加新的方法，可以直接在抽象类中添加具体的实现，子类可以不进行变更；而对于接口则不行，如果接口进行了变更，则所有实现这个接口的类都必须进行相应的改动。 简单来说，抽象类就是个模板类，接口是一种行为规范，就像上面说的辐射式设计，但是，对于新版本的jdk1.8，个人感觉也具有一定模板式设计了，都引入的默认方法了，和抽象类中非抽象方法有什么区别。但是，其设计层面的区别还主要是接口是对行为的抽象，新版本的小疑问以后再做考虑。 接口其它应用应用很多，有与设计模式相关的适配器，工厂模式等，具体详细请看java便构成思想，还有接口为什么优于抽象类等相关问题请看effective java。 补充： 对上面新版本中接口不就是抽象类的进行解释详细见开源中国 参考资料：http://www.importnew.com/18780.htmlhttps://www.jianshu.com/p/038f0b356e9ahttp://arthur503.github.io/blog/2013/10/10/Java-access-control.htmlhttps://www.ibm.com/developerworks/cn/java/j-lo-java8streamapi/","tags":[{"name":"java笔记","slug":"java笔记","permalink":"http://yoursite.com/tags/java笔记/"}]},{"title":"Java访问权限修饰符(非blog，Not recommended)(update ing)","date":"2018-04-12T08:51:23.000Z","path":"2018/04/12/ppt/","text":"引言：java中有四种访问修饰符，public，protected，defaul（实际上没有这个关键词（大概懂我意思吧），就是默认的同一包内访问权限。），private，用于对方法，属性，类的修饰，但是部分可用。 访问权限和使用类别见一下两个表格 表格(一) 修饰符 修饰成员变量和函数 修饰类 public yes yes protected yes no default yes yes private yes no 表格(二) 修饰符 当前类 同一包内 子孙类 其它包 public yes yes yes yes protected yes yes yes no default yes yes no no private yes no no no","tags":[{"name":"java笔记","slug":"java笔记","permalink":"http://yoursite.com/tags/java笔记/"}]},{"title":"easyMock的简单使用（详细见参考官方文档，第二问更新中）","date":"2018-04-09T12:14:44.000Z","path":"2018/04/09/easyMock-simple-use/","text":"引言： 本文采取的例子来自 EasyMock tutorial – Getting Started（就是原文啦） 什么是Mock？Mock其实就是模拟或者Stud，当你调用一个不好在测试中创建的对象时，Mock框架为你模拟一个和真实对象类似的数据类完成相应的行为。 比如说：我接下来要写的股票问题，首先，股价时刻都在变动，我们一旦获取了当前的股价，并不代表一定是正确的数据，因为真实的股价是时刻都在变动的，所以我们要模拟一个检索股票的接口来获取数据，而不是去访问真实的服务器。 与PowerMock和JMock相比如今比较流行的工具JMock，EasyMock，Mockito等都有一个共同的缺点，就是不能mock静态，final，私有方法(但是可以mock类哦，前提类内部也没有以上属性的方法），而PowerMock能够完美的弥补以上三个Mock的不足（扩充而不是替代，可以提高代码测试的覆盖率，天哪，我到底为什么才知道），自行百度吧。（似乎还有个全能的Jmokit，等研究好了再补充）某个工作的作者遇到坑，但是本萌现在还看不懂，大概因为用的是PowerMock，本萌还没学 简单用法：这里我们用一个简单的例子来简单的入门easyMock的用法。 股票计算应用引言：首先，这个应用有一个接口，两个实体类和一个测试类。 Stock类是用来表示股票的信息，含股票名和数量（我们可以想象成数据库所学的emp类） Portfolio类保存不同股票的信息（想象成emplist一样，里面存着各种人员的信息），这个类中有一个计算所有股票价格的总和的方法getTotalValue()，我们要测试的就是这个方法。 StockMarket接口，也就是股市的意思，就是我们要模拟的接口，模拟这个接口里getPrice的数据 内容：上代码，首先是实体类Stock12345678910111213141516171819202122232425262728293031Stock.javapublic class Stock &#123; /** * Stock类用来存储股票的信息，名字和类型, 联想一下就是实体类emp */ private String name; private int quantity; public Stock (String name, int quantity)&#123; this.name = name; this.quantity = quantity; &#125; public String getName()&#123; return name; &#125; public void setName(String name)&#123; this.name = name; &#125; public int getQuantity()&#123; return quantity; &#125; public void setQuantity(int quantity)&#123; this.quantity = quantity; &#125;&#125; 然后是Protfolio类 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859import java.util.ArrayList;import java.util.List;public class Protfolio &#123; /** *注意：硬编码依赖不是好的实践，我们不应该在此初始化stockMarket对象， *我们应该在使用测试代码的时候注入进来。(这里就先这样了） */ // 某个投资的名，这里不重要 private String name; // 模拟的接口，这里就当成是实际存在的进行使用 private StockMarket stockMarket; // 保存股票的信息 private List&lt;Stock&gt; stocks = new ArrayList&lt;&gt;(); /** * 计算所有股票是价格，并返回 * sock保存的各个股票的数量乘以通过接口stockMarket模拟获取的价格求和 */ public double getTotalValue()&#123; double value = 0.0; for (Stock stock: this.stocks)&#123; value += (stockMarket.getPrice(stock.getName()) * stock.getQuantity()); &#125; return value; &#125; public void addStock(Stock stock)&#123; stocks.add(stock); &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public StockMarket getStockMarket() &#123; return stockMarket; &#125; public void setStockMarket(StockMarket stockMarket) &#123; this.stockMarket = stockMarket; &#125; public List&lt;Stock&gt; getStocks() &#123; return stocks; &#125; public void setStocks(List&lt;Stock&gt; stocks) &#123; this.stocks = stocks; &#125;&#125; 以上就是所有业务的逻辑，很简单吧，sock股票信息，Port进行处理，stockMarket获取价格 然后是Junit和EasyMock测试Portfolio中的getTotalValue()方法 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748ProtfolioTest.javaimport com.wlq.easymock.dao.StockMarket;import com.wlq.easymock.entity.Protfolio;import com.wlq.easymock.entity.Stock;import org.easymock.EasyMock;import org.junit.Before;import org.junit.Test;import static org.junit.Assert.*;public class ProtfolioTest &#123; private Protfolio protfolio; private StockMarket marketMock; @Before public void setUp() throws Exception &#123; protfolio = new Protfolio(); protfolio.setName(\"wlq's portfolip.\"); // 模拟创建（StockMarket）股市的实例 marketMock = EasyMock.createMock(StockMarket.class); // 将模拟实例对象赋给股票列表 protfolio.setStockMarket(marketMock); &#125; @Test public void getTotalValue() &#123; // 用我们期望的返回值来配置模拟对象，当getPrice参数是EBAY时，返回的数值为42.00 EasyMock.expect(marketMock.getPrice(\"EBAY\")).andReturn(42.00); // 这个replay不要忘记，将mock进行重放，否则会IllegalStateException //异常和一个没有什么帮助的错误消息： //missing behavior definition for the preceding method call。 EasyMock.replay(marketMock); // 开始测试 Stock ebayStock = new Stock(\"EBAY\", 2); protfolio.addStock(ebayStock); // 这里使用的是org.junit下的断言，在4.12的javadoc中中已经没有没有junit.framework的 // 内容了，但是为了兼容，4.12版本中还会对其进行保留 // 在junit4中这个方法似乎被弃用了可以添加第三个参数代表误差 // 弃用： assertEquals(84.00, protfolio.getTotalValue()); assertEquals(84.00, protfolio.getTotalValue(), 0); &#125;&#125; 总结： 先 EasyMock.createMock(xxxx.class) 创建模拟接口返回的对象 然后就是正常使用接口的实例操作 配置模拟对象，在什么条件下做什么 EasyMock.expect(模拟的对象实例.xxx方法()).xxx返回的东西或者要做的事() EasyMock.replay(实例对象) 开始正常逻辑测试。","tags":[{"name":"Junit","slug":"Junit","permalink":"http://yoursite.com/tags/Junit/"},{"name":"easyMock","slug":"easyMock","permalink":"http://yoursite.com/tags/easyMock/"}]},{"title":"IDEA中dependencies和libraries的区别","date":"2018-04-09T11:50:06.000Z","path":"2018/04/09/dependencies-and-libraries/","text":"我觉得，idea中的dependencies和eclipse中的build path差不多，在eclipse中先将jar文件放入某个lib文件夹下然后add build path 其实通过意思可以看出，dependencies是依赖，libraries是库，dependencies中 添加jar包或者目录就是eclipse中的buildpath，libraries就是集中包的一个目录， 用来集中批量管理包。（目前理解就是这些，有错求指正）","tags":[{"name":"idea","slug":"idea","permalink":"http://yoursite.com/tags/idea/"},{"name":"随笔","slug":"随笔","permalink":"http://yoursite.com/tags/随笔/"}]},{"title":"idea-webApp简单运行环境配置","date":"2018-04-08T04:41:10.000Z","path":"2018/04/08/idea-webApp-simple/","text":"首先在web下创建两个目录，分别为lib和classes，classe保存编译后的.class文件，lib保存需要的jar包。 打开project Setting, 选择modules，点击paths，把两个path路径改成第一步骤下的classes路径。 点击path旁边的dependencies进行Tomcat的添加，点击+选择Library，选择Tomcat进行添加。或者先在librarys添加相应的包，再去dependencies添加。 配置Tomcat文件，edit Configurations，点击+，选择Tomcat，local Tomcat，Server部分进行相关配置，然后对deployment点击+添加artifact，webxxxxx啥的。 运行下试试。","tags":[{"name":"idea","slug":"idea","permalink":"http://yoursite.com/tags/idea/"},{"name":"随笔","slug":"随笔","permalink":"http://yoursite.com/tags/随笔/"},{"name":"applet","slug":"applet","permalink":"http://yoursite.com/tags/applet/"}]},{"title":"javaIO流的总结（更新中）","date":"2018-04-07T14:11:28.000Z","path":"2018/04/07/IO/javaIO-summary/","text":"引言：这里不会讲各种流的详细用法。 注意：original Stream（也称为节点流） 和 wrapper Stream（也称为处理流）未包装类和包装类。 java可分为输出流和输入流，根据流类型，可分为字符流和字节流，如下表： 分类 字节流 字符流 输入流 InputStream Reader 输出流 OutputStream Writer 实际使用中我们一般不会用到上面说的四类，而是使用继承它们的子类，不同的子类负责着不同的功能，以便于我开发不同的应用。用途主要有以下几种： 文件访问 网络访问 内存缓存访问 线程内部通信 缓冲 过滤 解析 读写文本，基本数据类型，对象 Java IO 类概述表 该表使用自并发编程网的javaIO 各做基类流继承下去的分为两类，节点的流和处理流：字节节点流只具有读取字节内容的方法，比如FileInputStream流和FileOutputStream流只能向文件中读取或者向文件中写入字节，对于各种类型的数据，如果是写入文件，必须转换成字节数组后写入文件，若是读取，那么就得转换成相应的类型。 而处理流，例如DataOutputStream提供了各种对象中写入类型的方法，方便编程人员。 1. 字节流1.1 InputStream作为基类1.1.1 ByteArrayInputStream 内部通过建立字节数组buf缓冲区来读取保存数据 适用场景:此流是内存操作流，这个流可实现类似内存虚拟文件的功能，将数据暂存在缓存区中，可以使程序不需要产生相应的临时文件，避免从存储介质上读取，提升效率。 注意:此流没有提供close关闭流的操作，当没有对其的强引用时，就会自动被GC，但是也会导致内存溢出，可以使用org.apache.commons.io.IoUtiles关闭流 1.1.2 FileInputStream 把一个文件作为文件输入流，实现对文件的读取操作，访问硬盘 适用场景:从名字上就能看出应用，对硬盘上的文件的存取 1.1.3 SocketInputStream 就和名字一样，适用于网络通信中。 1.1.4 PipeInputStream 通多创建管道实现线程间的通信 1.1.5 BufferedInputStream 本质是通过一个内部缓冲数组实现的，默认大小8192，实现滑动读取的功能，事先把size大小的数据从磁盘中读取到缓冲区上，然后实际操作都在缓冲区中进行，如果数据超过缓冲区，那么将重新载入数据。减少了磁盘IO，提高了效率。 用途：因为其缓存的功能，可以起到改善效率的作用。通过源码可以看出，构造器的形参是InputStream，所以可以对其进行改善效率，包括FileInputStream等，比如： 12BufferedInputStream bufferedInputStream = new BufferedInputStream(new FileInputStream(\"zzz.txt\")); 1.1.6 DataInputStream 封装了对字节流的解析，实现了对基本数据类型的基本操作和对读取UTF格式的方法，当然，读取字符的还有Rread等相关的字符流。 1.1.7 PushbackInputStream 回推流，把从缓存区中读出来的数据再原路推回去，没有破坏输入流里的内容结构。 注意：PushbackInputStream对象会使得InputStream对象（用于创建PushbackInputStream对象）的mark()或reset()方法无效。对于准备使用mark()或reset()方法的任何流来说，都应当使用markSupported()方法进行检查。 1.1.8 ObjectInputStream与ObjectOutputStream ObjectOutputStream 将 Java 对象的基本数据类型和图形写入 OutputStream。可以使用 ObjectInputStream 读取（重构）对象。通过在流中使用文件可以实现对象的持久存储。如果流是网络套接字流，则可以在另一台主机上或另一个进程中重构对象。只能将支持 java.io.Serializable 接口的对象写入流中。每个 serializable 对象的类都被编码，编码内容包括类名和类签名、对象的字段值和数组值，以及从初始对象中引用的其他所有对象的闭包。writeObject 方法用于将对象写入流中。所有对象（包括 String 和数组）都可以通过 writeObject 写入。可将多个对象或基元写入流中。必须使用与写入对象时相同的类型和顺序从相应 ObjectInputstream 中读回对象。 1.1.9 SequenceInputStream 合并流，将多个源合并成一个源 1.2 OutputStream作为基类1.2.1 PrintStream PrintStream 是打印输出流，它继承于FilterOutputStream。PrintStream 是用来装饰其它输出流。它能为其他输出流添加了功能，使它们能够方便地打印各种数据值表示形式。与其他输出流不同，PrintStream 永远不会抛出 IOException；它产生的IOException会被自身的函数所捕获并设置错误标记， 用户可以通过 checkError() 返回错误标记，从而查看PrintStream内部是否产生了IOException。另外，PrintStream 提供了自动flush 和 字符集设置功能。所谓自动flush，就是往PrintStream写入的数据会立刻调用flush()函数。 这里对比一下PrintStream和DataOutputStream（原文链接)相同点：都是继承与FileOutputStream，用于包装其它输出流。不同点： (01) PrintStream和DataOutputStream 都可以将数据格式化输出；但它们在“输出字符串”时的编码不同。 PrintStream是输出时采用的是用户指定的编码(创建PrintStream时指定的)，若没有指定，则采用系统默认的字符编码。而DataOutputStream则采用的是UTF-8。关于UTF-8的字符编码可以参考“字符编码(ASCII，Unicode和UTF-8) 和 大小端”关于DataOutputStream的更多内容，可以参考“java io系列15之 DataOutputStream(数据输出流)的认知、源码和示例” (02) 它们的写入数据时的异常处理机制不同。 DataOutputStream在通过write()向“输出流”中写入数据时，若产生IOException，会抛出。而PrintStream在通过write()向“输出流”中写入数据时，若产生IOException，则会在write()中进行捕获处理；并设置trouble标记(用于表示产生了异常)为true。用户可以通过checkError()返回trouble值，从而检查输出流中是否产生了异常。 (03) 构造函数不同 DataOutputStream的构造函数只有一个：DataOutputStream(OutputStream out)。即它只支持以输出流out作为“DataOutputStream的输出流”。而PrintStream的构造函数有许多：和DataOutputStream一样，支持以输出流out作为“PrintStream输出流”的构造函数；还支持以“File对象”或者“String类型的文件名对象”的构造函数。而且，在PrintStream的构造函数中，能“指定字符集”和“是否支持自动flush()操作”。 (04) 目的不同 DataOutputStream的作用是装饰其它的输出流，它和DataInputStream配合使用：允许应用程序以与机器无关的方式从底层输入流中读写java数据类型。而PrintStream的作用虽然也是装饰其他输出流，但是它的目的不是以与机器无关的方式从底层读写java数据类型；而是为其它输出流提供打印各种数据值表示形式，使其它输出流能方便的通过print(), println()或printf()等输出各种格式的数据。 2. 字符流2.1 Reader作为基类2.1.1 CharArrayReader2.1.2 InputStreamReader2.1.3 FileReader2.1.4 PipedReader2.1.5 StringReader2.1.6 BufferedReader2.1.7 LinNumberReader2.1.8 PushBackReader2.2 Writer作为基类2.2.1 PrintWriter3. RandomAccessFile4. 字符和字节流的转换5.一般使用规则(输入和输出类似)1.按数据来源分类： 文件：FileInputStream, FileReader byte[]: ByteArrayInputStream char[]: CharArrayReader String: StringBufferInputStream, StringReader 网络数据流: InputStream, Reader 2.按是否格式化输出 格式化输出： PrintStream, PrintWriter 3.按是否要缓冲 BufferedInputStream, BufferedReader 4.按数据格式： 字节流： InputStream和OutputStream以及它们的子类 字符流： Reader和Writer以及它们的子类 5.按输入输出： 不用写，都懂 6.特别的： Stream到Reader和Writer的转换类： InputStreamReader和OutputStreamWriter 对象输入输出： ObjectStream, ObjectStream 进程通信： PipeInputStream, PipeReader 合并输入： SequenceInputStream 其它： PushbackInputStream, PushbackReader, LineNumberInputStream, LineNumberReader 6. 构造准则决定使用哪个类以及它的构造进程的一般准则如下（不考虑特殊需要）： 首先，考虑最原始的数据格式是什么： 原则四 第二，是输入还是输出：原则五 第三，是否需要转换流：原则六第 1 点 第四，数据来源（去向）是什么：原则一 第五，是否要缓冲：原则三 （特别注明：一定要注意的是 readLine() 是否有定义，有什么比 read, write 更特殊的输入或输出方法） 第六，是否要格式化输出：原则二 借鉴远志，志在远方 【1】内存操作流： 用于处理临时存储的信息，程序结束，数据就从内存中消失。 字节数组： ByteArrayInputStream ByteArrayOutputStream 字符数组： CharArrayReader CharArrayWriter 字符串： StringReader StringWriter","tags":[{"name":"IO","slug":"IO","permalink":"http://yoursite.com/tags/IO/"}]},{"title":"java中自动拆装箱的一些问题","date":"2018-04-05T07:08:41.000Z","path":"2018/04/05/auto-unpacking-packing/","text":"引言： 直接进入正题，我就当大家都知道什么是拆箱和装箱了，这里主要讨论的是不清楚原理导致产生一些奇怪问题的内容，想看详细介绍的跳到这边：深入剖析java中的装箱和拆箱，这边感谢原作者对反编译class文件的解析，让我理解原理，下面会使用原作者的部分内容以及讲解一些原作者没解析的一些内容。 1. 拆箱和装箱时如何实现的 通过反编译的文件可以了解到（见下图），装箱时自动调用的是valueof()方法，而拆箱的时候自动调用的是xxxValue()方法。 2. 遇到的相关问题2.1 看下面的代码123456789101112public class Main &#123; public static void main(String[] args) &#123; Integer i1 = 100; Integer i2 = 100; Integer i3 = 200; Integer i4 = 200; System.out.println(i1==i2); System.out.println(i3==i4); &#125;&#125; 结果是： true false 神奇吧，出乎意料，以前没有深入了解，有人提到后就去分析了源码，看看Integer valueOf的部分源码实现 12345678Integer.java @HotSpotIntrinsicCandidate public static Integer valueOf(int i) &#123; if (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high) return IntegerCache.cache[i + (-IntegerCache.low)]; return new Integer(i); &#125; 通过源码的实现可以看出，有IntegerCache类参与，其实是Integer的一个内部类，源码如下： 1234567891011121314151617181920212223242526272829303132333435Integer.java private static class IntegerCache &#123; static final int low = -128; static final int high; static final Integer cache[]; static &#123; // high value may be configured by property int h = 127; String integerCacheHighPropValue = VM.getSavedProperty(\"java.lang.Integer.IntegerCache.high\"); if (integerCacheHighPropValue != null) &#123; try &#123; int i = parseInt(integerCacheHighPropValue); i = Math.max(i, 127); // Maximum array size is Integer.MAX_VALUE h = Math.min(i, Integer.MAX_VALUE - (-low) -1); &#125; catch( NumberFormatException nfe) &#123; // If the property cannot be parsed into an int, ignore it. &#125; &#125; high = h; cache = new Integer[(high - low) + 1]; int j = low; for(int k = 0; k &lt; cache.length; k++) cache[k] = new Integer(j++); // range [-128, 127] must be interned (JLS7 5.1.7) assert IntegerCache.high &gt;= 127; &#125; private IntegerCache() &#123;&#125; &#125; 通过源码可以看出，通过valueOf方法创建Integer对象，如果数值在-128到127之间(具体最大值还要看vm的配置)，直接返回IntegerCache中存在的引用，否则返回新的对象，就能解释true和false的问题了。 2.2 那么再来看一个问题123456789101112public class Main &#123; public static void main(String[] args) &#123; Double i1 = 100.0; Double i2 = 100.0; Double i3 = 200.0; Double i4 = 200.0; System.out.println(i1==i2); System.out.println(i3==i4); &#125;&#125; 结果是： false false 又错了吧，应该好好再看看源码的，可恶，没错Double类的valueOf源码的实现和Integet不一样，这里就不贴源码了，看的真心疼，大佬们的代码能力真的是很强。回到问题，源码中Double并没有像Integer那个有规定cache数组等相关的操作，大概我们能使用到double的地方的话代表精度很大，没必要吧，所以Double每次的装箱都是返回新的对象。 总结下： Integer，Short，Byte，Character，Long这几个类的valueOf类似，Double，Float的类似 2.3 这里原作者还提到了boolean变量，看例子12345678910111213141516public class Main &#123; public static void main(String[] args) &#123; Boolean i1 = false; Boolean i2 = false; Boolean i3 = true; Boolean i4 = true; System.out.println(i1==i2); System.out.println(i3==i4); &#125;&#125;// 结果： true true 通过源码可以很直接的看出 12345Boolean.javapublic static Boolean valueOf(boolean b) &#123; return (b ? TRUE : FALSE);&#125; emememem，很简单直观，看看True和False 1234Boolean.javapublic static final Boolean TRUE = new Boolean(true);public static final Boolean FALSE = new Boolean(false); 可以看出，是类成员属性 2.4 Integer i = new Integer(xxx)和Integer i =xxx;这两种方式的区别。（没错，这里copy原文）当然，这个题目属于比较宽泛类型的。但是要点一定要答上，我总结一下主要有以下这两点区别： 第一种方式不会触发自动装箱的过程；而第二种方式会触发； 在执行效率和资源占用上的区别。第二种方式的执行效率和资源占用在一般性情况下要优于第一种情况（注意这并不是绝对的）。 2.5 看下面完整的例子这里就当做读者都了解 == 和 equals 的区别了 12345678910111213141516171819202122// 引用原作者的例子强行解释public class Main &#123; public static void main(String[] args) &#123; Integer a = 1; Integer b = 2; Integer c = 3; Integer d = 3; Integer e = 321; Integer f = 321; Long g = 3L; Long h = 2L; System.out.println(c==d); //1.true System.out.println(e==f); //2.false System.out.println(c==(a+b)); //3.true System.out.println(c.equals(a+b)); //4.true System.out.println(g==(a+b)); //5.true System.out.println(g.equals(a+b)); //6.false System.out.println(g.equals(a+h)); //7.true &#125;&#125; 这里挑几点讲解 第3点，1+2触发自动拆箱，和c比较的是数值是否相等 第4点，a+b先触发拆箱求和后再触发装箱，调用valueOf方法 这里对比第6点和第7点：a+b通过拆装箱最后还是Integer类型，g调用的是Long类型的equals，看下面的源码，先比较的是类型，由于类型不对，所以false；这里看看第7点，h是long类型，所以a+b会隐式转换成long的类型，与g类型相同。 相关类型的的equals源码1234567891011121314151617Integer.java public boolean equals(Object obj) &#123; if (obj instanceof Integer) &#123; return value == ((Integer)obj).intValue(); &#125; return false; &#125;Long.java public boolean equals(Object obj) &#123; if (obj instanceof Long) &#123; return value == ((Long)obj).longValue(); &#125; return false; &#125;","tags":[{"name":"随笔","slug":"随笔","permalink":"http://yoursite.com/tags/随笔/"}]},{"title":"关于java.lang.UnsupportedOperationException异常","date":"2018-04-05T03:37:56.000Z","path":"2018/04/05/asListException/","text":"引言： 这里感谢我们的组长提出这个问题，然后我去查看源码后发现了导致这个问题的原因。 1. 是什么，原因在调用Arrays类的aslist函数把数组转换成List集合不能对其进行添加删除等操作，否则抛出UnsupportedOperationException的异常，代码如下： 123456789101112131415zzz.javapackage Test;import java.util.Arrays;import java.util.List;public class zzz &#123; public static void main(String[] args) &#123; Integer[] arr = &#123;1, 2, 3, 4&#125;; List&lt;Integer&gt; list = Arrays.asList(arr); list.add(3); //error list.remove(2); //error &#125;&#125; 运行代码将抛出一下错误： 1234Exception in thread \"main\" java.lang.UnsupportedOperationException at java.base/java.util.AbstractList.add(AbstractList.java:153) at java.base/java.util.AbstractList.add(AbstractList.java:111) at Test.zzz.main(zzz.java:10) 根据字面意思，unsupportedOperationException就是对该实例不支持相应的函数操作。 也许有人问，list接口明明提供相应的接口，并且ArrayList明明实现了add等操作函数，为什么不支持。问题就在这，aslist返回的ArrayList实例并不是我们之前学的Arraylist的实例，而是Arrays类的静态内部类的实例，看源码 12345Arrays.java public static &lt;T&gt; List&lt;T&gt; asList(T... a) &#123; return new ArrayList&lt;&gt;(a); &#125; asList的源码，跟踪ArrayList的创建方法，继续看源码。只需要注意继承和实现类和接口还有实现的相关函数，直接跳到解析部分： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126Arrays.java /** * @serial include */ private static class ArrayList&lt;E&gt; extends AbstractList&lt;E&gt; implements RandomAccess, java.io.Serializable &#123; private static final long serialVersionUID = -2764017481108945198L; private final E[] a; ArrayList(E[] array) &#123; a = Objects.requireNonNull(array); &#125; @Override public int size() &#123; return a.length; &#125; @Override public Object[] toArray() &#123; return Arrays.copyOf(a, a.length, Object[].class); &#125; @Override @SuppressWarnings(\"unchecked\") public &lt;T&gt; T[] toArray(T[] a) &#123; int size = size(); if (a.length &lt; size) return Arrays.copyOf(this.a, size, (Class&lt;? extends T[]&gt;) a.getClass()); System.arraycopy(this.a, 0, a, 0, size); if (a.length &gt; size) a[size] = null; return a; &#125; @Override public E get(int index) &#123; return a[index]; &#125; @Override public E set(int index, E element) &#123; E oldValue = a[index]; a[index] = element; return oldValue; &#125; @Override public int indexOf(Object o) &#123; E[] a = this.a; if (o == null) &#123; for (int i = 0; i &lt; a.length; i++) if (a[i] == null) return i; &#125; else &#123; for (int i = 0; i &lt; a.length; i++) if (o.equals(a[i])) return i; &#125; return -1; &#125; @Override public boolean contains(Object o) &#123; return indexOf(o) &gt;= 0; &#125; @Override public Spliterator&lt;E&gt; spliterator() &#123; return Spliterators.spliterator(a, Spliterator.ORDERED); &#125; @Override public void forEach(Consumer&lt;? super E&gt; action) &#123; Objects.requireNonNull(action); for (E e : a) &#123; action.accept(e); &#125; &#125; @Override public void replaceAll(UnaryOperator&lt;E&gt; operator) &#123; Objects.requireNonNull(operator); E[] a = this.a; for (int i = 0; i &lt; a.length; i++) &#123; a[i] = operator.apply(a[i]); &#125; &#125; @Override public void sort(Comparator&lt;? super E&gt; c) &#123; Arrays.sort(a, c); &#125; @Override public Iterator&lt;E&gt; iterator() &#123; return new ArrayItr&lt;&gt;(a); &#125; &#125; private static class ArrayItr&lt;E&gt; implements Iterator&lt;E&gt; &#123; private int cursor; private final E[] a; ArrayItr(E[] a) &#123; this.a = a; &#125; @Override public boolean hasNext() &#123; return cursor &lt; a.length; &#125; @Override public E next() &#123; int i = cursor; if (i &gt;= a.length) &#123; throw new NoSuchElementException(); &#125; cursor = i + 1; return a[i]; &#125; &#125; 调用的是Arrays.java内部类的构造方法ArrayList，然而这个静态内部类并没有实现add等相关的方法，怀着好奇心，继续研究源码，发现这个内部类并没有直接实现List接口，而是通过继承AbstractList来间接实现List接口，我们来看看AbstractList的add和remove源码部分： 123456789AbstractList.java public void add(int index, E element) &#123; throw new UnsupportedOperationException(); &#125; public E remove(int index) &#123; throw new UnsupportedOperationException(); &#125; 真相大白有没有，Arrays的静态内部类ArrayList并没有改写从AbstractList继承的源码，那么调用add和remove等相关函数时，就会调用AbstractList实现的相关方法，然而内容只有抛出异常，没有其它相关的实现操作。 2. 那么如何操作转换呢我这里知道的有两种，欢迎━(｀∀´)ノ亻!补充 使用Iterator迭代器，迭代访问赋值 直接使用new ArrayList(Collection&lt;? extends E&gt; c)构造方法，这里注意，ArrayList并没有提供集合以外的参数构造，所以一开始的Integer类型的数组老老实实的迭代添加吧(偷笑), 为什么迭代器，而不是for， get来，效率问题，谷歌去。 总结asList调用的是Arrays.java的静态内部类的构造方法，然而那个方法并没有实现add等相关修改数量大小的方法，也许这就是他们想要的目的，但是内容还是能通过set修改。","tags":[{"name":"随笔","slug":"随笔","permalink":"http://yoursite.com/tags/随笔/"}]},{"title":"getResourceAsStream和getSystemResourceAsStream等获取配置文件的路径表示","date":"2018-03-24T16:16:26.000Z","path":"2018/03/25/pro-path/","text":"解释下：包名下都有对应一样的配置文件名，方便确定配置文件的位置，测试类也一样，应该能马上看得出 1.相对路径根据我前面proper的几种读取方式中，只有ClassName.class.getResourceAsStream使用的才是相对路径。 配置文件.properties path kkk kkk/kkk.properties zzz ../../zzz/zzz.properties src ../../src.properties 1. kkk文件在与TestProperUtil同目录下的目录kkk下所以是kkk/文件 2. zzz 文件是在Testxxx上上级也就是src目录下的zzz目录中，其中..是上一级目录的意思 3. src是上上级目录下的文件 2. src下的绝对路径，不包括src的使用方式有三种： ClassLoadergetSystemResourceAsStream ClassName.class.getClassLoader().getResourceAsStream ResourceBundle.getBundle 注意：getBundle那个路径文件不加后缀名 配置文件.properties path kkk properties/test/kkk/kkk.properties zzz zzz/zzz.properties prop properties/prop.properties 1. kkk在src目录下的properties中的test目录的kkk目录下，所以path是properties/test/kkk/kkk.properties 2. zzz 同理 3.关于boot配置文件不知道怎么取得其配置，或者就取不到，希望有人告知，待更新","tags":[{"name":"properties","slug":"properties","permalink":"http://yoursite.com/tags/properties/"}]},{"title":"加载properties配置文件的六种方式","date":"2018-03-23T15:13:20.000Z","path":"2018/03/23/sixWayLoadProperties/","text":"1.是什么？1.1定义.properties是一种主要在java相关技术中用来存储应用程序的可配置参数的文件的文件扩展名。也可以存储用于国际化和本地化的字符串，这种文件被称为属性资源包。 1.2内容与格式 简单来说是类似map的键-值对存储方式，类型都是String字符串。 语法有以下几种： 以#和！号作为一行中的第一个字符表示注释 反斜杠(\\)用于转义 键=值表示 2.适用场合？优缺点，有无可替代对比？ java下常见的几种配置文件格式(在下资历少，只说三种)，其排序。适合人类编写：properties &gt; yaml &gt; xml可以存储数据的复杂度： xml &gt; yaml &gt; properties .properties的优点怕是只有简单这一说法了，缺点就是因为其简单，所以不支持层级关系，而且其文件的编码是ISO-8859-1，又称Latin-1，导致没法加载中文。 xml: 从排序来看，xml是层次结构的，存储内容复杂，但是就拥有了强大的表达能力。缺点分析起来复杂，对人类不太友好，不易阅读，所以一般不是用来让人写的，而是机器间的自我生成和解析，比如javafx图形界面生成的xml文档。 yaml：替代xml。 比xml好的地方有： yaml可读性好 yaml和脚本语言的交互性好 yaml的语法和高级语言类似，进行简单表达 yaml有一个一致性的类型信息模型 yaml易于实现yaml与xml相同的： yaml可以基于流来处理； yaml表达能力强，存储的数据复杂度也高。 综上所述：YAML 是以数据为设计语言的重点的，而不是像 XML 以标记为重点。实事上，正是因为这样一种设计理念使得 YAML 在后来的不少应用中取代XML，成为一种可读性高，易于表达数据序列的编程语言。YAML 和 XML也许只是有其不同的应用场景和使用范围。公认的是，yaml凭借易读性成为xml的对手。 properties可以用于简单的几乎不会变动的配置，如果是一些要经常改动的业务就可以使用yaml类配置 3.怎么用？下文的配置文件路径的具体表示点击跳转链接 先声明下全局变量12private static String basePath = \"src/properties/prop.properties\";private static String name = \"\"; 3.1使用java.util.Properties类的load(InputStream)方法加载properties文件 注意：这里的basepath是src目录开始的路径 1234567891011121314public static String getPath()&#123; try (InputStream in = new BufferedInputStream(new FileInputStream( new File(basePath))))&#123; Properties pro = new Properties(); pro.load(in); name = pro.getProperty(\"name\"); &#125; catch (FileNotFoundException e)&#123; e.printStackTrace(); &#125; catch (IOException e)&#123; e.printStackTrace(); &#125; return name; &#125; 3.2使用java.util.ResourceBundle类的getBudle()方法 注意：这个getBundle()方法的参数只能写成包路径+properties文件名，否则将抛异常,并且路径是使用用src下的包名(不包括src)+文件名的方式 12345public static String getPath()&#123; ResourceBundle rb = ResourceBundle.getBundle(\"properties/test/kkk/kkk\"); name = rb.getString(\"name\"); return name; &#125; 3.3使用java.util.PropertyResourceBudle类的构造函数1234567891011public static String getPath()&#123; try (InputStream in = new BufferedInputStream(new FileInputStream(basePath))) &#123; ResourceBundle rb = new PropertyResourceBundle(in); name = rb.getString(\"name\"); &#125; catch (FileNotFoundException e)&#123; e.printStackTrace(); &#125; catch (IOException e)&#123; e.printStackTrace(); &#125; return name; &#125; 3.4使用class变量的getResourceAsStream()方法注意：getResourceAsStream()方法的参数按格式写到包路径+properties文件名+.后缀 注意：路径使用的是相对路径 123456789101112public static String getPath()&#123; Properties p = new Properties(); try (InputStream in = TestProperUtil.class .getResourceAsStream(\"../../src.properties\"))&#123; p.load(in); name = p.getProperty(\"name\"); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; return name; &#125; 3.5使用class.getClassLoader()所得到的java.lang.ClassLoader的getResourceAsStream()方法getResourceAsStream(name)方法的参数必须是包路径+文件名+.后缀否则会报空指针异常 路径名和3.2一样 1234567891011public static String getPath() &#123; try (InputStream in = TestProperUtil.class.getClassLoader() .getResourceAsStream(\"zzz/zzz.properties\"))&#123; Properties p = new Properties(); p.load(in); name = p.getProperty(\"name\"); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; return name; &#125; 3.6使用java.lang.ClassLoader类的getSystemResourceAsStream()静态方法getSystemResourceAsStream()方法的参数格式也是有固定要求的 注意： 路径名和3.2一样的表示 1234567891011public static String getPath() &#123; try (InputStream in = ClassLoader .getSystemResourceAsStream(\"src.properties\"))&#123; Properties pro = new Properties(); pro.load(in); name = pro.getProperty(\"name\"); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; return name; &#125;","tags":[{"name":"配置文件","slug":"配置文件","permalink":"http://yoursite.com/tags/配置文件/"}]},{"title":"HexoMarkdown","date":"2018-03-22T15:17:08.000Z","path":"2018/03/22/WriteTest/","text":"引言：HexoMd 的语法，基本够用，欢迎补充(能用得到的)与修正，部分细节有待修改（基于主题BlueLake)Markdown 语法版本很多，不同地方部分语法不相兼容，导致网上部分语法不能再hexo上使用，以下是整理的能在hexo的部分语法。 1.Tab字前tab会加灰框 2.#的用法用来表示几级标题 # frist title ## second title ### third title 3.超链接3.1显示链接的图片![name](url) 显示链接的图片 ![this is page](/images/keduoli.jpg) link: 3.2文字超链接[name](url) 文字超链接 [bilibili](https://www.bilibili.com/) bilibili 3.3图片超链接[![xxx](图片url)][要转移到的链接]图片超链接 [![enene](/images/keduoli.jpg)](https://nodesource.com/products/nsolid) 4.列表4.1.1无序列表 -，*，+， 两格缩进，列表与前一行的hello: - one - two - three eg: hello (没有衔接一起很神奇） one two three food bread apple pig ddd mmm 4.1.2两格缩进 （衔接在一起了） 登录微博开放平台，选择。 为了与注意风格统一，如下配置 嗯嗯嗯 （也衔接一起了） 基础设置： dsfs 样式设置： sdfa 模块设置： dsfa 4.2有序列表 序号. xxx(注意有空格） 登录微博开放平台，选择。 为了与注意风格统一，如下配置 嗯嗯嗯 5.用键代替链接，键值对匹配关键字对上跳转的意思吧，[内容]和文章最后的[内容1](链接)对上 可以变成超链接，前后内容忽略大小写，也能匹配。这里注意最后一 个，如果最后几个字也要跳转，单单加[1]没用得再加[2]来达到目 的，此时内容为1，但是跳转到的目的为2 Markdown is a lightweight markup language based on the formatting conventions that people naturally use in email. As [John Gruber] writes on the [Markdown site] Markdown is a lightweight markup language based on the formatting conventions that people naturally use in email.As John Gruber writes on the Markdown site 6.可以用来注意，引用,可以多层&gt; The overriding design goal for Markdown&apos;s &gt;&gt; formatting syntax is to make it as readable &gt; as possible. The idea is that. eg: The overriding design goal for Markdown’s formatting syntax is to make it as readableas possible. The idea is that. 7.代码块代码表示 1 123$ cd dillinger$ npm install -d$ node app eg:123$ cd dillinger$ npm install -d$ node app 123public static void main(String[] args)&#123; System.out.println(\"I think it's good\");&#125; 8.表格制表第一行和第二行列必须对应数量相等 | Plugin | README | sdflj | | ------ | ：------： | -----： | 右对齐，居中，左对齐 | Dropbox | [plugins/dropbox/README.md][PlDb] | dsf | | Github | [plugins/github/README.md][PlGh] | sdf | | Google Drive | [plugins/googledrive/README.md][PlGd] | dsfs | | OneDrive | [plugins/onedrive/README.md][PlOd] | dsfj | | Medium | [plugins/medium/README.md][PlMe] | | Google Analytics | [plugins/googleanalytics/README.md][PlGa] | eg: Plugin README sdflj Dropbox plugins/dropbox/README.md dsf Github plugins/github/README.md sdf Google Drive plugins/googledrive/README.md dsfs OneDrive plugins/onedrive/README.md dsfj Medium plugins/medium/README.md df Google Analytics plugins/googleanalytics/README.md dsdg eg：This will create the dillinger image and pull in the necessary dependencies. Be sure to swap out ${package.json.version} with the actual version of Dillinger. 9.文字9.1文字背景`xxx` 背景颜色加灰 I love `you` red line eg:I love you red line 9.2文字加粗加粗 **Software** Free Software, Hell Yeah! 9.3删除线~~xxx~~ 我喜欢javapython 待更新附录： [dill]: &lt;https://github.com/joemccann/dillinger&gt; [git-repo-url]: &lt;https://github.com/joemccann/dillinger.git&gt; [john gruber]: &lt;http://daringfireball.net&gt; [df1]: &lt;http://daringfireball.net/projects/markdown/&gt; [PlMe]: &lt;https://github.com/joemccann/dillinger/tree/master/plugins/medium/README.md&gt; [PlGa]: &lt;https://github.com/RahulHP/dillinger/blob/master/plugins/googleanalytics/README.md&gt;","tags":[{"name":"markdown","slug":"markdown","permalink":"http://yoursite.com/tags/markdown/"}]},{"title":"Hello World","date":"2018-03-22T09:34:27.055Z","path":"2018/03/22/hello-world/","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","tags":[]}]