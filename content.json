[{"title":"(转)IntelliJ IDEA(Android Studio)中如何减少对c盘的占用(相关核心文件和目录介绍)","date":"2018-04-17T15:14:47.000Z","path":"2018/04/17/idea/configuration-path/","text":"引言：博主无聊之余，偶然发现c盘竟然快满了，立志要清理文件，看到idea的配置竟然占了2个多G，然后就与下面的博主展开了无声的交流。 原文： IntelliJ IDEA(Android Studio)中如何设置使得占用C盘空间尽量少(相关核心文件和目录介绍) 这下好了，全家桶都能把配置路径挪出去了。（开心.jpg）","tags":[]},{"title":"人性的弱点之待人的基本技巧","date":"2018-04-16T14:11:46.000Z","path":"2018/04/16/Literature/human-weakness/","text":"引言：这里没有读后感，也没有具体内容，只是记录一些觉得令我觉得不错的语句 如欲采蜜，勿蹴蜂房 批评是没有用的，因它诗人增加一层防御，而且竭力的替自己辩护。 批评也是危险的，它会伤害一个人的自尊和自重的感觉，并激起他的反抗 人类自然的天性，是做错事只会责备别人，而绝不会责备自己，我们每个人都是如此。 我们需要了解，我们要矫正或谴责的人，他也会为自己辩护，而反过来谴责我们。 不要评议人，免得为人所评议 –格言 不要批评他们，我们在相同的情形下，也会像他们一样。（换位思考，换做是我们，我们做的没准比他们还差，换位思考他们所处的环境） 你所认识的人，你愿意他改变、调整，或是进步吗？是的，那是最好不过的。可是为什么不从你自己先开始呢？从自私的立场来说，从自己开始要比改进别人，获益跟多。 当我们要应付一个人的时候，应该记住，我们不是应付理论的动物，而是应付感情的动物。 他成功的秘诀是：“我不说任何人的不好！”他又这样说：“而说我所知道的每一个人的好处！” 不要批评，责怪或抱怨 与人相处的大秘窍 我能叫你去做任何事情的唯一方法，那就是把你所需要的给你。 人类天性至深的本质，就是渴求为人所重视。 –威利·贾姆士 寻求自重感的欲望，是人类和动物间，一项重要的差别。 许多精神错乱的人，在他疯癫中，找到了真实世界中无法获得的自重感。 世界上最容易摧毁一个人志向的，那就是上司所给他的批评。我从来不批评任何人，我只给人们工作的激励。我是急于称赞，而迟于寻错，如果说我喜欢什么的话，那就是诚于嘉许，宽裕称道。 –司华伯 赞赏和谄媚的区别在······那很容易识别出来，赞赏是出于真诚，而谄媚是虚伪的。一个出于由衷，一个出于嘴裹；一个是不自私的，一个是自私的。一个是为人们所钦佩的，一个是令人不耻而扬弃的。 别怕攻击你的敌人，提防谄媚你的朋友。 –奥伯利根将军 凡我所遇到的人，有胜过我的地方，我就学他那些好的地方。 –爱默逊 献出你真实，诚恳的赞赏","tags":[{"name":"卡耐基","slug":"卡耐基","permalink":"http://yoursite.com/tags/卡耐基/"}]},{"title":"hexo的Unable to create index.lock File exits问题","date":"2018-04-16T13:56:31.000Z","path":"2018/04/16/hexo-some-quesions/","text":"引言：今天写博客时忘记hexo g就push了，所以我就强制ctrl + c暂停push，后面再push 也就是hexo d时gg了1Error: fatal: Unable to create 'D:/507/Blog/blog/.deploy_git/.git/index.lock': File exists. ememem, 解决方法很简单按意思是无法创建锁文件，了解原理后，到指定的文件路径把这个锁文件删掉就行了。解释：在hexo d文件的过程中，会产生临时文件index.lock锁文件来锁住相应的资源，push时在lock释放前不能使用相关资源，hexo在发布过程结束后会自动删除锁文件，但是如果我强制退出，此文件不会被删除，这时候手动删除此文件，重新hexo d就行了。","tags":[{"name":"随笔","slug":"随笔","permalink":"http://yoursite.com/tags/随笔/"}]},{"title":"设计模式之观察者模式","date":"2018-04-16T12:59:03.000Z","path":"2018/04/16/DesignPatterns/observer/","text":"引言：以下代码使用java实现 1.是什么定义观察者模式又被称为发布订阅模式，属于行为模式的一种，定义了一种一对多的依赖关系，让多个观察对象同时监听某一个主题对象，一旦主题对象状态变化时，就会通知所有的观察者对象，不管观察者对象是否需要这个信息。 盗用一下Head First上的类图 2.使用场景，优势在哪（可以先看观察者的简单使用，比较好理解）使用的场景有以下 关联行为的场景，注意不是组合，关联行为可拆分，可以取消关联 一对多的事件触发 其它 优点观察者模式提供了一种对象设计，让主题和观察者之间松耦合 关于观察者的一切，主题只知道观察者实现了某个接口（Observer）接口。主题不需要知道观察者的具体类是谁等其它细节。 任何时候我们都可以增加新的观察者。因为主题唯一依赖的东西是一个实现Observer接口的对象列表，所以我们可以随时增加观察者。 有新的类型的观察者出现时，我们不需要修改主题代码。主题只需要以同样的方式发送给实现了Observer接口的对象消息就行了。 改变主题或观察者其中一方，并不会影响另一方。因为两者是松耦合的，所以只要他们之间的接口仍然被遵守，我们就可以自由地改变他们。 缺点 如果一个观察者有很多直接和间接的观察者，所有通知一遍很费时间 如果被观察者之间有循环依赖，会触发他们间进行循环调用，导致系统崩溃，使用时注意点 如果对观察者的通知是通过另外的线程进 行异步投递的话，系统必须保证投递是以自恰的方式进行的。（这句没理解，等后面读四人帮的书后再改改） 3. 观察者模式的简单使用这种发布订阅的形式，我们用新闻给QQ用户和微信用户统一发送新闻。新闻栏是被观察者，就是我们说的主题，用户就是观察者 抽象观察者（Observer）1234567Observer.java// 观察者接口public interface Observer &#123; // 更新的方法，主题将要调用的方法。 void update(String message);&#125; 具体实现接口的观察者（XXXObserver）QQ用户观察者 123456789101112131415QQObserver.javapublic class QQObserver implements Observer&#123; // QQ用户 private String name; public QQObserver(String name)&#123; this.name = \"QQ \" + name; &#125; public void update(String message)&#123; System.out.println(name + \" : \" + message); &#125;&#125; 微信用户观察者 123456789101112131415WeiXinObserver.javapublic class WeiXinObserver implements Observer&#123; // 微信用户 private String name; public WeiXinObserver(String name)&#123; this.name = \"Weixin \" + name; &#125; public void update(String message)&#123; System.out.println(name + \" : \" + message); &#125;&#125; 抽象被观察者，或者说是主题（Subject）1234567891011121314Subject.javapublic interface Subject &#123; // 新闻订阅 // 添加QQ或微信订阅者 void registered(Observer observer); // 删除订阅者 void removed(Observer observer); // 通知订阅者更新的消息 void notify(String message);&#125; 具体观察者123456789101112131415161718192021222324252627ImplSubject.javaimport java.util.ArrayList;import java.util.List;public class ImplSubject implements Subject&#123; // 存储订阅者信息 private List&lt;Observer&gt; userList = new ArrayList&lt;&gt;(); @Override public void registered(Observer observer) &#123; userList.add(observer); &#125; @Override public void removed(Observer observer) &#123; userList.remove(observer); &#125; @Override public void notify(String message) &#123; for (Observer observer : userList)&#123; // 调用观察者的update observer.update(message); &#125; &#125;&#125; 客户端调用12345678910111213141516171819202122232425Client.javapublic class Client&#123; public static void main(String[] args) &#123; // 创建新闻栏 Subject newInformation = new ImplSubject(); // QQ用户注册 QQObserver qq1 = new QQObserver(\"wulingqi\"); QQObserver qq2 = new QQObserver(\"leiyanrui\"); // 微信用户注册 WeiXinObserver weiXin1 = new WeiXinObserver(\"yaonan\"); WeiXinObserver weixin2 = new WeiXinObserver(\"huangzizhong\"); // 订阅wulingqi新闻 newInformation.registered(qq1); newInformation.registered(qq2); newInformation.registered(weiXin1); newInformation.registered(weixin2); // 发送新闻 newInformation.notify(\"wulingqi博客更新啦\"); &#125;&#125; 输出：1234QQ wulingqi : wulingqi博客更新啦QQ leiyanrui : wulingqi博客更新啦Weixin yaonan : wulingqi博客更新啦Weixin huangzizhong : wulingqi博客更新啦 松耦合，我们可以通过观察者接口产生不同的用户类型，也可以通过被观察者（主题）接口产生不同的版块，新闻，娱乐，推送的公众号等，双方不会产生影响。具体的原因见第2点的解释。","tags":[{"name":"观察者模式","slug":"观察者模式","permalink":"http://yoursite.com/tags/观察者模式/"}]},{"title":"Oracle dense_rank函数问题解决中ing","date":"2018-04-15T11:37:46.000Z","path":"2018/04/15/Oracle/dense-rank/","text":"引言：苦逼博主在leetCode刷题时遇到的问题 Oracle函数dense_rank() over([partition by xxx] order by xxx [desc])是用来排序连续可重复的，比如 id 得分 名次 2 10 1 3 9 2 5 9 2 1 9 2 4 7 3 就是上表，连续可重复的名次，但是排序的过程竟然有细微的精度问题，请看下面这题Rank Scores 鉴于大概你们懒得打开，我直接贴图吧 看起来很简单，Oracle直接12select s.score as &quot;Score&quot;, dense_rank() over(order by s.score desc) as &quot;Rank&quot; from Scores s; 那么恭喜你过了9个case，第十个gg了，上图发现 注意：竟然是死在了精度问题，输出了几个精度那么高的数，嗯嗯嗯，看数据，嗯嗯嗯，两位数是么，嗯嗯嗯 12select round(s.score, 2) as &quot;Score&quot;, dense_rank() over(order by s.score desc) as &quot;Rank&quot; from Scores s; 哈哈哈，卡过了。 好吧，讲正经的，就是为了突出这个函数排序时会有精度问题？我也不是很确定，所以老老实实用别的方法吧。 123456select Score, (select count(distinct Score) from Scores where Score &gt;= s.Score) as Rank from Scores s order by Score desc 嗯，上面这个用Oracle交同样的精度问题，MySql交没错，。。。 所以，总结，这题Oracle有毒，函数也没确定是否会导致精度问题","tags":[{"name":"随笔","slug":"随笔","permalink":"http://yoursite.com/tags/随笔/"},{"name":"leetCode","slug":"leetCode","permalink":"http://yoursite.com/tags/leetCode/"}]},{"title":"2018搬瓦工搭建ss（小笔记）","date":"2018-04-15T09:01:26.000Z","path":"2018/04/15/vps-ss/","text":"购买和搭建ss看这个教程搬瓦工没有shadowsocks选项了怎么办？三种方法搭建SS教程！建议选择第三个 ss的详细配置看下面这个Shadowsocks Python版一键安装脚本 123456789101112131415# 上面包含几条命令和路径# 卸载./shadowsocks.sh unistall# 配置文件路径/etc/shaowsocks-python/config.json#启动/etc/init.d/shadowsocks-python start#停止/etc/init.d/shadowsocks-python stop#状态/etc/init.d/shadowsocks-python status 注意：putty或git连接vps的密码是root password modification生成的复杂密码git连接命令： ssh -p 端口号 user@ip","tags":[{"name":"随笔","slug":"随笔","permalink":"http://yoursite.com/tags/随笔/"}]},{"title":"java编程思想 内部类学习笔记（注意其中的jdk版本问题）","date":"2018-04-14T15:11:26.000Z","path":"2018/04/14/notes/innernal-class/","text":"引言：这里使用的都是Effective java里的例子，并且按照其目录顺序进行讲解（枯燥无味，没什么好玩的，毕竟只是笔记，尽量讲的简单，例子也需要注意，因为是直接拷贝effective java的例子稍加修改，所以不一定能运行（只对于print输出方面，其它正常无误） 创建内部类直接上例子：… 注意：如果在外部类外非静态方法创建内部类（还没讲到其它类型的内部类都默认普通内部类），具体声明对象的类型格式为：OuterClassName.InnerClassName 使用.this与.new例子1： 1234567891011121314151617public class DotThis &#123; void f() &#123; System.out.println(\"DotThis.f()\"); &#125; public class Inner &#123; public DotThis outer() &#123; // ClassName.this生成对外部类对象的引用 return DotThis.this; &#125; &#125; public Inner inner() &#123; return new Inner(); &#125; public static void main(String[] args) &#123; DotThis dt = new DotThis(); DotThis.Inner dti = dt.inner(); // outer获取DotThis对象的引用调用f函数 dti.outer().f(); &#125;&#125; 例子2： 123456789public class DotNew &#123; public class Inner &#123;&#125; public static void main(String[] args) &#123; DotNew dn = new DotNew(); // 外部类的引用dn使用.new语法 DotNew.Inner dni = dn.new Inner(); &#125;&#125; 如果要用其它对象去创建某个内部类对象，需要用外部类实例引用对内部类进行.new语法，但是，如果创建的是嵌套类（静态内部类，后面会讲），那么就不需要对外部类对象引用。 注意：在拥有外部类对象前是不可能创建内部类对象的（静态内部类除外），因为内部类对象会隐式产生连接到外部类对象的引用，而静态内部类不需要产生对外部类对象的引用。 内部类与向上转型（有个内容还不清楚，暂时不写） 在方法和作用域内的内部类使用这种内部类的理由有两个： 实现某类型的接口，可以创建并返回对其的引用。 要解决一个复杂的问题，想创建一个类来辅助你的解决方案，但是又不希望这个类是公共可用的 注意： 在某个方法或者作用域内声明的内部类，方法或者范围外部不能访问 例子： 123456789101112131415161718public class Parcel5 &#123; // destination方法中创建PDestination内部类 public Destination destination(String s) &#123; class PDestination implements Destination &#123; private String label; private PDestination(String whereTo) &#123; label = whereTo; &#125; public String readLabel() &#123; return label; &#125; &#125; return new PDestination(s); &#125; public static void main(String[] args) &#123; Parcel5 p = new Parcel5(); Destination d = p.destination(\"Tasmania\"); &#125;&#125; 匿名内部类直接看例子了解语法： 123456789101112131415161718192021222324252627282930public class Parcel7 &#123; // 这里返回匿名内部类的引用 public Contents contents() &#123; return new Contents() &#123; // Insert a class definition private int i = 11; public int value() &#123; return i; &#125; &#125;; // Semicolon required in this case &#125; public static void main(String[] args) &#123; Parcel7 p = new Parcel7(); Contents c = p.contents(); &#125;&#125;// 上述匿名内部类其实是下面例子的简化形式public class Parcel7b &#123; // 这里对应上面匿名内部类的内容 class MyContents implements Contents &#123; private int i = 11; public int value() &#123; return i; &#125; &#125; // 对应返回匿名内部类的引用 public Contents contents() &#123; return new MyContents(); &#125; public static void main(String[] args) &#123; Parcel7b p = new Parcel7b(); Contents c = p.contents(); &#125;&#125; 注意：如果匿名内部类要使用一个在外部定义的对象，那么这个对象必须是final类型的，看下面例子： 123456789101112131415class A&#123; &#125;class B&#123; // final变量 c 和 a final int c = 2; public A creatA(final int a)&#123; return new A()&#123; int b = a; int d = c; &#125;; &#125;&#125; 但是注意一点，是在匿名内部类内使用才必须是final，但是如果是下面这样，不需要final（ememem，这是对的么？不对啊，得看是什么版本的jdk版本，jdf1.8开始竟然没有这个限制了，ememem，坑我，再注意，没这个限制并不是意味着这个不是final，而是系统默认添加，用来简化代码而已，java将这个功能称为：Effectively final，改变值还是会报错的）看下面jdk1.8的官方文档 123456789101112131415161718class A&#123; String a; public A(String a)&#123; this.a = a; &#125;&#125;class B&#123; // final变量 c 和 a final String c = \"zzz\"; public A creatA(String a)&#123; return new A(a)&#123; String b = a; String d = c; &#125;; &#125;&#125; 注意：我上面也说了，new A(a)中的a并不在内部类中，所以不必声明fianl，String b = a在低版本中是会报错的，因为a并不是final，而在1.8开始由于effective final的存在，如果不改变其值就不会gg。 嵌套类（静态内部类）用static修饰词修饰，意味着： 要创建嵌套类对象，并不需要其外围类的对象 不能凶嵌套类的对象中访问非静态的外围类对象（没有特殊的this引用，使得它类似于一个static方法） 注意：普通内部类和嵌套类还有一个区别，普通内部类的字段与方法，只能放在类的外部层次上，所以普通的内部类不能有static数据和static字段，也不能包含嵌套类，但是嵌套类可以包含这些。 还是看个例子吧 1234567891011121314151617181920212223242526272829303132333435public class Parcel11 &#123; private static class ParcelContents implements Contents &#123; private int i = 11; public int value() &#123; return i; &#125; &#125; // 静态内部类 protected static class ParcelDestination implements Destination &#123; private String label; private ParcelDestination(String whereTo) &#123; label = whereTo; &#125; public String readLabel() &#123; return label; &#125; // Nested classes can contain other static elements: public static void f() &#123;&#125; static int x = 10; // 内部再嵌套一个嵌套类 static class AnotherLevel &#123; public static void f() &#123;&#125; static int x = 10; &#125; &#125; public static Destination destination(String s) &#123; return new ParcelDestination(s); &#125; public static Contents contents() &#123; return new ParcelContents(); &#125; public static void main(String[] args) &#123; Contents c = contents(); Destination d = destination(\"Tasmania\"); &#125;&#125; 接口内部的类正常情况下，不能再接口内部放置任何代码（当然，这指的是jdk1.8以下的版本），但嵌套类可以作为接口的一部分，放到接口中的任何类都自动的是public和static的，所以嵌套类置于接口的命名空间内，就拥有嵌套类的那两个特性。甚至可在嵌套类内实现外围接口。 12345678910111213public interface ClassInInterface &#123; void howdy(); // 嵌套类于接口中，并且实现接口方法 class Test implements ClassInInterface &#123; public void howdy() &#123; System.out.println(\"Howdy!\"); &#125; public static void main(String[] args) &#123; new Test().howdy(); &#125; &#125;&#125; 所以，这就有个好处，如果你要创建某些公共代码，使得它们可以被某个接口的所有不同实现类所共用，那么使用接口的嵌套类会显得很方便。 但是注意：jdk1.8中引入了接口的默认方法，所以也能在接口不使用嵌套类的情况下进行公共代码的实现，具体区别和优势有待考察。 从多重嵌套的内部类中访问外部类的成员（注意，这里不是嵌套类）一个内部类被嵌套多少层并不重要，它能透明的访问所有它所嵌入的外围类的所有成员，看以下例子： 123456789101112131415161718192021class MNA &#123; private void f() &#123;&#125; class A &#123; private void g() &#123;&#125; public class B &#123; void h() &#123; g(); f(); &#125; &#125; &#125;&#125;public class MultiNestingAccess &#123; public static void main(String[] args) &#123; MNA mna = new MNA(); MNA.A mnaa = mna.new A(); MNA.A.B mnaab = mnaa.new B(); mnaab.h(); &#125;&#125; 为什么需要内部类其中一个最吸引人的原因是：每一个内部类都能独立地继承一个（或者接口）的实现，无论外围类是否已经继承（或者接口）某个实现，对于内部类没有影响 所以可以考虑一种情形：必须在一个类中以某种方式实现两个接口，由于接口的灵活性，两种选择：单一类或者内部类，看以下例子： 12345678910111213141516171819202122232425interface A &#123;&#125;interface B &#123;&#125;// X单一类实现class X implements A, B &#123;&#125;// Y使用内部类实现class Y implements A &#123; B makeB() &#123;// Anonymous inner class: return new B() &#123;&#125;; &#125;&#125;public class MultiInterfaces &#123; static void takesA(A a) &#123;&#125; static void takesB(B b) &#123;&#125; public static void main(String[] args) &#123; X x = new X(); Y y = new Y(); takesA(x); takesA(y); takesB(x); takesB(y.makeB()); &#125;&#125; 注意：这里使用的是两个不同的接口，但是如果我需要同意接口的两种不同的实现呢，读者自行考虑吧，虽然我也不确定这个例子是否合适，哈哈。还有一个问题，不同的接口是没事了，但如果是抽象类或者具体的类呢，那不就只能使用内部类才能实现多重继承了，看以下例子： 123456789101112131415161718class D&#123;&#125;abstract class E &#123;&#125;// 继承类Dclass Z extends D &#123; // 内部类实现对E的继承，&#123;&#125;里可以填实现细节 E makeE() &#123; return new E() &#123;&#125;; &#125;&#125;public class MultiImplementation &#123; static void takesD(D d) &#123;&#125; static void takesE(E e) &#123;&#125; public static void main(String[] args) &#123; Z z = new Z(); takesD(z); takesE(z.makeE()); &#125;&#125; 一开始我也会想，直接声明父类变量使用不是更好，后来想想也不是不对，前提是我们不会对父类的函数进行重写，而且这里内部类继承的不是抽象类么，如果外部类不是抽象类肯定要实现重写函数的不是么，所以解开了我所想的。 如果不需要解决多重继承的问题的问题，那么自然可以用别的方式，而不需要使用内部类，但是如果使用内部类，还可以获得其他一些特性： 内部类可以有多个实例，每个实例都有自己的状态信息，并且与其外围类对象的信息相互独立 在单个外围类中，可以让多个内部类以不同的方式实现同一个接口，或者继承容一个类（就像我上面举的实现同一个接口的问题） 创建内部类对象的时刻并不依赖外围类对象的创建（这里不是指不需要外围类就能直接创建内部类，之前也讲过，除了嵌套类，在创建内部类之前，都得拥有外部类对象，那么这里是什么意思呢，就是如果你用继承的话，要想使用父类的内容，必须是依赖外部类的，比如不同的父类内容必须是不同的外部类实例，而内部类只要有一个外部类实例，就能创建一堆彼此间相互独立地内部类实例，我觉得是这个意思） 内部类没有令人迷惑的“is-a”关系，就是一个独立地实体。举个妮子： 有个父类接口中有display()方法用来实现数据内容的输出，如果没有内部类，我子类继承了并实现了，输出相应的姓名，年龄，身高，体重，性别。但是，这只是我想看的，我想给室友看的不想包括性别，给他介绍对象（男的也介绍，嘎嘎嘎），那我要怎么办，再写一个类重写？只要用内部类就能拥有另一种实现，noGenderDisplay()。只有内部类才有这种灵活性。 闭包与回调闭包：是一个可调用的对象，它记录了一些信息，这些信息来自于创建它的作用域。通过这个定义，可以看出内部类是面向对象的闭包，因为它不仅包含外围类对象（创建内部类的作用域）的信息，还自动拥有一个指向此外围类对象的引用，在此作用域内，内部类有权操作所有的成员，包括private成员 通过内部类提供闭包的功能是优良的解决方案，它比指针更灵活，更安全，如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566interface Incrementable &#123; void increment();&#125;// Very simple to just implement the interface:class Callee1 implements Incrementable &#123; private int i = 0; public void increment() &#123; i++; print(i); &#125;&#125;class MyIncrement &#123; public void increment() &#123; print(\"Other operation\"); &#125; static void f(MyIncrement mi) &#123; mi.increment(); &#125;&#125;// If your class must implement increment() in// some other way, you must use an inner class:class Callee2 extends MyIncrement &#123; private int i = 0; public void increment() &#123; super.increment(); i++; print(i); &#125; // 通过内部类实现自己期望的increment函数的使用 private class Closure implements Incrementable &#123; public void increment() &#123; // 外部的引用使用外围类的函数 Callee2.this.increment(); &#125; &#125; Incrementable getCallbackReference() &#123; return new Closure(); &#125;&#125;class Caller &#123; private Incrementable callbackReference; Caller(Incrementable cbh) &#123; callbackReference = cbh; &#125; void go() &#123; callbackReference.increment(); &#125;&#125;public class Callbacks &#123; public static void main(String[] args) &#123; Callee1 c1 = new Callee1(); Callee2 c2 = new Callee2(); MyIncrement.f(c2); Caller caller1 = new Caller(c1); Caller caller2 = new Caller(c2.getCallbackReference()); caller1.go(); caller1.go(); caller2.go(); caller2.go(); &#125;&#125;/*Output:Other operation112Other operation2Other operation3 */ 注意：Callee2中所有的除了getCallbackReferrence以外都是private。想要建立与外部的连接，只能使用接口Increamentable进行实现。内部类Closure实现了接口，并且返回Callee2的钩子，并且是安全的，只能调用increament函数，没有其它的功能。 回调： 这里有个写的挺清楚的，请看Bro__超 内部类的继承这里问题复杂点，因为非静态内部类的构造器必须连接到外围类的引用，所以继承内部类也需要外部类实例的参与，见下面例子： 12345678910111213141516171819public class HelloWord extends A.B &#123; // 外部类A的实例a调用super，提供必要的引用 public HelloWord(A a)&#123; a.super(); &#125; public static void main(String[] args)&#123; A a = new A(); HelloWord helloWord = new HelloWord(a); &#125;&#125;class A&#123; class B&#123; &#125;&#125; 内部类是可以被覆盖么 继承某个外围类时，就算子类重写父类的内部类，内部类的实现也不会被覆盖，调用的方法遵循声明的类型。 如果明确继承父类的内部类，并且重写内部类，则覆盖 看下面两个例子： 例子1： 123456789101112131415161718192021class Egg &#123; private Yolk y; protected class Yolk &#123; public Yolk() &#123; System.out.println(\"Egg.Yolk()\"); &#125; &#125; public Egg() &#123; System.out.println(\"New Egg()\"); y = new Yolk(); &#125;&#125;class BigEgg extends Egg &#123; public class Yolk &#123; public Yolk() &#123; System.out.println(\"BigEgg.Yolk()\"); &#125; &#125; public static void main(String[] args) &#123; new BigEgg(); &#125;&#125; 说明继承了某个外围类时，内部类保持独立的个体，两个独立地实体。 例子2： 1234567891011121314151617181920212223242526272829303132333435363738394041424344class Egg &#123; private Yolk y; protected class Yolk &#123; public void f()&#123; System.out.println(\"this is egg.Yolk\"); &#125; &#125; public void insertYolk(Yolk yy)&#123; this.y = yy; &#125; // 调用覆盖的f() public void g()&#123; y.f(); Yolk yy = new Yolk(); yy.f(); &#125;&#125;class BigEgg extends Egg &#123; Yolk y; public class Yolk extends Egg.Yolk&#123; public void f()&#123; System.out.println(\"this is BigEgg.Yolk\"); &#125; &#125; public BigEgg()&#123; y = new Yolk(); insertYolk(y); &#125; public static void main(String[] args) &#123; Egg egg = new BigEgg(); egg.g(); &#125;&#125;output:this is BigEgg.Yolkthis is Egg.Yolk 注意：其实父类还是保持着自己独立地实现，其实就和类继承一样，没什么差别，和类联系起来就行了。 局部内部类 注意：不带有访问修饰词 局部内部类和匿名内部类有相同的能力，那么为何还有用匿名内部类，因为，匿名内部类只能实例初始化，没有自己的构造器或者重载的构造器。所以，使用局部内部类的理由只有一个：不止使用同一种实例化方式实例化对象时 看例子： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950//定义在方法里public class Parcel5 &#123; public Destionation destionation(String str)&#123; class PDestionation implements Destionation&#123; private String label; private PDestionation(String whereTo)&#123; label = whereTo; &#125; public String readLabel()&#123; return label; &#125; &#125; return new PDestionation(str); &#125; public static void main(String[] args) &#123; Parcel5 parcel5 = new Parcel5(); Destionation d = parcel5.destionation(\"chenssy\"); &#125;&#125;//定义在作用域内public class Parcel6 &#123; private void internalTracking(boolean b)&#123; if(b)&#123; class TrackingSlip&#123; private String id; TrackingSlip(String s) &#123; id = s; &#125; String getSlip()&#123; return id; &#125; &#125; TrackingSlip ts = new TrackingSlip(\"chenssy\"); String string = ts.getSlip(); &#125; &#125; public void track()&#123; internalTracking(true); &#125; public static void main(String[] args) &#123; Parcel6 parcel6 = new Parcel6(); parcel6.track(); &#125;&#125; 总结总的来说内部类分为几种： 普通内部类 嵌套类 匿名内部类 局部内部类 部分使用场景 当某个类除了它的外部类，不再被其他类使用（比如：数据库连接池） 解决一些非面向对象的语句块 一些多算法的场合 适当使用内部类，使得代码更加灵活和富有扩展性 详细的上面四中场合","tags":[{"name":"Effective java","slug":"Effective-java","permalink":"http://yoursite.com/tags/Effective-java/"}]},{"title":"抽象类和接口(非blog，Not recommended)(更新中)","date":"2018-04-12T08:54:54.000Z","path":"2018/04/12/notes/abstract-class/","text":"抽象类什么是抽象类首先了解什么是抽象方法，抽象方法就是只声明，没有具体实现，eg如下:1abstract void zzz(); 必须用abstract进行修饰，如果一个类中含有抽象方法，那么称这个类为抽象方法，抽象方法必须也用abstract进行修饰。 注意： 抽象方法不能用来创建对象。这里来自某blog的大佬说在java编程思想中对抽象类的定义为“包含抽象方法的类”，但是后面看源码时有的抽象类其实内部什么方法都没有，然而还是声明成抽象类。算了，细节问题不要在意。 有什么用，用在哪:怎么说，按我的理解，就是为了继承实现多态的，多态的概念就不用解释了 怎么用？(不可能教你怎么用的，自己看书，自己谷歌)注意的问题 访问修饰符里虽然也有提到过，但是抽象类的方法必须为public或者protected，毕竟子类必须有能够访问的能力进行事项 如果子类继承了抽象父类，如果没有全部重写父类的所有抽象方法，那么子类依然是抽象类，依然不能实例化。 接口什么是接口怎么说，可以理解为纯粹的抽象类吧，接口泛指别人调用的方法或者函数，是对行为的抽象（下面对比的时候会解释的） 注意 接口中可以含有 变量和方法。但是要注意，接口中的变量会被隐式地指定为public static final变量（并且只能是public static final变量，用private修饰会报编译错误），而方法会被隐式地指定为public abstract方法且只能是public abstract方法（用其他关键字，比如private、protected、static、 final等修饰会报编译错误），并且接口中所有的方法不能有具体的实现，也就是说，接口中的方法必须都是抽象方法。从这里可以隐约看出接口和抽象类的区别，接口是一种极度抽象的类型，它比抽象类更加“抽象”，并且一般情况下不在接口中定义变量。 重点： 第1个注意点中，只适合老版本，jdk1.8以下的版本，在jdk1.8中接口加入了新概念，扩展了接口的含义：默认方法和静态方法，默认方法使得接口有点类似traits吧，不过要实现的目标不一样。默认方法使得开发者可以在不破坏二进制兼容性的前提下，王现存的接口中添加新的方法，即不强制实现了该接口的类也可同时实现这个新加的方法。（可以通过转换调用）可以看出，默认方法和抽象方法之间的区别在于抽象方法需要实现，而默认方法不需要。接口提供的默认方法会被接口的实现类继承或者覆写。看个简单的例子 12345678910111213141516171819202122private interface Defaulable &#123; // Interfaces now allow default methods, the implementer may or // may not implement (override) them. default String notRequired() &#123; return \"Default implementation\"; &#125; &#125; private static class DefaultableImpl implements Defaulable &#123;&#125; private static class OverridableImpl implements Defaulable &#123; @Override public String notRequired() &#123; return \"Overridden implementation\"; &#125;&#125;//例子来源：（其实是我懒得写）//作者：杜琪//链接：https://www.jianshu.com/p/5b800057f2d8//著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 此默认方法扩充了Collection的方法，比如stream(), parallelStream()等，Stream也是java8的一大亮点，专注于对集合对象进行各种流弊的操作，可以很方便写出高性能的并发程序，偏题了。 那么，抽象类和接口的区别语法层面上的区别（jdk1.8以下版本) 抽象类可以提供成员方法的实现细节，而接口中只能存在public abstract 方法； 抽象类中的成员变量可以是各种类型的，而接口中的成员变量只能是public static final类型的； 接口中不能含有静态代码块以及静态方法，而抽象类可以有静态代码块和静态方法； 一个类只能继承一个抽象类，而一个类却可以实现多个接口。 设计层面上的区别(那么多字，肯定不是我自己写的（别想太多，点我）) 抽象类是对一种事物的抽象，即对类抽象，而接口是对行为的抽象。抽象类是对整个类整体进行抽象，包括属性、行为，但是接口却是对类局部（行为）进行抽象。举个简单的例子，飞机和鸟是不同类的事物，但是它们都有一个共性，就是都会飞。那么在设计的时候，可以将飞机设计为一个类Airplane，将鸟设计为一个类Bird，但是不能将 飞行 这个特性也设计为类，因此它只是一个行为特性，并不是对一类事物的抽象描述。此时可以将 飞行 设计为一个接口Fly，包含方法fly( )，然后Airplane和Bird分别根据自己的需要实现Fly这个接口。然后至于有不同种类的飞机，比如战斗机、民用飞机等直接继承Airplane即可，对于鸟也是类似的，不同种类的鸟直接继承Bird类即可。从这里可以看出，继承是一个 “是不是”的关系，而 接口 实现则是 “有没有”的关系。如果一个类继承了某个抽象类，则子类必定是抽象类的种类，而接口实现则是有没有、具备不具备的关系，比如鸟是否能飞（或者是否具备飞行这个特点），能飞行则可以实现这个接口，不能飞行就不实现这个接口。 设计层面不同，抽象类作为很多子类的父类，它是一种模板式设计。而接口是一种行为规范，它是一种辐射式设计。什么是模板式设计？最简单例子，大家都用过ppt里面的模板，如果用模板A设计了ppt B和ppt C，ppt B和ppt C公共的部分就是模板A了，如果它们的公共部分需要改动，则只需要改动模板A就可以了，不需要重新对ppt B和ppt C进行改动。而辐射式设计，比如某个电梯都装了某种报警器，一旦要更新报警器，就必须全部更新。也就是说对于抽象类，如果需要添加新的方法，可以直接在抽象类中添加具体的实现，子类可以不进行变更；而对于接口则不行，如果接口进行了变更，则所有实现这个接口的类都必须进行相应的改动。 简单来说，抽象类就是个模板类，接口是一种行为规范，就像上面说的辐射式设计，但是，对于新版本的jdk1.8，个人感觉也具有一定模板式设计了，都引入的默认方法了，和抽象类中非抽象方法有什么区别。但是，其设计层面的区别还主要是接口是对行为的抽象，新版本的小疑问以后再做考虑。 接口其它应用应用很多，有与设计模式相关的适配器，工厂模式等，具体详细请看java便构成思想，还有接口为什么优于抽象类等相关问题请看effective java。 补充： 对上面新版本中接口不就是抽象类的进行解释详细见开源中国 参考资料：http://www.importnew.com/18780.htmlhttps://www.jianshu.com/p/038f0b356e9ahttp://arthur503.github.io/blog/2013/10/10/Java-access-control.htmlhttps://www.ibm.com/developerworks/cn/java/j-lo-java8streamapi/","tags":[{"name":"java笔记","slug":"java笔记","permalink":"http://yoursite.com/tags/java笔记/"}]},{"title":"Java访问权限修饰符(非blog，Not recommended)(更新中)","date":"2018-04-12T08:51:23.000Z","path":"2018/04/12/notes/ppt/","text":"引言：java中有四种访问修饰符，public，protected，defaul（实际上没有这个关键词（大概懂我意思吧），就是默认的同一包内访问权限。），private，用于对方法，属性，类的修饰，但是部分可用。 访问权限和使用类别见一下两个表格 表格(一) 修饰符 修饰成员变量和函数 修饰类 public yes yes protected yes no default yes yes private yes no 表格(二) 修饰符 当前类 同一包内 子孙类 其它包 public yes yes yes yes protected yes yes yes no default yes yes no no private yes no no no","tags":[{"name":"java笔记","slug":"java笔记","permalink":"http://yoursite.com/tags/java笔记/"}]},{"title":"easyMock的简单使用（详细参考官方文档，第二问更新中）","date":"2018-04-09T12:14:44.000Z","path":"2018/04/09/mock/easyMock-simple-use/","text":"引言： 本文采取的例子来自 EasyMock tutorial – Getting Started（就是原文啦） 什么是Mock？Mock其实就是模拟或者Stud，当你调用一个不好在测试中创建的对象时，Mock框架为你模拟一个和真实对象类似的数据类完成相应的行为。 比如说：我接下来要写的股票问题，首先，股价时刻都在变动，我们一旦获取了当前的股价，并不代表一定是正确的数据，因为真实的股价是时刻都在变动的，所以我们要模拟一个检索股票的接口来获取数据，而不是去访问真实的服务器。 与PowerMock和JMock相比如今比较流行的工具JMock，EasyMock，Mockito等都有一个共同的缺点，就是不能mock静态，final，私有方法(但是可以mock类哦，前提类内部也没有以上属性的方法），而PowerMock能够完美的弥补以上三个Mock的不足（扩充而不是替代，可以提高代码测试的覆盖率，天哪，我到底为什么才知道），自行百度吧。（似乎还有个全能的Jmokit，等研究好了再补充）某个工作的作者遇到坑，但是本萌现在还看不懂，大概因为用的是PowerMock，本萌还没学 简单用法：这里我们用一个简单的例子来简单的入门easyMock的用法。 股票计算应用引言：首先，这个应用有一个接口，两个实体类和一个测试类。 Stock类是用来表示股票的信息，含股票名和数量（我们可以想象成数据库所学的emp类） Portfolio类保存不同股票的信息（想象成emplist一样，里面存着各种人员的信息），这个类中有一个计算所有股票价格的总和的方法getTotalValue()，我们要测试的就是这个方法。 StockMarket接口，也就是股市的意思，就是我们要模拟的接口，模拟这个接口里getPrice的数据 内容：上代码，首先是实体类Stock12345678910111213141516171819202122232425262728293031Stock.javapublic class Stock &#123; /** * Stock类用来存储股票的信息，名字和类型, 联想一下就是实体类emp */ private String name; private int quantity; public Stock (String name, int quantity)&#123; this.name = name; this.quantity = quantity; &#125; public String getName()&#123; return name; &#125; public void setName(String name)&#123; this.name = name; &#125; public int getQuantity()&#123; return quantity; &#125; public void setQuantity(int quantity)&#123; this.quantity = quantity; &#125;&#125; 然后是Protfolio类 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859import java.util.ArrayList;import java.util.List;public class Protfolio &#123; /** *注意：硬编码依赖不是好的实践，我们不应该在此初始化stockMarket对象， *我们应该在使用测试代码的时候注入进来。(这里就先这样了） */ // 某个投资的名，这里不重要 private String name; // 模拟的接口，这里就当成是实际存在的进行使用 private StockMarket stockMarket; // 保存股票的信息 private List&lt;Stock&gt; stocks = new ArrayList&lt;&gt;(); /** * 计算所有股票是价格，并返回 * sock保存的各个股票的数量乘以通过接口stockMarket模拟获取的价格求和 */ public double getTotalValue()&#123; double value = 0.0; for (Stock stock: this.stocks)&#123; value += (stockMarket.getPrice(stock.getName()) * stock.getQuantity()); &#125; return value; &#125; public void addStock(Stock stock)&#123; stocks.add(stock); &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public StockMarket getStockMarket() &#123; return stockMarket; &#125; public void setStockMarket(StockMarket stockMarket) &#123; this.stockMarket = stockMarket; &#125; public List&lt;Stock&gt; getStocks() &#123; return stocks; &#125; public void setStocks(List&lt;Stock&gt; stocks) &#123; this.stocks = stocks; &#125;&#125; 以上就是所有业务的逻辑，很简单吧，sock股票信息，Port进行处理，stockMarket获取价格 然后是Junit和EasyMock测试Portfolio中的getTotalValue()方法 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748ProtfolioTest.javaimport com.wlq.easymock.dao.StockMarket;import com.wlq.easymock.entity.Protfolio;import com.wlq.easymock.entity.Stock;import org.easymock.EasyMock;import org.junit.Before;import org.junit.Test;import static org.junit.Assert.*;public class ProtfolioTest &#123; private Protfolio protfolio; private StockMarket marketMock; @Before public void setUp() throws Exception &#123; protfolio = new Protfolio(); protfolio.setName(\"wlq's portfolip.\"); // 模拟创建（StockMarket）股市的实例 marketMock = EasyMock.createMock(StockMarket.class); // 将模拟实例对象赋给股票列表 protfolio.setStockMarket(marketMock); &#125; @Test public void getTotalValue() &#123; // 用我们期望的返回值来配置模拟对象，当getPrice参数是EBAY时，返回的数值为42.00 EasyMock.expect(marketMock.getPrice(\"EBAY\")).andReturn(42.00); // 这个replay不要忘记，将mock进行重放，否则会IllegalStateException //异常和一个没有什么帮助的错误消息： //missing behavior definition for the preceding method call。 EasyMock.replay(marketMock); // 开始测试 Stock ebayStock = new Stock(\"EBAY\", 2); protfolio.addStock(ebayStock); // 这里使用的是org.junit下的断言，在4.12的javadoc中中已经没有没有junit.framework的 // 内容了，但是为了兼容，4.12版本中还会对其进行保留 // 在junit4中这个方法似乎被弃用了可以添加第三个参数代表误差 // 弃用： assertEquals(84.00, protfolio.getTotalValue()); assertEquals(84.00, protfolio.getTotalValue(), 0); &#125;&#125; 总结： 先 EasyMock.createMock(xxxx.class) 创建模拟接口返回的对象 然后就是正常使用接口的实例操作 配置模拟对象，在什么条件下做什么 EasyMock.expect(模拟的对象实例.xxx方法()).xxx返回的东西或者要做的事() EasyMock.replay(实例对象) 开始正常逻辑测试。","tags":[{"name":"Junit","slug":"Junit","permalink":"http://yoursite.com/tags/Junit/"},{"name":"easyMock","slug":"easyMock","permalink":"http://yoursite.com/tags/easyMock/"}]},{"title":"IDEA中dependencies和libraries的区别","date":"2018-04-09T11:50:06.000Z","path":"2018/04/09/idea/dependencies-and-libraries/","text":"我觉得，idea中的dependencies和eclipse中的build path差不多，在eclipse中先将jar文件放入某个lib文件夹下然后add build path 其实通过意思可以看出，dependencies是依赖，libraries是库，dependencies中 添加jar包或者目录就是eclipse中的buildpath，libraries就是集中包的一个目录， 用来集中批量管理包。（目前理解就是这些，有错求指正）","tags":[{"name":"随笔","slug":"随笔","permalink":"http://yoursite.com/tags/随笔/"},{"name":"idea","slug":"idea","permalink":"http://yoursite.com/tags/idea/"}]},{"title":"idea-webApp简单运行环境配置","date":"2018-04-08T04:41:10.000Z","path":"2018/04/08/idea/idea-webApp-simple/","text":"首先在web下创建两个目录，分别为lib和classes，classe保存编译后的.class文件，lib保存需要的jar包。 打开project Setting, 选择modules，点击paths，把两个path路径改成第一步骤下的classes路径。 点击path旁边的dependencies进行Tomcat的添加，点击+选择Library，选择Tomcat进行添加。或者先在librarys添加相应的包，再去dependencies添加。 配置Tomcat文件，edit Configurations，点击+，选择Tomcat，local Tomcat，Server部分进行相关配置，然后对deployment点击+添加artifact，webxxxxx啥的。 运行下试试。","tags":[{"name":"随笔","slug":"随笔","permalink":"http://yoursite.com/tags/随笔/"},{"name":"idea","slug":"idea","permalink":"http://yoursite.com/tags/idea/"},{"name":"applet","slug":"applet","permalink":"http://yoursite.com/tags/applet/"}]},{"title":"javaIO流的总结（更新中）","date":"2018-04-07T14:11:28.000Z","path":"2018/04/07/IO/javaIO-summary/","text":"引言：这里不会讲各种流的详细用法。 注意：original Stream（也称为节点流） 和 wrapper Stream（也称为处理流）未包装类和包装类。 java可分为输出流和输入流，根据流类型，可分为字符流和字节流，如下表： 分类 字节流 字符流 输入流 InputStream Reader 输出流 OutputStream Writer 实际使用中我们一般不会用到上面说的四类，而是使用继承它们的子类，不同的子类负责着不同的功能，以便于我开发不同的应用。用途主要有以下几种： 文件访问 网络访问 内存缓存访问 线程内部通信 缓冲 过滤 解析 读写文本，基本数据类型，对象 Java IO 类概述表 该表使用自并发编程网的javaIO 各做基类流继承下去的分为两类，节点的流和处理流：字节节点流只具有读取字节内容的方法，比如FileInputStream流和FileOutputStream流只能向文件中读取或者向文件中写入字节，对于各种类型的数据，如果是写入文件，必须转换成字节数组后写入文件，若是读取，那么就得转换成相应的类型。 而处理流，例如DataOutputStream提供了各种对象中写入类型的方法，方便编程人员。 1. 字节流1.1 InputStream作为基类1.1.1 ByteArrayInputStream 内部通过建立字节数组buf缓冲区来读取保存数据 适用场景:此流是内存操作流，这个流可实现类似内存虚拟文件的功能，将数据暂存在缓存区中，可以使程序不需要产生相应的临时文件，避免从存储介质上读取，提升效率。 注意:此流没有提供close关闭流的操作，当没有对其的强引用时，就会自动被GC，但是也会导致内存溢出，可以使用org.apache.commons.io.IoUtiles关闭流 1.1.2 FileInputStream 把一个文件作为文件输入流，实现对文件的读取操作，访问硬盘 适用场景:从名字上就能看出应用，对硬盘上的文件的存取 1.1.3 SocketInputStream 就和名字一样，适用于网络通信中。 1.1.4 PipeInputStream 通多创建管道实现线程间的通信 1.1.5 BufferedInputStream 本质是通过一个内部缓冲数组实现的，默认大小8192，实现滑动读取的功能，事先把size大小的数据从磁盘中读取到缓冲区上，然后实际操作都在缓冲区中进行，如果数据超过缓冲区，那么将重新载入数据。减少了磁盘IO，提高了效率。 用途：因为其缓存的功能，可以起到改善效率的作用。通过源码可以看出，构造器的形参是InputStream，所以可以对其进行改善效率，包括FileInputStream等，比如： 12BufferedInputStream bufferedInputStream = new BufferedInputStream(new FileInputStream(\"zzz.txt\")); 1.1.6 DataInputStream 封装了对字节流的解析，实现了对基本数据类型的基本操作和对读取UTF格式的方法，当然，读取字符的还有Rread等相关的字符流。 1.1.7 PushbackInputStream 回推流，把从缓存区中读出来的数据再原路推回去，没有破坏输入流里的内容结构。 注意：PushbackInputStream对象会使得InputStream对象（用于创建PushbackInputStream对象）的mark()或reset()方法无效。对于准备使用mark()或reset()方法的任何流来说，都应当使用markSupported()方法进行检查。 1.1.8 ObjectInputStream与ObjectOutputStream ObjectOutputStream 将 Java 对象的基本数据类型和图形写入 OutputStream。可以使用 ObjectInputStream 读取（重构）对象。通过在流中使用文件可以实现对象的持久存储。如果流是网络套接字流，则可以在另一台主机上或另一个进程中重构对象。只能将支持 java.io.Serializable 接口的对象写入流中。每个 serializable 对象的类都被编码，编码内容包括类名和类签名、对象的字段值和数组值，以及从初始对象中引用的其他所有对象的闭包。writeObject 方法用于将对象写入流中。所有对象（包括 String 和数组）都可以通过 writeObject 写入。可将多个对象或基元写入流中。必须使用与写入对象时相同的类型和顺序从相应 ObjectInputstream 中读回对象。 1.1.9 SequenceInputStream 合并流，将多个源合并成一个源 1.2 OutputStream作为基类1.2.1 PrintStream PrintStream 是打印输出流，它继承于FilterOutputStream。PrintStream 是用来装饰其它输出流。它能为其他输出流添加了功能，使它们能够方便地打印各种数据值表示形式。与其他输出流不同，PrintStream 永远不会抛出 IOException；它产生的IOException会被自身的函数所捕获并设置错误标记， 用户可以通过 checkError() 返回错误标记，从而查看PrintStream内部是否产生了IOException。另外，PrintStream 提供了自动flush 和 字符集设置功能。所谓自动flush，就是往PrintStream写入的数据会立刻调用flush()函数。 这里对比一下PrintStream和DataOutputStream（原文链接)相同点：都是继承与FileOutputStream，用于包装其它输出流。不同点： (01) PrintStream和DataOutputStream 都可以将数据格式化输出；但它们在“输出字符串”时的编码不同。 PrintStream是输出时采用的是用户指定的编码(创建PrintStream时指定的)，若没有指定，则采用系统默认的字符编码。而DataOutputStream则采用的是UTF-8。关于UTF-8的字符编码可以参考“字符编码(ASCII，Unicode和UTF-8) 和 大小端”关于DataOutputStream的更多内容，可以参考“java io系列15之 DataOutputStream(数据输出流)的认知、源码和示例” (02) 它们的写入数据时的异常处理机制不同。 DataOutputStream在通过write()向“输出流”中写入数据时，若产生IOException，会抛出。而PrintStream在通过write()向“输出流”中写入数据时，若产生IOException，则会在write()中进行捕获处理；并设置trouble标记(用于表示产生了异常)为true。用户可以通过checkError()返回trouble值，从而检查输出流中是否产生了异常。 (03) 构造函数不同 DataOutputStream的构造函数只有一个：DataOutputStream(OutputStream out)。即它只支持以输出流out作为“DataOutputStream的输出流”。而PrintStream的构造函数有许多：和DataOutputStream一样，支持以输出流out作为“PrintStream输出流”的构造函数；还支持以“File对象”或者“String类型的文件名对象”的构造函数。而且，在PrintStream的构造函数中，能“指定字符集”和“是否支持自动flush()操作”。 (04) 目的不同 DataOutputStream的作用是装饰其它的输出流，它和DataInputStream配合使用：允许应用程序以与机器无关的方式从底层输入流中读写java数据类型。而PrintStream的作用虽然也是装饰其他输出流，但是它的目的不是以与机器无关的方式从底层读写java数据类型；而是为其它输出流提供打印各种数据值表示形式，使其它输出流能方便的通过print(), println()或printf()等输出各种格式的数据。 2. 字符流2.1 Reader作为基类2.1.1 CharArrayReader2.1.2 InputStreamReader2.1.3 FileReader2.1.4 PipedReader2.1.5 StringReader2.1.6 BufferedReader2.1.7 LinNumberReader2.1.8 PushBackReader2.2 Writer作为基类2.2.1 PrintWriter3. RandomAccessFile4. 字符和字节流的转换5.一般使用规则(输入和输出类似)1.按数据来源分类： 文件：FileInputStream, FileReader byte[]: ByteArrayInputStream char[]: CharArrayReader String: StringBufferInputStream, StringReader 网络数据流: InputStream, Reader 2.按是否格式化输出 格式化输出： PrintStream, PrintWriter 3.按是否要缓冲 BufferedInputStream, BufferedReader 4.按数据格式： 字节流： InputStream和OutputStream以及它们的子类 字符流： Reader和Writer以及它们的子类 5.按输入输出： 不用写，都懂 6.特别的： Stream到Reader和Writer的转换类： InputStreamReader和OutputStreamWriter 对象输入输出： ObjectStream, ObjectStream 进程通信： PipeInputStream, PipeReader 合并输入： SequenceInputStream 其它： PushbackInputStream, PushbackReader, LineNumberInputStream, LineNumberReader 6. 构造准则决定使用哪个类以及它的构造进程的一般准则如下（不考虑特殊需要）： 首先，考虑最原始的数据格式是什么： 原则四 第二，是输入还是输出：原则五 第三，是否需要转换流：原则六第 1 点 第四，数据来源（去向）是什么：原则一 第五，是否要缓冲：原则三 （特别注明：一定要注意的是 readLine() 是否有定义，有什么比 read, write 更特殊的输入或输出方法） 第六，是否要格式化输出：原则二 借鉴远志，志在远方 【1】内存操作流： 用于处理临时存储的信息，程序结束，数据就从内存中消失。 字节数组： ByteArrayInputStream ByteArrayOutputStream 字符数组： CharArrayReader CharArrayWriter 字符串： StringReader StringWriter","tags":[{"name":"IO","slug":"IO","permalink":"http://yoursite.com/tags/IO/"}]},{"title":"java中自动拆装箱的一些问题","date":"2018-04-05T07:08:41.000Z","path":"2018/04/05/essays/auto-unpacking-packing/","text":"引言： 直接进入正题，我就当大家都知道什么是拆箱和装箱了，这里主要讨论的是不清楚原理导致产生一些奇怪问题的内容，想看详细介绍的跳到这边：深入剖析java中的装箱和拆箱，这边感谢原作者对反编译class文件的解析，让我理解原理，下面会使用原作者的部分内容以及讲解一些原作者没解析的一些内容。 1. 拆箱和装箱时如何实现的 通过反编译的文件可以了解到（见下图），装箱时自动调用的是valueof()方法，而拆箱的时候自动调用的是xxxValue()方法。 2. 遇到的相关问题2.1 看下面的代码123456789101112public class Main &#123; public static void main(String[] args) &#123; Integer i1 = 100; Integer i2 = 100; Integer i3 = 200; Integer i4 = 200; System.out.println(i1==i2); System.out.println(i3==i4); &#125;&#125; 结果是： true false 神奇吧，出乎意料，以前没有深入了解，有人提到后就去分析了源码，看看Integer valueOf的部分源码实现 12345678Integer.java @HotSpotIntrinsicCandidate public static Integer valueOf(int i) &#123; if (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high) return IntegerCache.cache[i + (-IntegerCache.low)]; return new Integer(i); &#125; 通过源码的实现可以看出，有IntegerCache类参与，其实是Integer的一个内部类，源码如下： 1234567891011121314151617181920212223242526272829303132333435Integer.java private static class IntegerCache &#123; static final int low = -128; static final int high; static final Integer cache[]; static &#123; // high value may be configured by property int h = 127; String integerCacheHighPropValue = VM.getSavedProperty(\"java.lang.Integer.IntegerCache.high\"); if (integerCacheHighPropValue != null) &#123; try &#123; int i = parseInt(integerCacheHighPropValue); i = Math.max(i, 127); // Maximum array size is Integer.MAX_VALUE h = Math.min(i, Integer.MAX_VALUE - (-low) -1); &#125; catch( NumberFormatException nfe) &#123; // If the property cannot be parsed into an int, ignore it. &#125; &#125; high = h; cache = new Integer[(high - low) + 1]; int j = low; for(int k = 0; k &lt; cache.length; k++) cache[k] = new Integer(j++); // range [-128, 127] must be interned (JLS7 5.1.7) assert IntegerCache.high &gt;= 127; &#125; private IntegerCache() &#123;&#125; &#125; 通过源码可以看出，通过valueOf方法创建Integer对象，如果数值在-128到127之间(具体最大值还要看vm的配置)，直接返回IntegerCache中存在的引用，否则返回新的对象，就能解释true和false的问题了。 2.2 那么再来看一个问题123456789101112public class Main &#123; public static void main(String[] args) &#123; Double i1 = 100.0; Double i2 = 100.0; Double i3 = 200.0; Double i4 = 200.0; System.out.println(i1==i2); System.out.println(i3==i4); &#125;&#125; 结果是： false false 又错了吧，应该好好再看看源码的，可恶，没错Double类的valueOf源码的实现和Integet不一样，这里就不贴源码了，看的真心疼，大佬们的代码能力真的是很强。回到问题，源码中Double并没有像Integer那个有规定cache数组等相关的操作，大概我们能使用到double的地方的话代表精度很大，没必要吧，所以Double每次的装箱都是返回新的对象。 总结下： Integer，Short，Byte，Character，Long这几个类的valueOf类似，Double，Float的类似 2.3 这里原作者还提到了boolean变量，看例子12345678910111213141516public class Main &#123; public static void main(String[] args) &#123; Boolean i1 = false; Boolean i2 = false; Boolean i3 = true; Boolean i4 = true; System.out.println(i1==i2); System.out.println(i3==i4); &#125;&#125;// 结果： true true 通过源码可以很直接的看出 12345Boolean.javapublic static Boolean valueOf(boolean b) &#123; return (b ? TRUE : FALSE);&#125; emememem，很简单直观，看看True和False 1234Boolean.javapublic static final Boolean TRUE = new Boolean(true);public static final Boolean FALSE = new Boolean(false); 可以看出，是类成员属性 2.4 Integer i = new Integer(xxx)和Integer i =xxx;这两种方式的区别。（没错，这里copy原文）当然，这个题目属于比较宽泛类型的。但是要点一定要答上，我总结一下主要有以下这两点区别： 第一种方式不会触发自动装箱的过程；而第二种方式会触发； 在执行效率和资源占用上的区别。第二种方式的执行效率和资源占用在一般性情况下要优于第一种情况（注意这并不是绝对的）。 2.5 看下面完整的例子这里就当做读者都了解 == 和 equals 的区别了 12345678910111213141516171819202122// 引用原作者的例子强行解释public class Main &#123; public static void main(String[] args) &#123; Integer a = 1; Integer b = 2; Integer c = 3; Integer d = 3; Integer e = 321; Integer f = 321; Long g = 3L; Long h = 2L; System.out.println(c==d); //1.true System.out.println(e==f); //2.false System.out.println(c==(a+b)); //3.true System.out.println(c.equals(a+b)); //4.true System.out.println(g==(a+b)); //5.true System.out.println(g.equals(a+b)); //6.false System.out.println(g.equals(a+h)); //7.true &#125;&#125; 这里挑几点讲解 第3点，1+2触发自动拆箱，和c比较的是数值是否相等 第4点，a+b先触发拆箱求和后再触发装箱，调用valueOf方法 这里对比第6点和第7点：a+b通过拆装箱最后还是Integer类型，g调用的是Long类型的equals，看下面的源码，先比较的是类型，由于类型不对，所以false；这里看看第7点，h是long类型，所以a+b会隐式转换成long的类型，与g类型相同。 相关类型的的equals源码1234567891011121314151617Integer.java public boolean equals(Object obj) &#123; if (obj instanceof Integer) &#123; return value == ((Integer)obj).intValue(); &#125; return false; &#125;Long.java public boolean equals(Object obj) &#123; if (obj instanceof Long) &#123; return value == ((Long)obj).longValue(); &#125; return false; &#125;","tags":[{"name":"随笔","slug":"随笔","permalink":"http://yoursite.com/tags/随笔/"}]},{"title":"关于java.lang.UnsupportedOperationException异常","date":"2018-04-05T03:37:56.000Z","path":"2018/04/05/essays/asListException/","text":"引言： 这里感谢我们的组长提出这个问题，然后我去查看源码后发现了导致这个问题的原因。 1. 是什么，原因在调用Arrays类的aslist函数把数组转换成List集合不能对其进行添加删除等操作，否则抛出UnsupportedOperationException的异常，代码如下： 123456789101112131415zzz.javapackage Test;import java.util.Arrays;import java.util.List;public class zzz &#123; public static void main(String[] args) &#123; Integer[] arr = &#123;1, 2, 3, 4&#125;; List&lt;Integer&gt; list = Arrays.asList(arr); list.add(3); //error list.remove(2); //error &#125;&#125; 运行代码将抛出一下错误： 1234Exception in thread \"main\" java.lang.UnsupportedOperationException at java.base/java.util.AbstractList.add(AbstractList.java:153) at java.base/java.util.AbstractList.add(AbstractList.java:111) at Test.zzz.main(zzz.java:10) 根据字面意思，unsupportedOperationException就是对该实例不支持相应的函数操作。 也许有人问，list接口明明提供相应的接口，并且ArrayList明明实现了add等操作函数，为什么不支持。问题就在这，aslist返回的ArrayList实例并不是我们之前学的Arraylist的实例，而是Arrays类的静态内部类的实例，看源码 12345Arrays.java public static &lt;T&gt; List&lt;T&gt; asList(T... a) &#123; return new ArrayList&lt;&gt;(a); &#125; asList的源码，跟踪ArrayList的创建方法，继续看源码。只需要注意继承和实现类和接口还有实现的相关函数，直接跳到解析部分： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126Arrays.java /** * @serial include */ private static class ArrayList&lt;E&gt; extends AbstractList&lt;E&gt; implements RandomAccess, java.io.Serializable &#123; private static final long serialVersionUID = -2764017481108945198L; private final E[] a; ArrayList(E[] array) &#123; a = Objects.requireNonNull(array); &#125; @Override public int size() &#123; return a.length; &#125; @Override public Object[] toArray() &#123; return Arrays.copyOf(a, a.length, Object[].class); &#125; @Override @SuppressWarnings(\"unchecked\") public &lt;T&gt; T[] toArray(T[] a) &#123; int size = size(); if (a.length &lt; size) return Arrays.copyOf(this.a, size, (Class&lt;? extends T[]&gt;) a.getClass()); System.arraycopy(this.a, 0, a, 0, size); if (a.length &gt; size) a[size] = null; return a; &#125; @Override public E get(int index) &#123; return a[index]; &#125; @Override public E set(int index, E element) &#123; E oldValue = a[index]; a[index] = element; return oldValue; &#125; @Override public int indexOf(Object o) &#123; E[] a = this.a; if (o == null) &#123; for (int i = 0; i &lt; a.length; i++) if (a[i] == null) return i; &#125; else &#123; for (int i = 0; i &lt; a.length; i++) if (o.equals(a[i])) return i; &#125; return -1; &#125; @Override public boolean contains(Object o) &#123; return indexOf(o) &gt;= 0; &#125; @Override public Spliterator&lt;E&gt; spliterator() &#123; return Spliterators.spliterator(a, Spliterator.ORDERED); &#125; @Override public void forEach(Consumer&lt;? super E&gt; action) &#123; Objects.requireNonNull(action); for (E e : a) &#123; action.accept(e); &#125; &#125; @Override public void replaceAll(UnaryOperator&lt;E&gt; operator) &#123; Objects.requireNonNull(operator); E[] a = this.a; for (int i = 0; i &lt; a.length; i++) &#123; a[i] = operator.apply(a[i]); &#125; &#125; @Override public void sort(Comparator&lt;? super E&gt; c) &#123; Arrays.sort(a, c); &#125; @Override public Iterator&lt;E&gt; iterator() &#123; return new ArrayItr&lt;&gt;(a); &#125; &#125; private static class ArrayItr&lt;E&gt; implements Iterator&lt;E&gt; &#123; private int cursor; private final E[] a; ArrayItr(E[] a) &#123; this.a = a; &#125; @Override public boolean hasNext() &#123; return cursor &lt; a.length; &#125; @Override public E next() &#123; int i = cursor; if (i &gt;= a.length) &#123; throw new NoSuchElementException(); &#125; cursor = i + 1; return a[i]; &#125; &#125; 调用的是Arrays.java内部类的构造方法ArrayList，然而这个静态内部类并没有实现add等相关的方法，怀着好奇心，继续研究源码，发现这个内部类并没有直接实现List接口，而是通过继承AbstractList来间接实现List接口，我们来看看AbstractList的add和remove源码部分： 123456789AbstractList.java public void add(int index, E element) &#123; throw new UnsupportedOperationException(); &#125; public E remove(int index) &#123; throw new UnsupportedOperationException(); &#125; 真相大白有没有，Arrays的静态内部类ArrayList并没有改写从AbstractList继承的源码，那么调用add和remove等相关函数时，就会调用AbstractList实现的相关方法，然而内容只有抛出异常，没有其它相关的实现操作。 2. 那么如何操作转换呢我这里知道的有两种，欢迎━(｀∀´)ノ亻!补充 使用Iterator迭代器，迭代访问赋值 直接使用new ArrayList(Collection&lt;? extends E&gt; c)构造方法，这里注意，ArrayList并没有提供集合以外的参数构造，所以一开始的Integer类型的数组老老实实的迭代添加吧(偷笑), 为什么迭代器，而不是for， get来，效率问题，谷歌去。 总结asList调用的是Arrays.java的静态内部类的构造方法，然而那个方法并没有实现add等相关修改数量大小的方法，也许这就是他们想要的目的，但是内容还是能通过set修改。","tags":[{"name":"随笔","slug":"随笔","permalink":"http://yoursite.com/tags/随笔/"}]},{"title":"getResourceAsStream和getSystemResourceAsStream等获取配置文件的路径表示","date":"2018-03-24T16:16:26.000Z","path":"2018/03/25/essays/pro-path/","text":"解释下：包名下都有对应一样的配置文件名，方便确定配置文件的位置，测试类也一样，应该能马上看得出 1.相对路径根据我前面proper的几种读取方式中，只有ClassName.class.getResourceAsStream使用的才是相对路径。 配置文件.properties path kkk kkk/kkk.properties zzz ../../zzz/zzz.properties src ../../src.properties 1. kkk文件在与TestProperUtil同目录下的目录kkk下所以是kkk/文件 2. zzz 文件是在Testxxx上上级也就是src目录下的zzz目录中，其中..是上一级目录的意思 3. src是上上级目录下的文件 2. src下的绝对路径，不包括src的使用方式有三种： ClassLoadergetSystemResourceAsStream ClassName.class.getClassLoader().getResourceAsStream ResourceBundle.getBundle 注意：getBundle那个路径文件不加后缀名 配置文件.properties path kkk properties/test/kkk/kkk.properties zzz zzz/zzz.properties prop properties/prop.properties 1. kkk在src目录下的properties中的test目录的kkk目录下，所以path是properties/test/kkk/kkk.properties 2. zzz 同理 3.关于boot配置文件不知道怎么取得其配置，或者就取不到，希望有人告知，待更新","tags":[{"name":"properties","slug":"properties","permalink":"http://yoursite.com/tags/properties/"}]},{"title":"加载properties配置文件的六种方式","date":"2018-03-23T15:13:20.000Z","path":"2018/03/23/essays/sixWayLoadProperties/","text":"1.是什么？1.1定义.properties是一种主要在java相关技术中用来存储应用程序的可配置参数的文件的文件扩展名。也可以存储用于国际化和本地化的字符串，这种文件被称为属性资源包。 1.2内容与格式 简单来说是类似map的键-值对存储方式，类型都是String字符串。 语法有以下几种： 以#和！号作为一行中的第一个字符表示注释 反斜杠(\\)用于转义 键=值表示 2.适用场合？优缺点，有无可替代对比？ java下常见的几种配置文件格式(在下资历少，只说三种)，其排序。适合人类编写：properties &gt; yaml &gt; xml可以存储数据的复杂度： xml &gt; yaml &gt; properties .properties的优点怕是只有简单这一说法了，缺点就是因为其简单，所以不支持层级关系，而且其文件的编码是ISO-8859-1，又称Latin-1，导致没法加载中文。 xml: 从排序来看，xml是层次结构的，存储内容复杂，但是就拥有了强大的表达能力。缺点分析起来复杂，对人类不太友好，不易阅读，所以一般不是用来让人写的，而是机器间的自我生成和解析，比如javafx图形界面生成的xml文档。 yaml：替代xml。 比xml好的地方有： yaml可读性好 yaml和脚本语言的交互性好 yaml的语法和高级语言类似，进行简单表达 yaml有一个一致性的类型信息模型 yaml易于实现yaml与xml相同的： yaml可以基于流来处理； yaml表达能力强，存储的数据复杂度也高。 综上所述：YAML 是以数据为设计语言的重点的，而不是像 XML 以标记为重点。实事上，正是因为这样一种设计理念使得 YAML 在后来的不少应用中取代XML，成为一种可读性高，易于表达数据序列的编程语言。YAML 和 XML也许只是有其不同的应用场景和使用范围。公认的是，yaml凭借易读性成为xml的对手。 properties可以用于简单的几乎不会变动的配置，如果是一些要经常改动的业务就可以使用yaml类配置 3.怎么用？下文的配置文件路径的具体表示点击跳转链接 先声明下全局变量12private static String basePath = \"src/properties/prop.properties\";private static String name = \"\"; 3.1使用java.util.Properties类的load(InputStream)方法加载properties文件 注意：这里的basepath是src目录开始的路径 1234567891011121314public static String getPath()&#123; try (InputStream in = new BufferedInputStream(new FileInputStream( new File(basePath))))&#123; Properties pro = new Properties(); pro.load(in); name = pro.getProperty(\"name\"); &#125; catch (FileNotFoundException e)&#123; e.printStackTrace(); &#125; catch (IOException e)&#123; e.printStackTrace(); &#125; return name; &#125; 3.2使用java.util.ResourceBundle类的getBudle()方法 注意：这个getBundle()方法的参数只能写成包路径+properties文件名，否则将抛异常,并且路径是使用用src下的包名(不包括src)+文件名的方式 12345public static String getPath()&#123; ResourceBundle rb = ResourceBundle.getBundle(\"properties/test/kkk/kkk\"); name = rb.getString(\"name\"); return name; &#125; 3.3使用java.util.PropertyResourceBudle类的构造函数1234567891011public static String getPath()&#123; try (InputStream in = new BufferedInputStream(new FileInputStream(basePath))) &#123; ResourceBundle rb = new PropertyResourceBundle(in); name = rb.getString(\"name\"); &#125; catch (FileNotFoundException e)&#123; e.printStackTrace(); &#125; catch (IOException e)&#123; e.printStackTrace(); &#125; return name; &#125; 3.4使用class变量的getResourceAsStream()方法注意：getResourceAsStream()方法的参数按格式写到包路径+properties文件名+.后缀 注意：路径使用的是相对路径 123456789101112public static String getPath()&#123; Properties p = new Properties(); try (InputStream in = TestProperUtil.class .getResourceAsStream(\"../../src.properties\"))&#123; p.load(in); name = p.getProperty(\"name\"); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; return name; &#125; 3.5使用class.getClassLoader()所得到的java.lang.ClassLoader的getResourceAsStream()方法getResourceAsStream(name)方法的参数必须是包路径+文件名+.后缀否则会报空指针异常 路径名和3.2一样 1234567891011public static String getPath() &#123; try (InputStream in = TestProperUtil.class.getClassLoader() .getResourceAsStream(\"zzz/zzz.properties\"))&#123; Properties p = new Properties(); p.load(in); name = p.getProperty(\"name\"); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; return name; &#125; 3.6使用java.lang.ClassLoader类的getSystemResourceAsStream()静态方法getSystemResourceAsStream()方法的参数格式也是有固定要求的 注意： 路径名和3.2一样的表示 1234567891011public static String getPath() &#123; try (InputStream in = ClassLoader .getSystemResourceAsStream(\"src.properties\"))&#123; Properties pro = new Properties(); pro.load(in); name = pro.getProperty(\"name\"); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; return name; &#125;","tags":[{"name":"配置文件","slug":"配置文件","permalink":"http://yoursite.com/tags/配置文件/"}]},{"title":"HexoMarkdown","date":"2018-03-22T15:17:08.000Z","path":"2018/03/22/WriteTest/","text":"引言：HexoMd 的语法，基本够用，欢迎补充(能用得到的)与修正，部分细节有待修改（基于主题BlueLake)Markdown 语法版本很多，不同地方部分语法不相兼容，导致网上部分语法不能再hexo上使用，以下是整理的能在hexo的部分语法。 1.Tab字前tab会加灰框 2.#的用法用来表示几级标题 # frist title ## second title ### third title 3.超链接3.1显示链接的图片![name](url) 显示链接的图片 ![this is page](/images/keduoli.jpg) link: 3.2文字超链接[name](url) 文字超链接 [bilibili](https://www.bilibili.com/) bilibili 3.3图片超链接[![xxx](图片url)][要转移到的链接]图片超链接 [![enene](/images/keduoli.jpg)](https://nodesource.com/products/nsolid) 4.列表4.1.1无序列表 -，*，+， 两格缩进，列表与前一行的hello: - one - two - three eg: hello (没有衔接一起很神奇）（衔接的意思是hello和one之间分开了，相当于多了一行空行 one two three 不同行两格缩进看看效果： food bread apple pig ddd mmm 4.1.2两格缩进 （衔接在一起了，就是上下文紧靠） 登录微博开放平台，选择。 为了与注意风格统一，如下配置 嗯嗯嗯 （也衔接一起了） 基础设置： dsfs 样式设置： sdfa 模块设置： dsfa 4.2有序列表 序号. xxx(注意有空格） 登录微博开放平台，选择。 为了与注意风格统一，如下配置 嗯嗯嗯 5.用键代替链接，键值对匹配（连接在附录）关键字对上跳转的意思吧，[内容]和文章最后的[内容1](链接)对上 可以变成超链接，前后内容忽略大小写，也能匹配。这里注意最后一 个，如果最后几个字也要跳转，单单加[1]没用得再加[2]来达到目 的，此时内容为1，但是跳转到的目的为2 Markdown is a lightweight markup language based on the formatting conventions that people naturally use in email. As [John Gruber] writes on the [Markdown site] Markdown is a lightweight markup language based on the formatting conventions that people naturally use in email.As John Gruber writes on the Markdown site 6.可以用来注意，引用,可以多层&gt; The overriding design goal for Markdown&apos;s &gt;&gt; formatting syntax is to make it as readable &gt; as possible. The idea is that. eg: The overriding design goal for Markdown’s formatting syntax is to make it as readableas possible. The idea is that. 7.代码块 eg:123$ cd dillinger$ npm install -d$ node app 123public static void main(String[] args)&#123; System.out.println(\"I think it's good\");&#125; 8.表格制表第一行和第二行列必须对应数量相等（注意，冒号和杠之间有空格） | Plugin | README | sdflj | | ------ | ：------： | -----： | 右对齐，居中，左对齐 | Dropbox | [plugins/dropbox/README.md][PlDb] | dsf | | Github | [plugins/github/README.md][PlGh] | sdf | | Google Drive | [plugins/googledrive/README.md][PlGd] | dsfs | | OneDrive | [plugins/onedrive/README.md][PlOd] | dsfj | | Medium | [plugins/medium/README.md][PlMe] | | Google Analytics | [plugins/googleanalytics/README.md][PlGa] | eg: Plugin README sdflj Dropbox plugins/dropbox/README.md dsf Github plugins/github/README.md sdf Google Drive plugins/googledrive/README.md dsfs OneDrive plugins/onedrive/README.md dsfj Medium plugins/medium/README.md df Google Analytics plugins/googleanalytics/README.md dsdg eg：This will create the dillinger image and pull in the necessary dependencies. Be sure to swap out ${package.json.version} with the actual version of Dillinger. 9.文字9.1文字背景`xxx` 背景颜色加灰 I love `you` red line eg:I love you red line 9.2文字加粗加粗 **Software** Free Software, Hell Yeah! 9.3删除线~~xxx~~ 我喜欢javapython 待更新附录： [dill]: &lt;https://github.com/joemccann/dillinger&gt; [git-repo-url]: &lt;https://github.com/joemccann/dillinger.git&gt; [john gruber]: &lt;http://daringfireball.net&gt; [df1]: &lt;http://daringfireball.net/projects/markdown/&gt; [PlMe]: &lt;https://github.com/joemccann/dillinger/tree/master/plugins/medium/README.md&gt; [PlGa]: &lt;https://github.com/RahulHP/dillinger/blob/master/plugins/googleanalytics/README.md&gt;","tags":[{"name":"markdown","slug":"markdown","permalink":"http://yoursite.com/tags/markdown/"}]},{"title":"Hello World","date":"2018-03-22T09:34:27.055Z","path":"2018/03/22/hello-world/","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","tags":[]}]