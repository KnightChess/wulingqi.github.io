[{"title":"getResourceAsStream和getSystemResourceAsStream等获取配置文件的路径表示","date":"2018-03-24T16:16:26.000Z","path":"2018/03/25/pro-path/","text":"解释下：包名下都有对应一样的配置文件名，方便确定配置文件的位置，测试类也一样，应该能马上看得出 1.相对路径根据我前面proper的几种读取方式中，只有ClassName.class.getResourceAsStream使用的才是相对路径。 配置文件.properties path kkk kkk/kkk.properties zzz ../../zzz/zzz.properties src ../../src.properties 1. kkk文件在与TestProperUtil同目录下的目录kkk下所以是kkk/文件 2. zzz 文件是在Testxxx上上级也就是src目录下的zzz目录中，其中..是上一级目录的意思 3. src是上上级目录下的文件 2. src下的绝对路径，不包括src的使用方式有三种： ClassLoadergetSystemResourceAsStream ClassName.class.getClassLoader().getResourceAsStream ResourceBundle.getBundle 注意：getBundle那个路径文件不加后缀名 配置文件.properties path kkk properties/test/kkk/kkk.properties zzz zzz/zzz.properties prop properties/prop.properties 1. kkk在src目录下的properties中的test目录的kkk目录下，所以path是properties/test/kkk/kkk.properties 2. zzz 同理 3.关于boot配置文件不知道怎么取得其配置，或者就取不到，希望有人告知，待更新","tags":[{"name":"properties","slug":"properties","permalink":"http://yoursite.com/tags/properties/"}]},{"title":"加载properties配置文件的六种方式","date":"2018-03-23T15:13:20.000Z","path":"2018/03/23/sixWayLoadProperties/","text":"1.是什么？1.1定义.properties是一种主要在java相关技术中用来存储应用程序的可配置参数的文件的文件扩展名。也可以存储用于国际化和本地化的字符串，这种文件被称为属性资源包。 1.2内容与格式 简单来说是类似map的键-值对存储方式，类型都是String字符串。 语法有以下几种： 以#和！号作为一行中的第一个字符表示注释 反斜杠()用于转义 键=值表示 2.适用场合？有无可替代对比？3.怎么用？文件路径的具体表示点击这里 先声明下全局变量12private static String basePath = \"src/properties/prop.properties\";private static String name = \"\"; 3.1使用java.util.Properties类的load(InputStream)方法加载properties文件 注意：这里的basepath是src目录开始的路径 1234567891011121314public static String getPath()&#123; try (InputStream in = new BufferedInputStream(new FileInputStream( new File(basePath))))&#123; Properties pro = new Properties(); pro.load(in); name = pro.getProperty(\"name\"); &#125; catch (FileNotFoundException e)&#123; e.printStackTrace(); &#125; catch (IOException e)&#123; e.printStackTrace(); &#125; return name; &#125; 3.2使用java.util.ResourceBundle类的getBudle()方法 注意：这个getBundle()方法的参数只能写成包路径+properties文件名，否则将抛异常,并且路径是使用用src下的包名(不包括src)+文件名的方式 12345public static String getPath()&#123; ResourceBundle rb = ResourceBundle.getBundle(\"properties/test/kkk/kkk\"); name = rb.getString(\"name\"); return name; &#125; 3.3使用java.util.PropertyResourceBudle类的构造函数1234567891011public static String getPath()&#123; try (InputStream in = new BufferedInputStream(new FileInputStream(basePath))) &#123; ResourceBundle rb = new PropertyResourceBundle(in); name = rb.getString(\"name\"); &#125; catch (FileNotFoundException e)&#123; e.printStackTrace(); &#125; catch (IOException e)&#123; e.printStackTrace(); &#125; return name; &#125; 3.4使用class变量的getResourceAsStream()方法注意：getResourceAsStream()方法的参数按格式写到包路径+properties文件名+.后缀 注意：路径使用的是相对路径 123456789101112public static String getPath()&#123; Properties p = new Properties(); try (InputStream in = TestProperUtil.class .getResourceAsStream(\"../../src.properties\"))&#123; p.load(in); name = p.getProperty(\"name\"); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; return name; &#125; 3.5使用class.getClassLoader()所得到的java.lang.ClassLoader的getResourceAsStream()方法getResourceAsStream(name)方法的参数必须是包路径+文件名+.后缀否则会报空指针异常 路径名和3.2一样 1234567891011public static String getPath() &#123; try (InputStream in = TestProperUtil.class.getClassLoader() .getResourceAsStream(\"zzz/zzz.properties\"))&#123; Properties p = new Properties(); p.load(in); name = p.getProperty(\"name\"); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; return name; &#125; 3.6使用java.lang.ClassLoader类的getSystemResourceAsStream()静态方法getSystemResourceAsStream()方法的参数格式也是有固定要求的 注意： 路径名和3.2一样的表示 1234567891011public static String getPath() &#123; try (InputStream in = ClassLoader .getSystemResourceAsStream(\"src.properties\"))&#123; Properties pro = new Properties(); pro.load(in); name = pro.getProperty(\"name\"); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; return name; &#125;","tags":[{"name":"配置文件","slug":"配置文件","permalink":"http://yoursite.com/tags/配置文件/"}]},{"title":"HexoMarkdown","date":"2018-03-22T15:17:08.000Z","path":"2018/03/22/WriteTest/","text":"引言：HexoMd 的语法，基本够用，欢迎补充(能用得到的)与修正，部分细节有待修改（基于主题BlueLake)Markdown 语法版本很多，不同地方部分语法不相兼容，导致网上部分语法不能再hexo上使用，以下是整理的能在hexo的部分语法。 1.Tab字前tab会加灰框 2.#的用法用来表示几级标题 # frist title ## second title ### third title 3.超链接3.1显示链接的图片![name](url) 显示链接的图片 ![this is page](/images/keduoli.jpg) link: 3.2文字超链接[name](url) 文字超链接 [bilibili](https://www.bilibili.com/) bilibili 3.3图片超链接[![xxx](图片url)][要转移到的链接]图片超链接 [![enene](/images/keduoli.jpg)](https://nodesource.com/products/nsolid) 4.列表4.1.1无序列表 -，*，+， 两格缩进，列表与前一行的hello: - one - two - three eg: hello (没有衔接一起很神奇） one two three food bread apple pig ddd mmm 4.1.2两格缩进 （衔接在一起了） 登录微博开放平台，选择。 为了与注意风格统一，如下配置 嗯嗯嗯 （也衔接一起了） 基础设置： dsfs 样式设置： sdfa 模块设置： dsfa 4.2有序列表 序号. xxx(注意有空格） 登录微博开放平台，选择。 为了与注意风格统一，如下配置 嗯嗯嗯 5.用键代替链接，键值对匹配关键字对上跳转的意思吧，[内容]和文章最后的[内容1](链接)对上 可以变成超链接，前后内容忽略大小写，也能匹配。这里注意最后一 个，如果最后几个字也要跳转，单单加[1]没用得再加[2]来达到目 的，此时内容为1，但是跳转到的目的为2 Markdown is a lightweight markup language based on the formatting conventions that people naturally use in email. As [John Gruber] writes on the [Markdown site] Markdown is a lightweight markup language based on the formatting conventions that people naturally use in email.As John Gruber writes on the Markdown site 6.可以用来注意，引用,可以多层&gt; The overriding design goal for Markdown&apos;s &gt;&gt; formatting syntax is to make it as readable &gt; as possible. The idea is that. eg: The overriding design goal for Markdown’s formatting syntax is to make it as readableas possible. The idea is that. 7.代码块代码表示 1 123$ cd dillinger$ npm install -d$ node app eg:123$ cd dillinger$ npm install -d$ node app 123public static void main(String[] args)&#123; System.out.println(\"I think it's good\");&#125; 8.表格制表第一行和第二行列必须对应数量相等 | Plugin | README | sdflj | | ------ | ：------： | -----： | 右对齐，居中，左对齐 | Dropbox | [plugins/dropbox/README.md][PlDb] | dsf | | Github | [plugins/github/README.md][PlGh] | sdf | | Google Drive | [plugins/googledrive/README.md][PlGd] | dsfs | | OneDrive | [plugins/onedrive/README.md][PlOd] | dsfj | | Medium | [plugins/medium/README.md][PlMe] | | Google Analytics | [plugins/googleanalytics/README.md][PlGa] | eg: Plugin README sdflj Dropbox plugins/dropbox/README.md dsf Github plugins/github/README.md sdf Google Drive plugins/googledrive/README.md dsfs OneDrive plugins/onedrive/README.md dsfj Medium plugins/medium/README.md df Google Analytics plugins/googleanalytics/README.md dsdg eg：This will create the dillinger image and pull in the necessary dependencies. Be sure to swap out ${package.json.version} with the actual version of Dillinger. 9.文字9.1文字背景`xxx` 背景颜色加灰 I love `you` red line eg:I love you red line 9.2文字加粗加粗 **Software** Free Software, Hell Yeah! 9.3删除线~~xxx~~ 我喜欢javapython 待更新附录： [dill]: &lt;https://github.com/joemccann/dillinger&gt; [git-repo-url]: &lt;https://github.com/joemccann/dillinger.git&gt; [john gruber]: &lt;http://daringfireball.net&gt; [df1]: &lt;http://daringfireball.net/projects/markdown/&gt; [PlMe]: &lt;https://github.com/joemccann/dillinger/tree/master/plugins/medium/README.md&gt; [PlGa]: &lt;https://github.com/RahulHP/dillinger/blob/master/plugins/googleanalytics/README.md&gt;","tags":[{"name":"markdown","slug":"markdown","permalink":"http://yoursite.com/tags/markdown/"}]},{"title":"Hello World","date":"2018-03-22T09:34:27.055Z","path":"2018/03/22/hello-world/","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","tags":[]}]