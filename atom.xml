<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>KnightChess</title>
  
  <subtitle>The shortest answer is doing.</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-04-12T08:54:54.287Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>wu07</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>抽象类和接口(非blog，Not recommended)(update ing)</title>
    <link href="http://yoursite.com/2018/04/12/abstract-class/"/>
    <id>http://yoursite.com/2018/04/12/abstract-class/</id>
    <published>2018-04-12T08:54:54.000Z</published>
    <updated>2018-04-12T08:54:54.287Z</updated>
    
    <content type="html"><![CDATA[<h2 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h2><h3 id="什么是抽象类"><a href="#什么是抽象类" class="headerlink" title="什么是抽象类"></a>什么是抽象类</h3><p>首先了解什么是抽象方法，抽象方法就是只声明，没有具体实现，eg如下:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">zzz</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure></p><p>必须用abstract进行修饰，如果一个类中含有抽象方法，那么称这个类为抽象方法，抽象方法必须也用abstract进行修饰。</p><blockquote><p>注意： 抽象方法不能用来创建对象。这里来自某blog的大佬说在java编程思想中对抽象类的定义为“包含抽象方法的类”，但是后面看源码时有的抽象类其实内部什么方法都没有，然而还是声明成抽象类。算了，细节问题不要在意。</p></blockquote><h3 id="有什么用，用在哪"><a href="#有什么用，用在哪" class="headerlink" title="有什么用，用在哪:"></a>有什么用，用在哪:</h3><p>怎么说，按我的理解，就是为了继承实现多态的，多态的概念就不用解释了</p><h3 id="怎么用？-不可能教你怎么用的，自己看书，自己谷歌"><a href="#怎么用？-不可能教你怎么用的，自己看书，自己谷歌" class="headerlink" title="怎么用？(不可能教你怎么用的，自己看书，自己谷歌)"></a>怎么用？(不可能教你怎么用的，自己看书，自己谷歌)</h3><h3 id="注意的问题"><a href="#注意的问题" class="headerlink" title="注意的问题"></a>注意的问题</h3><ol><li>访问修饰符里虽然也有提到过，但是抽象类的方法必须为public或者protected，毕竟子类必须有能够访问的能力进行事项</li><li>如果子类继承了抽象父类，如果没有全部重写父类的所有抽象方法，那么子类依然是抽象类，依然不能实例化。</li></ol><h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><h3 id="什么是接口"><a href="#什么是接口" class="headerlink" title="什么是接口"></a>什么是接口</h3><p>怎么说，可以理解为纯粹的抽象类吧，接口泛指别人调用的方法或者函数，是对行为的抽象（下面对比的时候会解释的）</p><h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><ol><li>接口中可以含有 变量和方法。但是要注意，接口中的变量会被隐式地指定为public static final变量（并且只能是public static final变量，用private修饰会报编译错误），而方法会被隐式地指定为public abstract方法且只能是public abstract方法（用其他关键字，比如private、protected、static、 final等修饰会报编译错误），并且接口中所有的方法不能有具体的实现，也就是说，接口中的方法必须都是抽象方法。从这里可以隐约看出接口和抽象类的区别，接口是一种极度抽象的类型，它比抽象类更加“抽象”，并且一般情况下不在接口中定义变量。</li><li>重点： 第1个注意点中，只适合老版本，jdk1.8以下的版本，在jdk1.8中接口加入了新概念，扩展了接口的含义：默认方法和静态方法，默认方法使得接口有点类似traits吧，不过要实现的目标不一样。默认方法使得开发者可以在不破坏二进制兼容性的前提下，王现存的接口中添加新的方法，即不强制实现了该接口的类也可同时实现这个新加的方法。（可以通过转换调用）可以看出，默认方法和抽象方法之间的区别在于抽象方法需要实现，而默认方法不需要。接口提供的默认方法会被接口的实现类继承或者覆写。看个简单的例子</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">interface</span> <span class="title">Defaulable</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Interfaces now allow default methods, the implementer may or </span></span><br><span class="line">    <span class="comment">// may not implement (override) them.</span></span><br><span class="line">    <span class="function"><span class="keyword">default</span> String <span class="title">notRequired</span><span class="params">()</span> </span>&#123; </span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Default implementation"</span>; </span><br><span class="line">    &#125;        </span><br><span class="line">&#125;</span><br><span class="line">        </span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultableImpl</span> <span class="keyword">implements</span> <span class="title">Defaulable</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">OverridableImpl</span> <span class="keyword">implements</span> <span class="title">Defaulable</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">notRequired</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Overridden implementation"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//例子来源：（其实是我懒得写）</span></span><br><span class="line"><span class="comment">//作者：杜琪</span></span><br><span class="line"><span class="comment">//链接：https://www.jianshu.com/p/5b800057f2d8</span></span><br><span class="line"><span class="comment">//著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span></span><br></pre></td></tr></table></figure><p><code>此默认方法扩充了Collection的方法，比如stream(), parallelStream()等，Stream也是java8的一大亮点，专注于对集合对象进行各种流弊的操作，可以很方便写出高性能的并发程序，偏题了。</code></p><h2 id="那么，抽象类和接口的区别"><a href="#那么，抽象类和接口的区别" class="headerlink" title="那么，抽象类和接口的区别"></a>那么，抽象类和接口的区别</h2><p>语法层面上的区别（jdk1.8以下版本)</p><ul><li>抽象类可以提供成员方法的实现细节，而接口中只能存在public abstract 方法；</li><li>抽象类中的成员变量可以是各种类型的，而接口中的成员变量只能是public static final类型的；</li><li>接口中不能含有静态代码块以及静态方法，而抽象类可以有静态代码块和静态方法；</li><li>一个类只能继承一个抽象类，而一个类却可以实现多个接口。</li></ul><p>设计层面上的区别(<a href="http://www.importnew.com/18780.html" target="_blank" rel="noopener">那么多字，肯定不是我自己写的</a>)</p><ol><li>抽象类是对一种事物的抽象，即对类抽象，而接口是对行为的抽象。抽象类是对整个类整体进行抽象，包括属性、行为，但是接口却是对类局部（行为）进行抽象。举个简单的例子，飞机和鸟是不同类的事物，但是它们都有一个共性，就是都会飞。那么在设计的时候，可以将飞机设计为一个类Airplane，将鸟设计为一个类Bird，但是不能将 飞行 这个特性也设计为类，因此它只是一个行为特性，并不是对一类事物的抽象描述。此时可以将 飞行 设计为一个接口Fly，包含方法fly( )，然后Airplane和Bird分别根据自己的需要实现Fly这个接口。然后至于有不同种类的飞机，比如战斗机、民用飞机等直接继承Airplane即可，对于鸟也是类似的，不同种类的鸟直接继承Bird类即可。从这里可以看出，继承是一个 “是不是”的关系，而 接口 实现则是 “有没有”的关系。如果一个类继承了某个抽象类，则子类必定是抽象类的种类，而接口实现则是有没有、具备不具备的关系，比如鸟是否能飞（或者是否具备飞行这个特点），能飞行则可以实现这个接口，不能飞行就不实现这个接口。</li><li>设计层面不同，抽象类作为很多子类的父类，它是一种模板式设计。而接口是一种行为规范，它是一种辐射式设计。什么是模板式设计？最简单例子，大家都用过ppt里面的模板，如果用模板A设计了ppt B和ppt C，ppt B和ppt C公共的部分就是模板A了，如果它们的公共部分需要改动，则只需要改动模板A就可以了，不需要重新对ppt B和ppt C进行改动。而辐射式设计，比如某个电梯都装了某种报警器，一旦要更新报警器，就必须全部更新。也就是说对于抽象类，如果需要添加新的方法，可以直接在抽象类中添加具体的实现，子类可以不进行变更；而对于接口则不行，如果接口进行了变更，则所有实现这个接口的类都必须进行相应的改动。</li></ol><blockquote><p>简单来说，抽象类就是个模板类，接口是一种行为规范，就像上面说的辐射式设计，但是，对于新版本的jdk1.8，个人感觉也具有一定模板式设计了，都引入的默认方法了，和抽象类中非抽象方法有什么区别。但是，其设计层面的区别还主要是接口是对行为的抽象，新版本的小疑问以后再做考虑。</p></blockquote><h2 id="接口其它应用"><a href="#接口其它应用" class="headerlink" title="接口其它应用"></a>接口其它应用</h2><p>应用很多，有与设计模式相关的适配器，工厂模式等，具体详细请看java便构成思想，还有接口为什么优于抽象类等相关问题请看effective java。</p><h2 id="补充：-对上面新版本中接口不就是抽象类的进行解释"><a href="#补充：-对上面新版本中接口不就是抽象类的进行解释" class="headerlink" title="补充： 对上面新版本中接口不就是抽象类的进行解释"></a>补充： 对上面新版本中接口不就是抽象类的进行解释</h2><p>详细见<a href="https://my.oschina.net/benhaile/blog/176007" target="_blank" rel="noopener">开源中国</a></p><h1 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h1><p><a href="http://www.importnew.com/18780.html" target="_blank" rel="noopener">http://www.importnew.com/18780.html</a><br><a href="https://www.jianshu.com/p/038f0b356e9a" target="_blank" rel="noopener">https://www.jianshu.com/p/038f0b356e9a</a><br><a href="http://arthur503.github.io/blog/2013/10/10/Java-access-control.html" target="_blank" rel="noopener">http://arthur503.github.io/blog/2013/10/10/Java-access-control.html</a><br><a href="https://www.ibm.com/developerworks/cn/java/j-lo-java8streamapi/" target="_blank" rel="noopener">https://www.ibm.com/developerworks/cn/java/j-lo-java8streamapi/</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;抽象类&quot;&gt;&lt;a href=&quot;#抽象类&quot; class=&quot;headerlink&quot; title=&quot;抽象类&quot;&gt;&lt;/a&gt;抽象类&lt;/h2&gt;&lt;h3 id=&quot;什么是抽象类&quot;&gt;&lt;a href=&quot;#什么是抽象类&quot; class=&quot;headerlink&quot; title=&quot;什么是抽象类&quot;&gt;&lt;
      
    
    </summary>
    
      <category term="java" scheme="http://yoursite.com/categories/java/"/>
    
    
      <category term="java笔记" scheme="http://yoursite.com/tags/java%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>Java访问权限修饰符(非blog，Not recommended)(update ing)</title>
    <link href="http://yoursite.com/2018/04/12/ppt/"/>
    <id>http://yoursite.com/2018/04/12/ppt/</id>
    <published>2018-04-12T08:51:23.000Z</published>
    <updated>2018-04-12T08:54:40.575Z</updated>
    
    <content type="html"><![CDATA[<p>引言：java中有四种访问修饰符，public，protected，defaul（实际上没有这个关键词（大概懂我意思吧），就是默认的同一包内访问权限。），private，用于对方法，属性，类的修饰，但是部分可用。</p><p>访问权限和使用类别见一下两个表格</p><p><code>表格(一)</code></p><table><thead><tr><th style="text-align:center">修饰符</th><th style="text-align:center">修饰成员变量和函数</th><th style="text-align:center">修饰类</th></tr></thead><tbody><tr><td style="text-align:center">public</td><td style="text-align:center">yes</td><td style="text-align:center">yes</td></tr><tr><td style="text-align:center">protected</td><td style="text-align:center">yes</td><td style="text-align:center">no</td></tr><tr><td style="text-align:center">default</td><td style="text-align:center">yes</td><td style="text-align:center">yes</td></tr><tr><td style="text-align:center">private</td><td style="text-align:center">yes</td><td style="text-align:center">no</td></tr></tbody></table><p><code>表格(二)</code></p><table><thead><tr><th style="text-align:center">修饰符</th><th style="text-align:center">当前类</th><th style="text-align:center">同一包内</th><th style="text-align:center">子孙类</th><th style="text-align:center">其它包</th></tr></thead><tbody><tr><td style="text-align:center">public</td><td style="text-align:center">yes</td><td style="text-align:center">yes</td><td style="text-align:center">yes</td><td style="text-align:center">yes</td></tr><tr><td style="text-align:center">protected</td><td style="text-align:center">yes</td><td style="text-align:center">yes</td><td style="text-align:center">yes</td><td style="text-align:center">no</td></tr><tr><td style="text-align:center">default</td><td style="text-align:center">yes</td><td style="text-align:center">yes</td><td style="text-align:center">no</td><td style="text-align:center">no</td></tr><tr><td style="text-align:center">private</td><td style="text-align:center">yes</td><td style="text-align:center">no</td><td style="text-align:center">no</td><td style="text-align:center">no</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;引言：java中有四种访问修饰符，public，protected，defaul（实际上没有这个关键词（大概懂我意思吧），就是默认的同一包内访问权限。），private，用于对方法，属性，类的修饰，但是部分可用。&lt;/p&gt;
&lt;p&gt;访问权限和使用类别见一下两个表格&lt;/p&gt;
&lt;p
      
    
    </summary>
    
      <category term="java" scheme="http://yoursite.com/categories/java/"/>
    
    
      <category term="java笔记" scheme="http://yoursite.com/tags/java%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>java内部类(非blog，Not recommended)(update ing)</title>
    <link href="http://yoursite.com/2018/04/12/internalclass/"/>
    <id>http://yoursite.com/2018/04/12/internalclass/</id>
    <published>2018-04-12T08:18:22.896Z</published>
    <updated>2018-04-12T08:56:06.263Z</updated>
    
    <summary type="html">
    
    </summary>
    
      <category term="java" scheme="http://yoursite.com/categories/java/"/>
    
    
      <category term="java笔记" scheme="http://yoursite.com/tags/java%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>easyMock的简单使用（详细参考官方文档，第二问更新中）</title>
    <link href="http://yoursite.com/2018/04/09/easyMock-simple-use/"/>
    <id>http://yoursite.com/2018/04/09/easyMock-simple-use/</id>
    <published>2018-04-09T12:14:44.000Z</published>
    <updated>2018-04-14T01:01:51.745Z</updated>
    
    <content type="html"><![CDATA[<p>引言： 本文采取的例子来自 <a href="https://veerasundar.com/blog/2012/06/easymock-tutorial-getting-started/" target="_blank" rel="noopener">EasyMock tutorial – Getting Started</a>（就是原文啦）</p><h2 id="什么是Mock？"><a href="#什么是Mock？" class="headerlink" title="什么是Mock？"></a>什么是Mock？</h2><p>Mock其实就是模拟或者Stud，当你调用一个不好在测试中创建的对象时，Mock框架为你模拟一个和真实对象类似的数据类完成相应的行为。</p><blockquote><p>比如说：我接下来要写的股票问题，首先，股价时刻都在变动，我们一旦获取了当前的股价，并不代表一定是正确的数据，因为真实的股价是时刻都在变动的，所以我们要模拟一个检索股票的接口来获取数据，而不是去访问真实的服务器。</p></blockquote><h2 id="与PowerMock和JMock相比"><a href="#与PowerMock和JMock相比" class="headerlink" title="与PowerMock和JMock相比"></a>与PowerMock和JMock相比</h2><p>如今比较流行的工具JMock，EasyMock，Mockito等都有一个共同的缺点，就是不能mock静态，final，私有方法(但是可以mock类哦，前提类内部也没有以上属性的方法），而PowerMock能够完美的弥补以上三个Mock的不足（扩充而不是替代，可以提高代码测试的覆盖率，天哪，我到底为什么才知道），自行百度吧。（似乎还有个全能的Jmokit，等研究好了再补充）<br>某个工作的<a href="https://blog.coding.net/blog/mock-testing-tools" target="_blank" rel="noopener">作者遇到坑</a>，但是本萌现在还看不懂，大概因为用的是PowerMock，本萌还没学</p><h3 id="简单用法："><a href="#简单用法：" class="headerlink" title="简单用法："></a>简单用法：</h3><p>这里我们用一个简单的例子来简单的入门easyMock的用法。</p><h3 id="股票计算应用"><a href="#股票计算应用" class="headerlink" title="股票计算应用"></a>股票计算应用</h3><p>引言：首先，这个应用有一个接口，两个实体类和一个测试类。</p><ol><li>Stock类是用来表示股票的信息，含股票名和数量（我们可以想象成数据库所学的emp类）</li><li>Portfolio类保存不同股票的信息（想象成emplist一样，里面存着各种人员的信息），这个类中有一个计算所有股票价格的总和的方法getTotalValue()，我们要测试的就是这个方法。</li><li>StockMarket接口，也就是股市的意思，就是我们要模拟的接口，模拟这个接口里getPrice的数据</li></ol><p>内容：<br>上代码，首先是实体类Stock<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">Stock.java</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Stock</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Stock类用来存储股票的信息，名字和类型, 联想一下就是实体类emp</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> quantity;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Stock</span> <span class="params">(String name, <span class="keyword">int</span> quantity)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.quantity = quantity;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getQuantity</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> quantity;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setQuantity</span><span class="params">(<span class="keyword">int</span> quantity)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.quantity = quantity;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>然后是Protfolio类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Protfolio</span> </span>&#123;</span><br><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment">     *注意：硬编码依赖不是好的实践，我们不应该在此初始化stockMarket对象，</span></span><br><span class="line"><span class="comment"> *我们应该在使用测试代码的时候注入进来。(这里就先这样了）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 某个投资的名，这里不重要</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 模拟的接口，这里就当成是实际存在的进行使用</span></span><br><span class="line">    <span class="keyword">private</span> StockMarket stockMarket;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 保存股票的信息</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;Stock&gt; stocks = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 计算所有股票是价格，并返回</span></span><br><span class="line"><span class="comment">     * sock保存的各个股票的数量乘以通过接口stockMarket模拟获取的价格求和</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getTotalValue</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">double</span> value = <span class="number">0.0</span>;</span><br><span class="line">        <span class="keyword">for</span> (Stock stock: <span class="keyword">this</span>.stocks)&#123;</span><br><span class="line">            value += (stockMarket.getPrice(stock.getName()) * stock.getQuantity());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addStock</span><span class="params">(Stock stock)</span></span>&#123;</span><br><span class="line">        stocks.add(stock);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> StockMarket <span class="title">getStockMarket</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> stockMarket;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setStockMarket</span><span class="params">(StockMarket stockMarket)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.stockMarket = stockMarket;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Stock&gt; <span class="title">getStocks</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> stocks;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setStocks</span><span class="params">(List&lt;Stock&gt; stocks)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.stocks = stocks;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上就是所有业务的逻辑，很简单吧，sock股票信息，Port进行处理，stockMarket获取价格</p><p><code>然后是Junit和EasyMock测试Portfolio中的getTotalValue()方法</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">ProtfolioTest.java</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.wlq.easymock.dao.StockMarket;</span><br><span class="line"><span class="keyword">import</span> com.wlq.easymock.entity.Protfolio;</span><br><span class="line"><span class="keyword">import</span> com.wlq.easymock.entity.Stock;</span><br><span class="line"><span class="keyword">import</span> org.easymock.EasyMock;</span><br><span class="line"><span class="keyword">import</span> org.junit.Before;</span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.junit.Assert.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProtfolioTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Protfolio protfolio;</span><br><span class="line">    <span class="keyword">private</span> StockMarket marketMock;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Before</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUp</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        protfolio = <span class="keyword">new</span> Protfolio();</span><br><span class="line">        protfolio.setName(<span class="string">"wlq's portfolip."</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 模拟创建（StockMarket）股市的实例</span></span><br><span class="line">        marketMock = EasyMock.createMock(StockMarket.class);</span><br><span class="line">        <span class="comment">// 将模拟实例对象赋给股票列表</span></span><br><span class="line">        protfolio.setStockMarket(marketMock);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getTotalValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 用我们期望的返回值来配置模拟对象，当getPrice参数是EBAY时，返回的数值为42.00</span></span><br><span class="line">        EasyMock.expect(marketMock.getPrice(<span class="string">"EBAY"</span>)).andReturn(<span class="number">42.00</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 这个replay不要忘记，将mock进行重放，否则会IllegalStateException</span></span><br><span class="line">        <span class="comment">//异常和一个没有什么帮助的错误消息：</span></span><br><span class="line">        <span class="comment">//missing behavior definition for the preceding method call。</span></span><br><span class="line">        EasyMock.replay(marketMock);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 开始测试</span></span><br><span class="line">        Stock ebayStock = <span class="keyword">new</span> Stock(<span class="string">"EBAY"</span>, <span class="number">2</span>);</span><br><span class="line">        protfolio.addStock(ebayStock);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 这里使用的是org.junit下的断言，在4.12的javadoc中中已经没有没有junit.framework的</span></span><br><span class="line">        <span class="comment">// 内容了，但是为了兼容，4.12版本中还会对其进行保留</span></span><br><span class="line">        <span class="comment">// 在junit4中这个方法似乎被弃用了可以添加第三个参数代表误差</span></span><br><span class="line">        <span class="comment">// 弃用： assertEquals(84.00, protfolio.getTotalValue());</span></span><br><span class="line">        assertEquals(<span class="number">84.00</span>, protfolio.getTotalValue(), <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h2><ol><li>先 EasyMock.createMock(xxxx.class) 创建模拟接口返回的对象</li><li>然后就是正常使用接口的实例操作</li><li>配置模拟对象，在什么条件下做什么 EasyMock.expect(模拟的对象实例.xxx方法()).xxx返回的东西或者要做的事()</li><li>EasyMock.replay(实例对象)</li><li>开始正常逻辑测试。</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;引言： 本文采取的例子来自 &lt;a href=&quot;https://veerasundar.com/blog/2012/06/easymock-tutorial-getting-started/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;EasyMock t
      
    
    </summary>
    
      <category term="java" scheme="http://yoursite.com/categories/java/"/>
    
    
      <category term="Junit" scheme="http://yoursite.com/tags/Junit/"/>
    
      <category term="easyMock" scheme="http://yoursite.com/tags/easyMock/"/>
    
  </entry>
  
  <entry>
    <title>IDEA中dependencies和libraries的区别</title>
    <link href="http://yoursite.com/2018/04/09/dependencies-and-libraries/"/>
    <id>http://yoursite.com/2018/04/09/dependencies-and-libraries/</id>
    <published>2018-04-09T11:50:06.000Z</published>
    <updated>2018-04-09T12:13:55.871Z</updated>
    
    <content type="html"><![CDATA[<p>我觉得，idea中的dependencies和eclipse中的build path差不多，在eclipse中先将jar文件放入某个lib文件夹下然后add build path</p><pre><code>其实通过意思可以看出，dependencies是依赖，libraries是库，dependencies中添加jar包或者目录就是eclipse中的buildpath，libraries就是集中包的一个目录，用来集中批量管理包。（目前理解就是这些，有错求指正）</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;我觉得，idea中的dependencies和eclipse中的build path差不多，在eclipse中先将jar文件放入某个lib文件夹下然后add build path&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;其实通过意思可以看出，dependencies是依赖，libra
      
    
    </summary>
    
    
      <category term="随笔" scheme="http://yoursite.com/tags/%E9%9A%8F%E7%AC%94/"/>
    
      <category term="idea" scheme="http://yoursite.com/tags/idea/"/>
    
  </entry>
  
  <entry>
    <title>idea-webApp简单运行环境配置</title>
    <link href="http://yoursite.com/2018/04/08/idea-webApp-simple/"/>
    <id>http://yoursite.com/2018/04/08/idea-webApp-simple/</id>
    <published>2018-04-08T04:41:10.000Z</published>
    <updated>2018-04-09T12:03:15.858Z</updated>
    
    <content type="html"><![CDATA[<ol><li>首先在web下创建两个目录，分别为lib和classes，classe保存编译后的.class文件，lib保存需要的jar包。</li><li>打开project Setting, 选择modules，点击paths，把两个path路径改成第一步骤下的classes路径。</li><li>点击path旁边的dependencies进行Tomcat的添加，点击+选择Library，选择Tomcat进行添加。或者先在librarys添加相应的包，再去dependencies添加。</li><li>配置Tomcat文件，edit Configurations，点击+，选择Tomcat，local Tomcat，Server部分进行相关配置，然后对deployment点击+添加artifact，webxxxxx啥的。</li><li>运行下试试。</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ol&gt;
&lt;li&gt;首先在web下创建两个目录，分别为lib和classes，classe保存编译后的.class文件，lib保存需要的jar包。&lt;/li&gt;
&lt;li&gt;打开project Setting, 选择modules，点击paths，把两个path路径改成第一步骤下的clas
      
    
    </summary>
    
      <category term="java" scheme="http://yoursite.com/categories/java/"/>
    
    
      <category term="随笔" scheme="http://yoursite.com/tags/%E9%9A%8F%E7%AC%94/"/>
    
      <category term="idea" scheme="http://yoursite.com/tags/idea/"/>
    
      <category term="applet" scheme="http://yoursite.com/tags/applet/"/>
    
  </entry>
  
  <entry>
    <title>javaIO流的总结（更新中）</title>
    <link href="http://yoursite.com/2018/04/07/IO/javaIO-summary/"/>
    <id>http://yoursite.com/2018/04/07/IO/javaIO-summary/</id>
    <published>2018-04-07T14:11:28.000Z</published>
    <updated>2018-04-07T06:22:38.744Z</updated>
    
    <content type="html"><![CDATA[<p>引言：这里不会讲各种流的详细用法。</p><p><img src="/images/javaIO.png" alt="我的流结构"></p><blockquote><p>注意：original Stream（也称为节点流） 和 wrapper Stream（也称为处理流）未包装类和包装类。</p></blockquote><blockquote><p>java可分为输出流和输入流，根据流类型，可分为字符流和字节流，如下表：</p></blockquote><table><thead><tr><th style="text-align:center">分类</th><th style="text-align:center">字节流</th><th>字符流</th></tr></thead><tbody><tr><td style="text-align:center">输入流</td><td style="text-align:center">InputStream</td><td>Reader</td></tr><tr><td style="text-align:center">输出流</td><td style="text-align:center">OutputStream</td><td>Writer</td></tr></tbody></table><blockquote><p>实际使用中我们一般不会用到上面说的四类，而是使用继承它们的子类，不同的子类负责着不同的功能，以便于我开发不同的应用。<br>用途主要有以下几种：</p></blockquote><ul><li>文件访问</li><li>网络访问</li><li>内存缓存访问</li><li>线程内部通信</li><li>缓冲</li><li>过滤</li><li>解析</li><li>读写文本，基本数据类型，对象</li></ul><h3 id="Java-IO-类概述表"><a href="#Java-IO-类概述表" class="headerlink" title="Java IO 类概述表"></a>Java IO 类概述表</h3><p><img src="/images/IO.png" alt=""></p><blockquote><p>该表使用自并发编程网的<a href="http://ifeve.com/java-io-3/" target="_blank" rel="noopener">javaIO</a></p></blockquote><blockquote><p>各做基类流继承下去的分为两类，节点的流和处理流：<br>字节节点流只具有读取字节内容的方法，比如FileInputStream流和FileOutputStream流只能向文件中读取或者向文件中写入字节，对于各种类型的数据，如果是写入文件，必须转换成字节数组后写入文件，若是读取，那么就得转换成相应的类型。 而处理流，例如DataOutputStream提供了各种对象中写入类型的方法，方便编程人员。</p></blockquote><h2 id="1-字节流"><a href="#1-字节流" class="headerlink" title="1. 字节流"></a>1. 字节流</h2><h3 id="1-1-InputStream作为基类"><a href="#1-1-InputStream作为基类" class="headerlink" title="1.1 InputStream作为基类"></a>1.1 InputStream作为基类</h3><h4 id="1-1-1-ByteArrayInputStream"><a href="#1-1-1-ByteArrayInputStream" class="headerlink" title="1.1.1 ByteArrayInputStream"></a>1.1.1 ByteArrayInputStream</h4><blockquote><p>内部通过建立字节数组buf缓冲区来读取保存数据</p></blockquote><p>适用场景:<br>此流是内存操作流，这个流可实现类似内存虚拟文件的功能，将数据暂存在缓存区中，可以使程序不需要产生相应的临时文件，避免从存储介质上读取，提升效率。</p><p>注意:<br>此流没有提供close关闭流的操作，当没有对其的强引用时，就会自动被GC，但是也会导致内存溢出，可以使用org.apache.commons.io.IoUtiles关闭流</p><h4 id="1-1-2-FileInputStream"><a href="#1-1-2-FileInputStream" class="headerlink" title="1.1.2 FileInputStream"></a>1.1.2 FileInputStream</h4><blockquote><p>把一个文件作为文件输入流，实现对文件的读取操作，访问硬盘</p></blockquote><p>适用场景:<br>从名字上就能看出应用，对硬盘上的文件的存取</p><h4 id="1-1-3-SocketInputStream"><a href="#1-1-3-SocketInputStream" class="headerlink" title="1.1.3 SocketInputStream"></a>1.1.3 SocketInputStream</h4><blockquote><p>就和名字一样，适用于网络通信中。</p></blockquote><h4 id="1-1-4-PipeInputStream"><a href="#1-1-4-PipeInputStream" class="headerlink" title="1.1.4 PipeInputStream"></a>1.1.4 PipeInputStream</h4><blockquote><p>通多创建管道实现线程间的通信</p></blockquote><h4 id="1-1-5-BufferedInputStream"><a href="#1-1-5-BufferedInputStream" class="headerlink" title="1.1.5 BufferedInputStream"></a>1.1.5 BufferedInputStream</h4><blockquote><p>本质是通过一个内部缓冲数组实现的，默认大小8192，实现滑动读取的功能，事先把size大小的数据从磁盘中读取到缓冲区上，然后实际操作都在缓冲区中进行，如果数据超过缓冲区，那么将重新载入数据。减少了磁盘IO，提高了效率。</p></blockquote><p>用途：<br>因为其缓存的功能，可以起到改善效率的作用。通过源码可以看出，构造器的形参是InputStream，所以可以对其进行改善效率，包括FileInputStream等，比如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">BufferedInputStream bufferedInputStream = <span class="keyword">new</span> BufferedInputStream(<span class="keyword">new</span> FileInputStream(<span class="string">"zzz.txt"</span>));</span><br></pre></td></tr></table></figure><h4 id="1-1-6-DataInputStream"><a href="#1-1-6-DataInputStream" class="headerlink" title="1.1.6 DataInputStream"></a>1.1.6 DataInputStream</h4><blockquote><p>封装了对字节流的解析，实现了对基本数据类型的基本操作和对读取UTF格式的方法，当然，读取字符的还有Rread等相关的字符流。</p></blockquote><h4 id="1-1-7-PushbackInputStream"><a href="#1-1-7-PushbackInputStream" class="headerlink" title="1.1.7 PushbackInputStream"></a>1.1.7 PushbackInputStream</h4><blockquote><p>回推流，把从缓存区中读出来的数据再原路推回去，没有破坏输入流里的内容结构。</p></blockquote><p>注意：<br>PushbackInputStream对象会使得InputStream对象（用于创建PushbackInputStream对象）的mark()或reset()方法无效。对于准备使用mark()或reset()方法的任何流来说，都应当使用markSupported()方法进行检查。</p><h4 id="1-1-8-ObjectInputStream与ObjectOutputStream"><a href="#1-1-8-ObjectInputStream与ObjectOutputStream" class="headerlink" title="1.1.8 ObjectInputStream与ObjectOutputStream"></a>1.1.8 ObjectInputStream与ObjectOutputStream</h4><blockquote><p>ObjectOutputStream 将 Java 对象的基本数据类型和图形写入 OutputStream。可以使用 ObjectInputStream 读取（重构）对象。通过在流中使用文件可以实现对象的持久存储。如果流是网络套接字流，则可以在另一台主机上或另一个进程中重构对象。<br>只能将支持 java.io.Serializable 接口的对象写入流中。每个 serializable 对象的类都被编码，编码内容包括类名和类签名、对象的字段值和数组值，以及从初始对象中引用的其他所有对象的闭包。<br>writeObject 方法用于将对象写入流中。所有对象（包括 String 和数组）都可以通过 writeObject 写入。可将多个对象或基元写入流中。必须使用与写入对象时相同的类型和顺序从相应 ObjectInputstream 中读回对象。</p></blockquote><h4 id="1-1-9-SequenceInputStream"><a href="#1-1-9-SequenceInputStream" class="headerlink" title="1.1.9 SequenceInputStream"></a>1.1.9 SequenceInputStream</h4><blockquote><p>合并流，将多个源合并成一个源</p></blockquote><h3 id="1-2-OutputStream作为基类"><a href="#1-2-OutputStream作为基类" class="headerlink" title="1.2 OutputStream作为基类"></a>1.2 OutputStream作为基类</h3><h4 id="1-2-1-PrintStream"><a href="#1-2-1-PrintStream" class="headerlink" title="1.2.1 PrintStream"></a>1.2.1 PrintStream</h4><blockquote><p>PrintStream 是打印输出流，它继承于FilterOutputStream。<br>PrintStream 是用来装饰其它输出流。它能为其他输出流添加了功能，使它们能够方便地打印各种数据值表示形式。<br>与其他输出流不同，PrintStream 永远不会抛出 IOException；它产生的IOException会被自身的函数所捕获并设置错误标记， 用户可以通过 checkError() 返回错误标记，从而查看PrintStream内部是否产生了IOException。<br>另外，PrintStream 提供了自动flush 和 字符集设置功能。所谓自动flush，就是往PrintStream写入的数据会立刻调用flush()函数。</p></blockquote><h4 id="这里对比一下PrintStream和DataOutputStream（原文链接"><a href="#这里对比一下PrintStream和DataOutputStream（原文链接" class="headerlink" title="这里对比一下PrintStream和DataOutputStream（原文链接)"></a>这里对比一下PrintStream和DataOutputStream（<a href="https://www.cnblogs.com/skywang12345/p/io_16.html" target="_blank" rel="noopener">原文链接</a>)</h4><p>相同点：都是继承与FileOutputStream，用于包装其它输出流。<br>不同点：</p><p>(01) PrintStream和DataOutputStream 都可以将数据格式化输出；但它们在“输出字符串”时的编码不同。</p><blockquote><p>PrintStream是输出时采用的是用户指定的编码(创建PrintStream时指定的)，若没有指定，则采用系统默认的字符编码。而DataOutputStream则采用的是UTF-8。<br>关于UTF-8的字符编码可以参考“字符编码(ASCII，Unicode和UTF-8) 和 大小端”<br>关于DataOutputStream的更多内容，可以参考“java io系列15之 DataOutputStream(数据输出流)的认知、源码和示例”</p></blockquote><p>(02) 它们的写入数据时的异常处理机制不同。</p><blockquote><p>DataOutputStream在通过write()向“输出流”中写入数据时，若产生IOException，会抛出。<br>而PrintStream在通过write()向“输出流”中写入数据时，若产生IOException，则会在write()中进行捕获处理；并设置trouble标记(用于表示产生了异常)为true。用户可以通过checkError()返回trouble值，从而检查输出流中是否产生了异常。</p></blockquote><p>(03) 构造函数不同</p><blockquote><p>DataOutputStream的构造函数只有一个：DataOutputStream(OutputStream out)。即它只支持以输出流out作为“DataOutputStream的输出流”。<br>而PrintStream的构造函数有许多：和DataOutputStream一样，支持以输出流out作为“PrintStream输出流”的构造函数；还支持以“File对象”或者“String类型的文件名对象”的构造函数。<br>而且，在PrintStream的构造函数中，能“指定字符集”和“是否支持自动flush()操作”。</p></blockquote><p>(04) 目的不同</p><blockquote><p>DataOutputStream的作用是装饰其它的输出流，它和DataInputStream配合使用：允许应用程序以与机器无关的方式从底层输入流中读写java数据类型。<br>而PrintStream的作用虽然也是装饰其他输出流，但是它的目的不是以与机器无关的方式从底层读写java数据类型；而是为其它输出流提供打印各种数据值表示形式，使其它输出流能方便的通过print(), println()或printf()等输出各种格式的数据。</p></blockquote><h2 id="2-字符流"><a href="#2-字符流" class="headerlink" title="2. 字符流"></a>2. 字符流</h2><h3 id="2-1-Reader作为基类"><a href="#2-1-Reader作为基类" class="headerlink" title="2.1 Reader作为基类"></a>2.1 Reader作为基类</h3><h4 id="2-1-1-CharArrayReader"><a href="#2-1-1-CharArrayReader" class="headerlink" title="2.1.1 CharArrayReader"></a>2.1.1 CharArrayReader</h4><h4 id="2-1-2-InputStreamReader"><a href="#2-1-2-InputStreamReader" class="headerlink" title="2.1.2 InputStreamReader"></a>2.1.2 InputStreamReader</h4><h4 id="2-1-3-FileReader"><a href="#2-1-3-FileReader" class="headerlink" title="2.1.3 FileReader"></a>2.1.3 FileReader</h4><h4 id="2-1-4-PipedReader"><a href="#2-1-4-PipedReader" class="headerlink" title="2.1.4 PipedReader"></a>2.1.4 PipedReader</h4><h4 id="2-1-5-StringReader"><a href="#2-1-5-StringReader" class="headerlink" title="2.1.5 StringReader"></a>2.1.5 StringReader</h4><h4 id="2-1-6-BufferedReader"><a href="#2-1-6-BufferedReader" class="headerlink" title="2.1.6 BufferedReader"></a>2.1.6 BufferedReader</h4><h4 id="2-1-7-LinNumberReader"><a href="#2-1-7-LinNumberReader" class="headerlink" title="2.1.7 LinNumberReader"></a>2.1.7 LinNumberReader</h4><h4 id="2-1-8-PushBackReader"><a href="#2-1-8-PushBackReader" class="headerlink" title="2.1.8 PushBackReader"></a>2.1.8 PushBackReader</h4><h3 id="2-2-Writer作为基类"><a href="#2-2-Writer作为基类" class="headerlink" title="2.2 Writer作为基类"></a>2.2 Writer作为基类</h3><h4 id="2-2-1-PrintWriter"><a href="#2-2-1-PrintWriter" class="headerlink" title="2.2.1 PrintWriter"></a>2.2.1 PrintWriter</h4><h2 id="3-RandomAccessFile"><a href="#3-RandomAccessFile" class="headerlink" title="3. RandomAccessFile"></a>3. RandomAccessFile</h2><h2 id="4-字符和字节流的转换"><a href="#4-字符和字节流的转换" class="headerlink" title="4. 字符和字节流的转换"></a>4. 字符和字节流的转换</h2><h2 id="5-一般使用规则-输入和输出类似"><a href="#5-一般使用规则-输入和输出类似" class="headerlink" title="5.一般使用规则(输入和输出类似)"></a>5.一般使用规则(输入和输出类似)</h2><p>1.按数据来源分类：</p><ul><li>文件：FileInputStream, FileReader</li><li>byte[]: ByteArrayInputStream</li><li>char[]: CharArrayReader</li><li>String: StringBufferInputStream, StringReader</li><li>网络数据流: InputStream, Reader</li></ul><p>2.按是否格式化输出</p><ul><li>格式化输出： PrintStream, PrintWriter</li></ul><p>3.按是否要缓冲</p><ul><li>BufferedInputStream, BufferedReader</li></ul><p>4.按数据格式：</p><ul><li>字节流： InputStream和OutputStream以及它们的子类</li><li>字符流： Reader和Writer以及它们的子类</li></ul><p>5.按输入输出：</p><ul><li>不用写，都懂</li></ul><p>6.特别的：</p><ul><li>Stream到Reader和Writer的转换类： InputStreamReader和OutputStreamWriter</li><li>对象输入输出： ObjectStream, ObjectStream</li><li>进程通信： PipeInputStream, PipeReader</li><li>合并输入： SequenceInputStream</li><li>其它： PushbackInputStream, PushbackReader, LineNumberInputStream, LineNumberReader</li></ul><h2 id="6-构造准则"><a href="#6-构造准则" class="headerlink" title="6. 构造准则"></a>6. 构造准则</h2><pre><code>决定使用哪个类以及它的构造进程的一般准则如下（不考虑特殊需要）：首先，考虑最原始的数据格式是什么： 原则四第二，是输入还是输出：原则五第三，是否需要转换流：原则六第 1 点第四，数据来源（去向）是什么：原则一第五，是否要缓冲：原则三 （特别注明：一定要注意的是 readLine() 是否有定义，有什么比 read, write 更特殊的输入或输出方法）第六，是否要格式化输出：原则二</code></pre><p>借鉴<a href="http://yuanzhitofaraway.lofter.com/post/2b181d_aac8fcf" target="_blank" rel="noopener">远志，志在远方</a></p><p>【1】内存操作流： 用于处理临时存储的信息，程序结束，数据就从内存中消失。</p><ul><li>字节数组：</li><li>ByteArrayInputStream</li><li><p>ByteArrayOutputStream</p></li><li><p>字符数组：</p></li><li>CharArrayReader</li><li><p>CharArrayWriter</p></li><li><p>字符串：</p></li><li>StringReader</li><li>StringWriter</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;引言：这里不会讲各种流的详细用法。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/javaIO.png&quot; alt=&quot;我的流结构&quot;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;注意：original Stream（也称为节点流） 和 wrapper Stream（也称为处理
      
    
    </summary>
    
      <category term="java" scheme="http://yoursite.com/categories/java/"/>
    
    
      <category term="IO" scheme="http://yoursite.com/tags/IO/"/>
    
  </entry>
  
  <entry>
    <title>java中自动拆装箱的一些问题</title>
    <link href="http://yoursite.com/2018/04/05/auto-unpacking-packing/"/>
    <id>http://yoursite.com/2018/04/05/auto-unpacking-packing/</id>
    <published>2018-04-05T07:08:41.000Z</published>
    <updated>2018-04-10T06:43:20.320Z</updated>
    
    <content type="html"><![CDATA[<p>引言： 直接进入正题，我就当大家都知道什么是拆箱和装箱了，这里主要讨论的是不清楚原理导致产生一些奇怪问题的内容，想看详细介绍的跳到这边：<a href="http://www.cnblogs.com/dolphin0520/p/3780005.html" target="_blank" rel="noopener">深入剖析java中的装箱和拆箱</a>，这边感谢原作者对反编译class文件的解析，让我理解原理，下面会使用原作者的部分内容以及讲解一些原作者没解析的一些内容。</p><h2 id="1-拆箱和装箱时如何实现的"><a href="#1-拆箱和装箱时如何实现的" class="headerlink" title="1. 拆箱和装箱时如何实现的"></a>1. 拆箱和装箱时如何实现的</h2><blockquote><p>通过反编译的文件可以了解到（见下图），装箱时自动调用的是valueof()方法，而拆箱的时候自动调用的是xxxValue()方法。</p></blockquote><p><img src="/images/Integer.png" alt=""></p><h2 id="2-遇到的相关问题"><a href="#2-遇到的相关问题" class="headerlink" title="2. 遇到的相关问题"></a>2. 遇到的相关问题</h2><h3 id="2-1-看下面的代码"><a href="#2-1-看下面的代码" class="headerlink" title="2.1 看下面的代码"></a>2.1 看下面的代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">         </span><br><span class="line">        Integer i1 = <span class="number">100</span>;</span><br><span class="line">        Integer i2 = <span class="number">100</span>;</span><br><span class="line">        Integer i3 = <span class="number">200</span>;</span><br><span class="line">        Integer i4 = <span class="number">200</span>;</span><br><span class="line">         </span><br><span class="line">        System.out.println(i1==i2);</span><br><span class="line">        System.out.println(i3==i4);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><pre><code>结果是：truefalse</code></pre><blockquote><p>神奇吧，出乎意料，以前没有深入了解，有人提到后就去分析了源码，看看Integer valueOf的部分源码实现</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Integer.java</span><br><span class="line"></span><br><span class="line"><span class="meta">@HotSpotIntrinsicCandidate</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Integer <span class="title">valueOf</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)</span><br><span class="line">            <span class="keyword">return</span> IntegerCache.cache[i + (-IntegerCache.low)];</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Integer(i);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><blockquote><p>通过源码的实现可以看出，有IntegerCache类参与，其实是Integer的一个内部类，源码如下：</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">Integer.java</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">IntegerCache</span> </span>&#123;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> low = -<span class="number">128</span>;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> high;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> Integer cache[];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">static</span> &#123;</span><br><span class="line">            <span class="comment">// high value may be configured by property</span></span><br><span class="line">            <span class="keyword">int</span> h = <span class="number">127</span>;</span><br><span class="line">            String integerCacheHighPropValue =</span><br><span class="line">                VM.getSavedProperty(<span class="string">"java.lang.Integer.IntegerCache.high"</span>);</span><br><span class="line">            <span class="keyword">if</span> (integerCacheHighPropValue != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">int</span> i = parseInt(integerCacheHighPropValue);</span><br><span class="line">                    i = Math.max(i, <span class="number">127</span>);</span><br><span class="line">                    <span class="comment">// Maximum array size is Integer.MAX_VALUE</span></span><br><span class="line">                    h = Math.min(i, Integer.MAX_VALUE - (-low) -<span class="number">1</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span>( NumberFormatException nfe) &#123;</span><br><span class="line">                    <span class="comment">// If the property cannot be parsed into an int, ignore it.</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            high = h;</span><br><span class="line"></span><br><span class="line">            cache = <span class="keyword">new</span> Integer[(high - low) + <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">int</span> j = low;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; cache.length; k++)</span><br><span class="line">                cache[k] = <span class="keyword">new</span> Integer(j++);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// range [-128, 127] must be interned (JLS7 5.1.7)</span></span><br><span class="line">            <span class="keyword">assert</span> IntegerCache.high &gt;= <span class="number">127</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="title">IntegerCache</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><blockquote><p>通过源码可以看出，通过valueOf方法创建Integer对象，如果数值在-128到127之间(具体最大值还要看vm的配置)，直接返回IntegerCache中存在的引用，否则返回新的对象，就能解释true和false的问题了。</p></blockquote><h3 id="2-2-那么再来看一个问题"><a href="#2-2-那么再来看一个问题" class="headerlink" title="2.2 那么再来看一个问题"></a>2.2 那么再来看一个问题</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">         </span><br><span class="line">        Double i1 = <span class="number">100.0</span>;</span><br><span class="line">        Double i2 = <span class="number">100.0</span>;</span><br><span class="line">        Double i3 = <span class="number">200.0</span>;</span><br><span class="line">        Double i4 = <span class="number">200.0</span>;</span><br><span class="line">         </span><br><span class="line">        System.out.println(i1==i2);</span><br><span class="line">        System.out.println(i3==i4);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><pre><code>结果是：falsefalse</code></pre><blockquote><p>又错了吧，应该好好再看看源码的，可恶，没错Double类的valueOf源码的实现和Integet不一样，这里就不贴源码了，看的真心疼，大佬们的代码能力真的是很强。回到问题，源码中Double并没有像Integer那个有规定cache数组等相关的操作，大概我们能使用到double的地方的话代表精度很大，没必要吧，所以Double每次的装箱都是返回新的对象。</p></blockquote><p><code>总结下： Integer，Short，Byte，Character，Long这几个类的valueOf类似，Double，Float的类似</code></p><h3 id="2-3-这里原作者还提到了boolean变量，看例子"><a href="#2-3-这里原作者还提到了boolean变量，看例子" class="headerlink" title="2.3 这里原作者还提到了boolean变量，看例子"></a>2.3 这里原作者还提到了boolean变量，看例子</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">         </span><br><span class="line">        Boolean i1 = <span class="keyword">false</span>;</span><br><span class="line">        Boolean i2 = <span class="keyword">false</span>;</span><br><span class="line">        Boolean i3 = <span class="keyword">true</span>;</span><br><span class="line">        Boolean i4 = <span class="keyword">true</span>;</span><br><span class="line">         </span><br><span class="line">        System.out.println(i1==i2);</span><br><span class="line">        System.out.println(i3==i4);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 结果：</span></span><br><span class="line"><span class="keyword">true</span></span><br><span class="line"><span class="keyword">true</span></span><br></pre></td></tr></table></figure><blockquote><p>通过源码可以很直接的看出</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Boolean.java</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Boolean <span class="title">valueOf</span><span class="params">(<span class="keyword">boolean</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (b ? TRUE : FALSE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>emememem，很简单直观，看看True和False</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Boolean.java</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Boolean TRUE = <span class="keyword">new</span> Boolean(<span class="keyword">true</span>);</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Boolean FALSE = <span class="keyword">new</span> Boolean(<span class="keyword">false</span>);</span><br></pre></td></tr></table></figure><blockquote><p>可以看出，是类成员属性</p></blockquote><h3 id="2-4-Integer-i-new-Integer-xxx-和Integer-i-xxx-这两种方式的区别。（没错，这里copy原文）"><a href="#2-4-Integer-i-new-Integer-xxx-和Integer-i-xxx-这两种方式的区别。（没错，这里copy原文）" class="headerlink" title="2.4 Integer i = new Integer(xxx)和Integer i =xxx;这两种方式的区别。（没错，这里copy原文）"></a>2.4 Integer i = new Integer(xxx)和Integer i =xxx;这两种方式的区别。（没错，这里copy原文）</h3><p>当然，这个题目属于比较宽泛类型的。但是要点一定要答上，我总结一下主要有以下这两点区别：</p><ol><li>第一种方式不会触发自动装箱的过程；而第二种方式会触发；</li><li>在执行效率和资源占用上的区别。第二种方式的执行效率和资源占用在一般性情况下要优于第一种情况（注意这并不是绝对的）。</li></ol><h3 id="2-5-看下面完整的例子"><a href="#2-5-看下面完整的例子" class="headerlink" title="2.5 看下面完整的例子"></a>2.5 看下面完整的例子</h3><p>这里就当做读者都了解 == 和 equals 的区别了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 引用原作者的例子强行解释</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">         </span><br><span class="line">        Integer a = <span class="number">1</span>;</span><br><span class="line">        Integer b = <span class="number">2</span>;</span><br><span class="line">        Integer c = <span class="number">3</span>;</span><br><span class="line">        Integer d = <span class="number">3</span>;</span><br><span class="line">        Integer e = <span class="number">321</span>;</span><br><span class="line">        Integer f = <span class="number">321</span>;</span><br><span class="line">        Long g = <span class="number">3L</span>;</span><br><span class="line">        Long h = <span class="number">2L</span>;</span><br><span class="line">         </span><br><span class="line">        System.out.println(c==d);          <span class="comment">//1.true </span></span><br><span class="line">        System.out.println(e==f);          <span class="comment">//2.false</span></span><br><span class="line">        System.out.println(c==(a+b));      <span class="comment">//3.true</span></span><br><span class="line">        System.out.println(c.equals(a+b)); <span class="comment">//4.true</span></span><br><span class="line">        System.out.println(g==(a+b));      <span class="comment">//5.true</span></span><br><span class="line">        System.out.println(g.equals(a+b)); <span class="comment">//6.false</span></span><br><span class="line">        System.out.println(g.equals(a+h)); <span class="comment">//7.true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>这里挑几点讲解</p><ol><li>第3点，1+2触发自动拆箱，和c比较的是数值是否相等</li><li>第4点，a+b先触发拆箱求和后再触发装箱，调用valueOf方法</li><li>这里对比第6点和第7点：a+b通过拆装箱最后还是Integer类型，g调用的是Long类型的equals，看下面的源码，先比较的是类型，由于类型不对，所以false；这里看看第7点，h是long类型，所以a+b会隐式转换成long的类型，与g类型相同。</li></ol></blockquote><p>相关类型的的equals源码<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Integer.java</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> Integer) &#123;</span><br><span class="line">            <span class="keyword">return</span> value == ((Integer)obj).intValue();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">Long.java</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> Long) &#123;</span><br><span class="line">            <span class="keyword">return</span> value == ((Long)obj).longValue();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;引言： 直接进入正题，我就当大家都知道什么是拆箱和装箱了，这里主要讨论的是不清楚原理导致产生一些奇怪问题的内容，想看详细介绍的跳到这边：&lt;a href=&quot;http://www.cnblogs.com/dolphin0520/p/3780005.html&quot; target=&quot;_
      
    
    </summary>
    
      <category term="java" scheme="http://yoursite.com/categories/java/"/>
    
    
      <category term="随笔" scheme="http://yoursite.com/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>关于java.lang.UnsupportedOperationException异常</title>
    <link href="http://yoursite.com/2018/04/05/asListException/"/>
    <id>http://yoursite.com/2018/04/05/asListException/</id>
    <published>2018-04-05T03:37:56.000Z</published>
    <updated>2018-04-05T07:01:37.834Z</updated>
    
    <content type="html"><![CDATA[<p>引言： 这里感谢我们的组长提出这个问题，然后我去查看源码后发现了导致这个问题的原因。</p><h2 id="1-是什么，原因"><a href="#1-是什么，原因" class="headerlink" title="1. 是什么，原因"></a>1. 是什么，原因</h2><p>在调用Arrays类的aslist函数把数组转换成List集合不能对其进行添加删除等操作，否则抛出UnsupportedOperationException的异常，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">zzz.java</span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">zzz</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Integer[] arr = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line">        List&lt;Integer&gt; list = Arrays.asList(arr);</span><br><span class="line">        list.add(<span class="number">3</span>);  <span class="comment">//error</span></span><br><span class="line">        list.remove(<span class="number">2</span>);  <span class="comment">//error</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行代码将抛出一下错误：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Exception in thread <span class="string">"main"</span> java.lang.UnsupportedOperationException</span><br><span class="line">at java.base/java.util.AbstractList.add(AbstractList.java:<span class="number">153</span>)</span><br><span class="line">at java.base/java.util.AbstractList.add(AbstractList.java:<span class="number">111</span>)</span><br><span class="line">at Test.zzz.main(zzz.java:<span class="number">10</span>)</span><br></pre></td></tr></table></figure><p>根据字面意思，unsupportedOperationException就是对该实例不支持相应的函数操作。</p><blockquote><p>也许有人问，list接口明明提供相应的接口，并且ArrayList明明实现了add等操作函数，为什么不支持。问题就在这，aslist返回的ArrayList实例并不是我们之前学的Arraylist的实例，而是Arrays类的静态内部类的实例，看源码</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Arrays.java</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">List&lt;T&gt; <span class="title">asList</span><span class="params">(T... a)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;&gt;(a);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><blockquote><p>asList的源码，跟踪ArrayList的创建方法，继续看源码。只需要注意继承和实现类和接口还有实现的相关函数，直接跳到解析部分：</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br></pre></td><td class="code"><pre><span class="line">Arrays.java</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@serial</span> include</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayList</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractList</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">RandomAccess</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span></span></span><br><span class="line"><span class="class">    </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">2764017481108945198L</span>;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> E[] a;</span><br><span class="line"></span><br><span class="line">        ArrayList(E[] array) &#123;</span><br><span class="line">            a = Objects.requireNonNull(array);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> a.length;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> Object[] toArray() &#123;</span><br><span class="line">            <span class="keyword">return</span> Arrays.copyOf(a, a.length, Object[].class);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">        <span class="keyword">public</span> &lt;T&gt; T[] toArray(T[] a) &#123;</span><br><span class="line">            <span class="keyword">int</span> size = size();</span><br><span class="line">            <span class="keyword">if</span> (a.length &lt; size)</span><br><span class="line">                <span class="keyword">return</span> Arrays.copyOf(<span class="keyword">this</span>.a, size,</span><br><span class="line">                                     (Class&lt;? extends T[]&gt;) a.getClass());</span><br><span class="line">            System.arraycopy(<span class="keyword">this</span>.a, <span class="number">0</span>, a, <span class="number">0</span>, size);</span><br><span class="line">            <span class="keyword">if</span> (a.length &gt; size)</span><br><span class="line">                a[size] = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">return</span> a;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> a[index];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> E <span class="title">set</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</span><br><span class="line">            E oldValue = a[index];</span><br><span class="line">            a[index] = element;</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">            E[] a = <span class="keyword">this</span>.a;</span><br><span class="line">            <span class="keyword">if</span> (o == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a.length; i++)</span><br><span class="line">                    <span class="keyword">if</span> (a[i] == <span class="keyword">null</span>)</span><br><span class="line">                        <span class="keyword">return</span> i;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a.length; i++)</span><br><span class="line">                    <span class="keyword">if</span> (o.equals(a[i]))</span><br><span class="line">                        <span class="keyword">return</span> i;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> indexOf(o) &gt;= <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Spliterator&lt;E&gt; <span class="title">spliterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> Spliterators.spliterator(a, Spliterator.ORDERED);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">forEach</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> E&gt; action)</span> </span>&#123;</span><br><span class="line">            Objects.requireNonNull(action);</span><br><span class="line">            <span class="keyword">for</span> (E e : a) &#123;</span><br><span class="line">                action.accept(e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">replaceAll</span><span class="params">(UnaryOperator&lt;E&gt; operator)</span> </span>&#123;</span><br><span class="line">            Objects.requireNonNull(operator);</span><br><span class="line">            E[] a = <span class="keyword">this</span>.a;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a.length; i++) &#123;</span><br><span class="line">                a[i] = operator.apply(a[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Comparator&lt;? <span class="keyword">super</span> E&gt; c)</span> </span>&#123;</span><br><span class="line">            Arrays.sort(a, c);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Iterator&lt;E&gt; <span class="title">iterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ArrayItr&lt;&gt;(a);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayItr</span>&lt;<span class="title">E</span>&gt; <span class="keyword">implements</span> <span class="title">Iterator</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> cursor;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> E[] a;</span><br><span class="line"></span><br><span class="line">        ArrayItr(E[] a) &#123;</span><br><span class="line">            <span class="keyword">this</span>.a = a;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> cursor &lt; a.length;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> E <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">int</span> i = cursor;</span><br><span class="line">            <span class="keyword">if</span> (i &gt;= a.length) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">            &#125;</span><br><span class="line">            cursor = i + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">return</span> a[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><blockquote><p>调用的是Arrays.java内部类的构造方法ArrayList，然而这个静态内部类并没有实现add等相关的方法，怀着好奇心，继续研究源码，发现这个内部类并没有直接实现List接口，而是通过继承AbstractList<e>来间接实现List接口，我们来看看AbstractList的add和remove源码部分：</e></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">AbstractList.java</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><blockquote><p>真相大白有没有，Arrays的静态内部类ArrayList并没有改写从AbstractList继承的源码，那么调用add和remove等相关函数时，就会调用AbstractList实现的相关方法，然而内容只有抛出异常，没有其它相关的实现操作。</p></blockquote><h2 id="2-那么如何操作转换呢"><a href="#2-那么如何操作转换呢" class="headerlink" title="2. 那么如何操作转换呢"></a>2. 那么如何操作转换呢</h2><p>我这里知道的有两种，欢迎━(<em>｀∀´</em>)ノ亻!补充</p><ol><li>使用Iterator迭代器，迭代访问赋值</li><li>直接使用new ArrayList(Collection&lt;? extends E&gt; c)构造方法，这里注意，ArrayList并没有提供集合以外的参数构造，所以一开始的Integer类型的数组老老实实的迭代添加吧(偷笑), 为什么迭代器，而不是for， get来，效率问题，谷歌去。</li></ol><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>asList调用的是Arrays.java的静态内部类的构造方法，然而那个方法并没有实现add等相关修改数量大小的方法，也许这就是他们想要的目的，但是内容还是能通过set修改。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;引言： 这里感谢我们的组长提出这个问题，然后我去查看源码后发现了导致这个问题的原因。&lt;/p&gt;
&lt;h2 id=&quot;1-是什么，原因&quot;&gt;&lt;a href=&quot;#1-是什么，原因&quot; class=&quot;headerlink&quot; title=&quot;1. 是什么，原因&quot;&gt;&lt;/a&gt;1. 是什么，原因&lt;/
      
    
    </summary>
    
      <category term="java" scheme="http://yoursite.com/categories/java/"/>
    
    
      <category term="随笔" scheme="http://yoursite.com/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>getResourceAsStream和getSystemResourceAsStream等获取配置文件的路径表示</title>
    <link href="http://yoursite.com/2018/03/25/pro-path/"/>
    <id>http://yoursite.com/2018/03/25/pro-path/</id>
    <published>2018-03-24T16:16:26.000Z</published>
    <updated>2018-03-24T16:58:33.578Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/properties.png" alt="我的项目包结构"></p><blockquote><p>解释下：包名下都有对应一样的配置文件名，方便确定配置文件的位置，测试类也一样，应该能马上看得出</p></blockquote><h2 id="1-相对路径"><a href="#1-相对路径" class="headerlink" title="1.相对路径"></a>1.相对路径</h2><p>根据我前面proper的几种读取方式中，只有<code>ClassName.class.getResourceAsStream</code>使用的才是相对路径。</p><table><thead><tr><th style="text-align:center">配置文件.properties</th><th style="text-align:right">path</th></tr></thead><tbody><tr><td style="text-align:center">kkk</td><td style="text-align:right">kkk/kkk.properties</td></tr><tr><td style="text-align:center">zzz</td><td style="text-align:right"><code>../../zzz/zzz.properties</code></td></tr><tr><td style="text-align:center">src</td><td style="text-align:right"><code>../../src.properties</code></td></tr></tbody></table><pre><code>1. kkk文件在与TestProperUtil同目录下的目录kkk下所以是kkk/文件2. zzz 文件是在Testxxx上上级也就是src目录下的zzz目录中，其中..是上一级目录的意思3. src是上上级目录下的文件</code></pre><hr><h2 id="2-src下的绝对路径，不包括src的使用方式有三种："><a href="#2-src下的绝对路径，不包括src的使用方式有三种：" class="headerlink" title="2. src下的绝对路径，不包括src的使用方式有三种："></a>2. src下的绝对路径，不包括src的使用方式有三种：</h2><ol><li><code>ClassLoadergetSystemResourceAsStream</code></li><li><code>ClassName.class.getClassLoader().getResourceAsStream</code></li><li><code>ResourceBundle.getBundle</code><blockquote><p>注意：getBundle那个路径文件不加后缀名</p></blockquote></li></ol><table><thead><tr><th style="text-align:center">配置文件.properties</th><th style="text-align:right">path</th></tr></thead><tbody><tr><td style="text-align:center">kkk</td><td style="text-align:right">properties/test/kkk/kkk.properties</td></tr><tr><td style="text-align:center">zzz</td><td style="text-align:right">zzz/zzz.properties</td></tr><tr><td style="text-align:center">prop</td><td style="text-align:right">properties/prop.properties</td></tr></tbody></table><pre><code>1. kkk在src目录下的properties中的test目录的kkk目录下，所以path是properties/test/kkk/kkk.properties2. zzz 同理</code></pre><h2 id="3-关于boot配置文件"><a href="#3-关于boot配置文件" class="headerlink" title="3.关于boot配置文件"></a>3.关于boot配置文件</h2><p>不知道怎么取得其配置，或者就取不到，希望有人告知，待更新</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;/images/properties.png&quot; alt=&quot;我的项目包结构&quot;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;解释下：包名下都有对应一样的配置文件名，方便确定配置文件的位置，测试类也一样，应该能马上看得出&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h
      
    
    </summary>
    
      <category term="java" scheme="http://yoursite.com/categories/java/"/>
    
    
      <category term="properties" scheme="http://yoursite.com/tags/properties/"/>
    
  </entry>
  
  <entry>
    <title>加载properties配置文件的六种方式</title>
    <link href="http://yoursite.com/2018/03/23/sixWayLoadProperties/"/>
    <id>http://yoursite.com/2018/03/23/sixWayLoadProperties/</id>
    <published>2018-03-23T15:13:20.000Z</published>
    <updated>2018-04-10T06:36:26.548Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-是什么？"><a href="#1-是什么？" class="headerlink" title="1.是什么？"></a>1.是什么？</h2><h3 id="1-1定义"><a href="#1-1定义" class="headerlink" title="1.1定义"></a>1.1定义</h3><p>.properties是一种主要在java相关技术中用来存储应用程序的可配置参数的文件的文件扩展名。也可以存储用于国际化和本地化的字符串，这种文件被称为属性资源包。</p><h3 id="1-2内容与格式"><a href="#1-2内容与格式" class="headerlink" title="1.2内容与格式"></a>1.2内容与格式</h3><ol><li>简单来说是类似map的键-值对存储方式，类型都是String字符串。</li><li>语法有以下几种：<ul><li>以#和！号作为一行中的第一个字符表示注释</li><li>反斜杠(\)用于转义</li><li>键=值表示</li></ul></li></ol><h2 id="2-适用场合？优缺点，有无可替代对比？"><a href="#2-适用场合？优缺点，有无可替代对比？" class="headerlink" title="2.适用场合？优缺点，有无可替代对比？"></a>2.适用场合？优缺点，有无可替代对比？</h2><blockquote><p>java下常见的几种配置文件格式(在下资历少，只说三种)，其排序。<br>适合人类编写：properties &gt; yaml &gt; xml<br>可以存储数据的复杂度： xml &gt; yaml &gt; properties</p></blockquote><ol><li>.properties的优点怕是只有简单这一说法了，缺点就是因为其简单，所以不支持层级关系，而且其文件的编码是ISO-8859-1，又称Latin-1，导致没法加载中文。</li><li>xml: 从排序来看，xml是层次结构的，存储内容复杂，但是就拥有了强大的表达能力。缺点分析起来复杂，对人类不太友好，不易阅读，所以一般不是用来让人写的，而是机器间的自我生成和解析，比如javafx图形界面生成的xml文档。</li><li>yaml：替代xml。<blockquote><p><code>比xml好的地方有</code>：</p><ul><li>yaml可读性好</li><li>yaml和脚本语言的交互性好</li><li>yaml的语法和高级语言类似，进行简单表达</li><li>yaml有一个一致性的类型信息模型</li><li>yaml易于实现<br><code>yaml与xml相同的</code>：</li><li>yaml可以基于流来处理；</li><li>yaml表达能力强，存储的数据复杂度也高。</li></ul></blockquote></li></ol><h3 id="综上所述："><a href="#综上所述：" class="headerlink" title="综上所述："></a>综上所述：</h3><p><strong>YAML 是以数据为设计语言的重点的，而不是像 XML 以标记为重点。实事上，正是因为这样一种设计理念使得 YAML 在后来的不少应用中取代XML，成为一种可读性高，易于表达数据序列的编程语言。YAML 和 XML也许只是有其不同的应用场景和使用范围。公认的是，yaml凭借易读性成为xml的对手。</strong></p><blockquote><p>properties可以用于简单的几乎不会变动的配置，如果是一些要经常改动的业务就可以使用yaml类配置</p></blockquote><h2 id="3-怎么用？"><a href="#3-怎么用？" class="headerlink" title="3.怎么用？"></a>3.怎么用？</h2><p><strong>下文的配置文件路径的具体表示点击</strong><a href="/2018/03/25/pro-path/index.html">跳转链接</a></p><p><img src="/images/properties.png" alt="这是我的项目结构"><br>先声明下全局变量<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> String basePath = <span class="string">"src/properties/prop.properties"</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> String name = <span class="string">""</span>;</span><br></pre></td></tr></table></figure></p><h3 id="3-1"><a href="#3-1" class="headerlink" title="3.1"></a>3.1</h3><p>使用java.util.Properties类的load(InputStream)方法加载properties文件</p><blockquote><p>注意：这里的basepath是src目录开始的路径</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getPath</span><span class="params">()</span></span>&#123;</span><br><span class="line">     <span class="keyword">try</span> (InputStream in = <span class="keyword">new</span> BufferedInputStream(<span class="keyword">new</span> FileInputStream(</span><br><span class="line">             <span class="keyword">new</span> File(basePath))))&#123;</span><br><span class="line">         Properties pro = <span class="keyword">new</span> Properties();</span><br><span class="line">         pro.load(in);</span><br><span class="line">         name = pro.getProperty(<span class="string">"name"</span>);</span><br><span class="line"></span><br><span class="line">     &#125; <span class="keyword">catch</span> (FileNotFoundException e)&#123;</span><br><span class="line">         e.printStackTrace();</span><br><span class="line">     &#125; <span class="keyword">catch</span> (IOException e)&#123;</span><br><span class="line">         e.printStackTrace();</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span>  name;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h3 id="3-2"><a href="#3-2" class="headerlink" title="3.2"></a>3.2</h3><p>使用java.util.ResourceBundle类的getBudle()方法</p><blockquote><p>注意：这个getBundle()方法的参数只能写成包路径+properties文件名，否则将抛异常,并且路径是使用用src下的包名(不包括src)+文件名的方式 </p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getPath</span><span class="params">()</span></span>&#123;</span><br><span class="line">     ResourceBundle rb = ResourceBundle.getBundle(<span class="string">"properties/test/kkk/kkk"</span>);</span><br><span class="line">     name = rb.getString(<span class="string">"name"</span>);</span><br><span class="line">     <span class="keyword">return</span> name;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h3 id="3-3"><a href="#3-3" class="headerlink" title="3.3"></a>3.3</h3><p>使用java.util.PropertyResourceBudle类的构造函数<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getPath</span><span class="params">()</span></span>&#123;</span><br><span class="line">     <span class="keyword">try</span> (InputStream in = <span class="keyword">new</span> BufferedInputStream(<span class="keyword">new</span> FileInputStream(basePath))) &#123;</span><br><span class="line">         ResourceBundle rb = <span class="keyword">new</span> PropertyResourceBundle(in);</span><br><span class="line">         name = rb.getString(<span class="string">"name"</span>);</span><br><span class="line">     &#125; <span class="keyword">catch</span> (FileNotFoundException e)&#123;</span><br><span class="line">         e.printStackTrace();</span><br><span class="line">     &#125; <span class="keyword">catch</span> (IOException e)&#123;</span><br><span class="line">         e.printStackTrace();</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> name;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p><h3 id="3-4"><a href="#3-4" class="headerlink" title="3.4"></a>3.4</h3><p>使用class变量的getResourceAsStream()方法注意：getResourceAsStream()方法的参数按格式写到包路径+properties文件名+.后缀</p><blockquote><p>注意：路径使用的是相对路径</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getPath</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">     Properties p = <span class="keyword">new</span> Properties();</span><br><span class="line">     <span class="keyword">try</span> (InputStream in = TestProperUtil.class</span><br><span class="line">             .getResourceAsStream(<span class="string">"../../src.properties"</span>))&#123;</span><br><span class="line">         p.load(in);</span><br><span class="line">         name = p.getProperty(<span class="string">"name"</span>);</span><br><span class="line">     &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">         e.printStackTrace();</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> name;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h3 id="3-5"><a href="#3-5" class="headerlink" title="3.5"></a>3.5</h3><p>使用class.getClassLoader()所得到的java.lang.ClassLoader的getResourceAsStream()方法getResourceAsStream(name)方法的参数必须是包路径+文件名+.后缀否则会报空指针异常</p><blockquote><p>路径名和3.2一样</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getPath</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     <span class="keyword">try</span> (InputStream in = TestProperUtil.class.getClassLoader()</span><br><span class="line">             .getResourceAsStream(<span class="string">"zzz/zzz.properties"</span>))&#123;</span><br><span class="line">         Properties p = <span class="keyword">new</span> Properties();</span><br><span class="line">         p.load(in);</span><br><span class="line">         name = p.getProperty(<span class="string">"name"</span>);</span><br><span class="line">     &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">         e.printStackTrace();</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> name;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h3 id="3-6"><a href="#3-6" class="headerlink" title="3.6"></a>3.6</h3><p>使用java.lang.ClassLoader类的getSystemResourceAsStream()静态方法getSystemResourceAsStream()方法的参数格式也是有固定要求的</p><blockquote><p>注意： 路径名和3.2一样的表示</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getPath</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     <span class="keyword">try</span> (InputStream in = ClassLoader</span><br><span class="line">             .getSystemResourceAsStream(<span class="string">"src.properties"</span>))&#123;</span><br><span class="line">         Properties pro = <span class="keyword">new</span> Properties();</span><br><span class="line">         pro.load(in);</span><br><span class="line">         name = pro.getProperty(<span class="string">"name"</span>);</span><br><span class="line">     &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">         e.printStackTrace();</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> name;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;1-是什么？&quot;&gt;&lt;a href=&quot;#1-是什么？&quot; class=&quot;headerlink&quot; title=&quot;1.是什么？&quot;&gt;&lt;/a&gt;1.是什么？&lt;/h2&gt;&lt;h3 id=&quot;1-1定义&quot;&gt;&lt;a href=&quot;#1-1定义&quot; class=&quot;headerlink&quot; title=
      
    
    </summary>
    
      <category term="java" scheme="http://yoursite.com/categories/java/"/>
    
    
      <category term="配置文件" scheme="http://yoursite.com/tags/%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>HexoMarkdown</title>
    <link href="http://yoursite.com/2018/03/22/WriteTest/"/>
    <id>http://yoursite.com/2018/03/22/WriteTest/</id>
    <published>2018-03-22T15:17:08.000Z</published>
    <updated>2018-03-24T02:19:54.331Z</updated>
    
    <content type="html"><![CDATA[<h2 id="引言：HexoMd-的语法，基本够用，欢迎补充-能用得到的-与修正，部分细节有待修改（基于主题BlueLake"><a href="#引言：HexoMd-的语法，基本够用，欢迎补充-能用得到的-与修正，部分细节有待修改（基于主题BlueLake" class="headerlink" title="引言：HexoMd 的语法，基本够用，欢迎补充(能用得到的)与修正，部分细节有待修改（基于主题BlueLake)"></a>引言：HexoMd 的语法，基本够用，欢迎补充(能用得到的)与修正，部分细节有待修改（基于主题BlueLake)</h2><p>Markdown 语法版本很多，不同地方部分语法不相兼容，导致网上部分语法不能再hexo上使用，以下是整理的能在hexo的部分语法。</p><hr><h2 id="1-Tab"><a href="#1-Tab" class="headerlink" title="1.Tab"></a>1.Tab</h2><pre><code>字前tab会加灰框</code></pre><h2 id="2-的用法"><a href="#2-的用法" class="headerlink" title="2.#的用法"></a>2.#的用法</h2><pre><code>用来表示几级标题# frist title## second title### third title</code></pre><h2 id="3-超链接"><a href="#3-超链接" class="headerlink" title="3.超链接"></a>3.超链接</h2><h3 id="3-1显示链接的图片"><a href="#3-1显示链接的图片" class="headerlink" title="3.1显示链接的图片"></a>3.1显示链接的图片</h3><pre><code>![name](url) 显示链接的图片![this is page](/images/keduoli.jpg)</code></pre><p>link:<br><img src="/images/keduoli.jpg" alt="this is page"></p><h3 id="3-2文字超链接"><a href="#3-2文字超链接" class="headerlink" title="3.2文字超链接"></a>3.2文字超链接</h3><pre><code>[name](url) 文字超链接[bilibili](https://www.bilibili.com/)</code></pre><p><a href="https://www.bilibili.com/" target="_blank" rel="noopener">bilibili</a></p><h3 id="3-3图片超链接"><a href="#3-3图片超链接" class="headerlink" title="3.3图片超链接"></a>3.3图片超链接</h3><pre><code>[![xxx](图片url)][要转移到的链接]图片超链接[![enene](/images/keduoli.jpg)](https://nodesource.com/products/nsolid)</code></pre><p><a href="https://nodesource.com/products/nsolid" target="_blank" rel="noopener"><img src="/images/keduoli.jpg" alt="enene"></a></p><h2 id="4-列表"><a href="#4-列表" class="headerlink" title="4.列表"></a>4.列表</h2><h3 id="4-1-1无序列表-，-，-，-两格缩进，列表与前一行的"><a href="#4-1-1无序列表-，-，-，-两格缩进，列表与前一行的" class="headerlink" title="4.1.1无序列表 -，*，+， 两格缩进，列表与前一行的"></a>4.1.1无序列表 -，*，+， 两格缩进，列表与前一行的</h3><pre><code>hello:      - one      - two      - three</code></pre><p>eg:</p><p>hello (没有衔接一起很神奇）</p><ul><li>one</li><li>two</li><li>three</li></ul><p>food</p><ul><li>bread<ul><li>apple<ul><li>pig<ul><li>ddd<ul><li>mmm</li></ul></li></ul></li></ul></li></ul></li></ul><h3 id="4-1-2两格缩进-（衔接在一起了）"><a href="#4-1-2两格缩进-（衔接在一起了）" class="headerlink" title="4.1.2两格缩进  （衔接在一起了）"></a>4.1.2两格缩进  （衔接在一起了）</h3><ol><li>登录微博开放平台，选择。</li><li>为了与注意风格统一，如下配置</li><li>嗯嗯嗯          （也衔接一起了）</li></ol><ul><li>基础设置： dsfs<ul><li>样式设置： sdfa</li><li>模块设置： dsfa</li></ul></li></ul><hr><h3 id="4-2有序列表-序号-xxx-注意有空格）"><a href="#4-2有序列表-序号-xxx-注意有空格）" class="headerlink" title="4.2有序列表 序号. xxx(注意有空格）"></a>4.2有序列表 序号. xxx(注意有空格）</h3><ol><li>登录微博开放平台，选择。</li><li>为了与注意风格统一，如下配置</li><li>嗯嗯嗯 </li></ol><h2 id="5-用键代替链接，键值对匹配"><a href="#5-用键代替链接，键值对匹配" class="headerlink" title="5.用键代替链接，键值对匹配"></a>5.用键代替链接，键值对匹配</h2><pre><code>关键字对上跳转的意思吧，[内容]和文章最后的[内容1](链接)对上可以变成超链接，前后内容忽略大小写，也能匹配。这里注意最后一个，如果最后几个字也要跳转，单单加[1]没用得再加[2]来达到目的，此时内容为1，但是跳转到的目的为2Markdown is a lightweight markup language based on theformatting conventions that people naturally use in email.  As [John Gruber] writes on the [Markdown site]</code></pre><p>Markdown is a lightweight markup language based on the formatting conventions that people naturally use in email.As <a href="http://daringfireball.net" target="_blank" rel="noopener">John Gruber</a> writes on the <a href="https://github.com/joemccann/dillinger" target="_blank" rel="noopener">Markdown site</a></p><h2 id="6-可以用来注意，引用-可以多层"><a href="#6-可以用来注意，引用-可以多层" class="headerlink" title="6.可以用来注意，引用,可以多层"></a>6.可以用来注意，引用,可以多层</h2><pre><code>&gt; The overriding design goal for Markdown&apos;s&gt;&gt; formatting syntax is to make it as readable&gt; as possible. The idea is that.</code></pre><p>eg:</p><blockquote><p>The overriding design goal for Markdown’s</p><blockquote><p>formatting syntax is to make it as readable<br>as possible. The idea is that.</p></blockquote></blockquote><h2 id="7-代码块"><a href="#7-代码块" class="headerlink" title="7.代码块"></a>7.代码块</h2><pre><code>代码表示<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> dillinger</span><br><span class="line">$ npm install -d</span><br><span class="line">$ node app</span><br></pre></td></tr></table></figure></code></pre><p>eg:<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> dillinger</span><br><span class="line">$ npm install -d</span><br><span class="line">$ node app</span><br></pre></td></tr></table></figure></p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="keyword">String</span>[] args)&#123;</span><br><span class="line">    System.out.<span class="built_in">println</span>(<span class="string">"I think it's good"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="8-表格"><a href="#8-表格" class="headerlink" title="8.表格"></a>8.表格</h2><pre><code>制表第一行和第二行列必须对应数量相等| Plugin | README | sdflj || ------ | ：------： | -----： |  右对齐，居中，左对齐| Dropbox | [plugins/dropbox/README.md][PlDb] | dsf || Github | [plugins/github/README.md][PlGh] | sdf || Google Drive | [plugins/googledrive/README.md][PlGd] | dsfs || OneDrive | [plugins/onedrive/README.md][PlOd] | dsfj || Medium | [plugins/medium/README.md][PlMe] || Google Analytics | [plugins/googleanalytics/README.md][PlGa] |</code></pre><p>eg:</p><table><thead><tr><th>Plugin</th><th>README</th><th>sdflj</th></tr></thead><tbody><tr><td>Dropbox</td><td><a href="https://github.com/joemccann/dillinger/tree/master/plugins/dropbox/README.md" target="_blank" rel="noopener">plugins/dropbox/README.md</a></td><td>dsf</td></tr><tr><td>Github</td><td><a href="https://github.com/joemccann/dillinger/tree/master/plugins/github/README.md" target="_blank" rel="noopener">plugins/github/README.md</a></td><td>sdf</td></tr><tr><td>Google Drive</td><td><a href="https://github.com/joemccann/dillinger/tree/master/plugins/googledrive/README.md" target="_blank" rel="noopener">plugins/googledrive/README.md</a></td><td>dsfs</td></tr><tr><td>OneDrive</td><td><a href="https://github.com/joemccann/dillinger/tree/master/plugins/onedrive/README.md" target="_blank" rel="noopener">plugins/onedrive/README.md</a></td><td>dsfj</td></tr><tr><td>Medium</td><td><a href="https://github.com/joemccann/dillinger/tree/master/plugins/medium/README.md" target="_blank" rel="noopener">plugins/medium/README.md</a></td><td>df</td></tr><tr><td>Google Analytics</td><td><a href="https://github.com/RahulHP/dillinger/blob/master/plugins/googleanalytics/README.md" target="_blank" rel="noopener">plugins/googleanalytics/README.md</a></td><td>dsdg</td></tr></tbody></table><p>eg：<br>This will create the dillinger image and pull in the necessary dependencies. Be sure to swap out <code>${package.json.version}</code> with the actual version of Dillinger.</p><h2 id="9-文字"><a href="#9-文字" class="headerlink" title="9.文字"></a>9.文字</h2><h3 id="9-1文字背景"><a href="#9-1文字背景" class="headerlink" title="9.1文字背景"></a>9.1文字背景</h3><pre><code>`xxx` 背景颜色加灰I love `you` red line</code></pre><p>eg:<br>I love <code>you</code> red line</p><h3 id="9-2文字加粗"><a href="#9-2文字加粗" class="headerlink" title="9.2文字加粗"></a>9.2文字加粗</h3><pre><code>加粗 **Software**</code></pre><p>Free <strong>Software</strong>, Hell Yeah!</p><h3 id="9-3删除线"><a href="#9-3删除线" class="headerlink" title="9.3删除线"></a>9.3删除线</h3><pre><code>~~xxx~~</code></pre><p>我喜欢<del>java</del>python</p><h2 id="待更新"><a href="#待更新" class="headerlink" title="待更新"></a>待更新</h2><pre><code>附录：[dill]: &lt;https://github.com/joemccann/dillinger&gt;[git-repo-url]: &lt;https://github.com/joemccann/dillinger.git&gt;[john gruber]: &lt;http://daringfireball.net&gt;[df1]: &lt;http://daringfireball.net/projects/markdown/&gt;[PlMe]: &lt;https://github.com/joemccann/dillinger/tree/master/plugins/medium/README.md&gt;[PlGa]: &lt;https://github.com/RahulHP/dillinger/blob/master/plugins/googleanalytics/README.md&gt;</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;引言：HexoMd-的语法，基本够用，欢迎补充-能用得到的-与修正，部分细节有待修改（基于主题BlueLake&quot;&gt;&lt;a href=&quot;#引言：HexoMd-的语法，基本够用，欢迎补充-能用得到的-与修正，部分细节有待修改（基于主题BlueLake&quot; class=&quot;h
      
    
    </summary>
    
      <category term="hexo" scheme="http://yoursite.com/categories/hexo/"/>
    
    
      <category term="markdown" scheme="http://yoursite.com/tags/markdown/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://yoursite.com/2018/03/22/hello-world/"/>
    <id>http://yoursite.com/2018/03/22/hello-world/</id>
    <published>2018-03-22T09:34:27.055Z</published>
    <updated>2018-03-22T09:34:27.056Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.
      
    
    </summary>
    
    
  </entry>
  
</feed>
