<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>KnightChess</title>
  
  <subtitle>The shortest answer is doing.</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://wulingqi.github.io/"/>
  <updated>2018-05-10T11:45:34.191Z</updated>
  <id>http://wulingqi.github.io/</id>
  
  <author>
    <name>wu07</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>给Word文档加页码</title>
    <link href="http://wulingqi.github.io/2018/05/10/word/word-page-number/"/>
    <id>http://wulingqi.github.io/2018/05/10/word/word-page-number/</id>
    <published>2018-05-10T07:56:02.000Z</published>
    <updated>2018-05-10T11:45:34.191Z</updated>
    
    <content type="html"><![CDATA[<p>引言：呀，今天被人拜托了个word文档加页码，从任意第几页开始加页码，我其实也是不会的，然后谷歌了，文字讲的很不通俗啊，然后不知为什么莫名对B站（这里不是广告）有点信任，就上B站搜了相关视屏，然后还真的给我找到了，好了，废话不多说，加页码。</p><hr><h2 id="1-正常的步骤："><a href="#1-正常的步骤：" class="headerlink" title="1. 正常的步骤："></a>1. 正常的步骤：</h2><hr><p>1.</p><blockquote><p>点击<code>插入</code>，点击<code>页眉</code>，点击<code>编辑页眉</code></p></blockquote><p><a href="/images/word/page-number-one.png"><img src="/images/word/page-number-one.png" alt=""></a></p><p>2.</p><blockquote><p>点击<code>上页眉</code>的位置，然后点击<code>链接到前一条页眉</code></p></blockquote><p><a href="/images/word/page-number-two.png"><img src="/images/word/page-number-two.png" alt=""></a></p><p>3</p><blockquote><p>点击<code>下页眉</code>的位置，然后点击<code>链接到前一条页眉</code>，可能会有提示删除页眉，点击<code>确定</code>，关闭页眉</p></blockquote><p><a href="/images/word/page-number-three.png"><img src="/images/word/page-number-three.png" alt=""></a></p><p>4.</p><blockquote><p>点击<code>插入</code>，点击<code>页码</code>，点击<code>设置页码格式</code></p></blockquote><p><a href="/images/word/page-number-four.png"><img src="/images/word/page-number-four.png" alt=""></a><br><a href="/images/word/page-number-five.png"><img src="/images/word/page-number-five.png" alt=""></a></p><p>5.</p><blockquote><p>点击<code>页码</code>，点击<code>页码低端格式</code>，选择一个你喜欢的，然后·关闭页眉·，结束</p></blockquote><p><a href="/images/word/page-number-six.png"><img src="/images/word/page-number-six.png" alt=""></a></p><hr><h2 id="2-不正常的步骤，其实也正常"><a href="#2-不正常的步骤，其实也正常" class="headerlink" title="2. 不正常的步骤，其实也正常"></a>2. 不正常的步骤，其实也正常</h2><blockquote><p>有的文档页眉已经链接完成，直接从正常的步<code>第4步</code>，如果<code>第4步</code>设置好了也可以直接从<code>第5步</code>开始。</p></blockquote><h2 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h2><p><a href="https://www.bilibili.com/video/av18210559?from=search&amp;seid=14187288009735054722" target="_blank" rel="noopener">ppt技巧系列视频3：Word如何从任意页开始插入页码</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;引言：呀，今天被人拜托了个word文档加页码，从任意第几页开始加页码，我其实也是不会的，然后谷歌了，文字讲的很不通俗啊，然后不知为什么莫名对B站（这里不是广告）有点信任，就上B站搜了相关视屏，然后还真的给我找到了，好了，废话不多说，加页码。&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=
      
    
    </summary>
    
      <category term="Office" scheme="http://wulingqi.github.io/categories/Office/"/>
    
    
      <category term="Word" scheme="http://wulingqi.github.io/tags/Word/"/>
    
  </entry>
  
  <entry>
    <title>动态规划入门 Dynamic Programming</title>
    <link href="http://wulingqi.github.io/2018/04/24/dynamic-programming/"/>
    <id>http://wulingqi.github.io/2018/04/24/dynamic-programming/</id>
    <published>2018-04-24T10:18:41.984Z</published>
    <updated>2018-04-25T05:53:52.376Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-动态规划的核心"><a href="#1-动态规划的核心" class="headerlink" title="1. 动态规划的核心"></a>1. 动态规划的核心</h2><hr><p>怎么理解动态规划，假设读者会分治，可以发现，分治法重复多次计算相同的子问题，而动态规划就是对每个子问题只求解一次，将其解保存在一个表格中，对于重复的子问题通过查表来求解，避免不必要的计算工作。举个例子<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">问题<span class="number">1</span>：计算<span class="number">1</span>*<span class="number">2</span>*<span class="number">3</span>*<span class="number">4</span>的值result</span><br><span class="line">解：   result = <span class="number">24</span>;</span><br><span class="line">问题<span class="number">2</span>：计算<span class="number">1</span>*<span class="number">2</span>*<span class="number">3</span>*<span class="number">4</span>*<span class="number">5</span>的值result2</span><br><span class="line">解：   result2 = result * <span class="number">5</span> = <span class="number">120</span></span><br><span class="line"></span><br><span class="line">解析： 这就是动态规划的核心，用已有的子问题求解当前的值，</span><br><span class="line">  如果不用result子问题的值，那么必定会降低result2</span><br><span class="line">  的求解速度。</span><br></pre></td></tr></table></figure></p><hr><h2 id="2-动态规划解决的问题"><a href="#2-动态规划解决的问题" class="headerlink" title="2. 动态规划解决的问题"></a>2. 动态规划解决的问题</h2><hr><p>动态规划通常用来解决最优化问题。这类问题可以有很多可行解，每个解都有一个值，我们希望寻找具有最优值的解。我们称其为此题的一个最优解（最优解可能有多个）。</p><hr><h2 id="3-动态规划的步骤"><a href="#3-动态规划的步骤" class="headerlink" title="3. 动态规划的步骤"></a>3. 动态规划的步骤</h2><hr><h3 id="3-1-一般有四个步骤："><a href="#3-1-一般有四个步骤：" class="headerlink" title="3.1 一般有四个步骤："></a>3.1 一般有四个步骤：</h3><ol><li>刻画一个最优解的结构特征</li><li>递归地定义最优解的值</li><li>计算最优解的值，通常采用自低向上的方法</li><li>利用计算出的信息构造一个最优解</li></ol><h3 id="3-2-动态规划的两种等价的实现方式"><a href="#3-2-动态规划的两种等价的实现方式" class="headerlink" title="3.2 动态规划的两种等价的实现方式"></a>3.2 动态规划的两种等价的实现方式</h3><pre><code>用个大家都熟悉的fibnacci数列，虽然不是最优化问题，但能用动态规划的思想提高运行效率</code></pre><p>1.普通的递归<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">fib</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n&lt;=<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> fib(n-<span class="number">1</span>) + fib(n - <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><blockquote><p>这种方法的效率大家也知道，O(2^n)，不清楚的用递归树法画一下就知道了。</p></blockquote><p>2.动态规划–带备忘的自顶向下法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 注意，dp的大小是n+1哦，注意下标</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">fib2</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span>[] dp)</span></span>&#123;</span><br><span class="line">        <span class="comment">// dp是备忘录，默认设置好dp数组的值为-1，dp[0] = 0, dp[1] = 1</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果不为-1，说明这个子问题被解决过，直接返回，不用重复计算</span></span><br><span class="line">        <span class="keyword">if</span> (dp[n] != -<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> dp[n];</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> dp[n] = fib2(n-<span class="number">1</span>, dp) + fib2(n-<span class="number">2</span>, dp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><blockquote><p>带备忘录的自顶向下，就是从大问题开始划分一个一个子问题，通过备忘录数组记录子问题的解，避免重复求解。想象一下之前说的乘法1<em>2</em>3<em>4，后面求1</em>2<em>3</em>4<em>5，不就是直接用前面子问题的结果</em>5马上算出结果么。</p></blockquote><p>3.动态规划之自低向上法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">fib3</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n&lt;=<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n+<span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i&lt;=n; ++i)&#123;</span><br><span class="line">            dp[i] = dp[i-<span class="number">1</span>] + dp[i-<span class="number">2</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><blockquote><p>自低向上，意思就是从小到大，先算子问题，再渐渐向包含子问题的父问题求解。</p></blockquote><hr><h2 id="4-动态规划的基本要素"><a href="#4-动态规划的基本要素" class="headerlink" title="4. 动态规划的基本要素"></a>4. 动态规划的基本要素</h2><hr><p>一般的，能使用动态规划的问题具有两个要素，一个是最优子结构，一个是重叠子问题。当然，这两个要素只是给我们思考是否使用动态规划的线索，具体问题具体分析，单单满足最优子问题有时还能使用贪心算法。</p><ul><li>下面通过分析一个例子来分析这两个要素：</li></ul><p><strong>矩阵连乘问题</strong><br>引言：线性代数中，我们是不是学过矩阵相乘，所谓的矩阵连乘就是多个矩阵相乘，而我们的目的就是算出计算最少的次数，举个例子，假设有三个矩阵A1: 10<em>100，A2: 100</em>5，A3: 5<em>50；如果按（A1A2）A3算，计算规模为10</em>100<em>5 + 10</em>5<em>50共7500次；如果是A1（A2A3），计算规模为100</em>5<em>50 + 10</em>100*50共75000，可以看出不同的划分产生的是不同的结果，接下来我们按照动态规划的基本4个步骤进行分析。</p><h3 id="4-1-刻画一个最优解结构特征"><a href="#4-1-刻画一个最优解结构特征" class="headerlink" title="4.1 刻画一个最优解结构特征"></a>4.1 刻画一个最优解结构特征</h3><p>也就是最优括号化方案的结构特征，找出最优子结构。</p><ul><li>直接找或许比较难，这里举个例子帮助参考</li><li>以矩阵ABCD为例</li><li>按照矩阵链长度递增计算最优值（这个是重要的外层循环条件）</li><li>当长度为1时，分别计算矩阵链A、B、C、D的最优值，也就是0</li><li>当长度为2时，分别计算AB、BC、CD的最优值</li><li>当长度为3时，分别计算ABC、BCD的最优值</li><li><ul><li>这里就有不同的条件了，比如ABC可以是(AB)C | A(BC)</li></ul></li><li>当长度为4时，计算矩阵链ABCD的最优值，可以调用长度3时的结果。<br>重叠子问题</li><li>ABCD中，调用ABC或BCD，ABC调用AB或BC，BCD中调用BC或CD</li></ul><p><strong>验证最优结构</strong>（看不懂也没事，多做题，渐渐就有感觉）</p><blockquote><p>假设m[i,j]（二维数组）代表i到j的最优解，其中一个最优解的分割点为k，那么继续分别对子链m[i,k]和m[k+1,j]进行括号化；而且两条子链必须是独立求解，也就是说互不干扰的继续划分，如果不独立求解划分，那么就可以将此最优解带入m[i,j]中，并且代价比是分割点为k时更低，与假设矛盾（反证法）。那么我们就找到了我们想要的最优子结构，为了构造最优解，我们可以将问题划分为两个子问题继续求解。</p></blockquote><h3 id="4-2-递归地定义最优解的值"><a href="#4-2-递归地定义最优解的值" class="headerlink" title="4.2 递归地定义最优解的值"></a>4.2 递归地定义最优解的值</h3><p>就是找出递归表达式，状态转移方程。</p><blockquote><p>m[i,j]表示i到j的最小次数，所以，当i==j时，就是本身，所以m[i,j] = 0;<br>假设割点在i，j之间，当i&lt;j时，看下图，我们的状态转移方程就出来了</p></blockquote><p><a href="/images/Algorithm/dy.jpg"><img src="/images/Algorithm/dy.jpg" alt=""></a></p><blockquote><p>注意这里的p的下标，有的是p(i)<em>p(k)</em>p(j+1)，这里并没有什么毛病，和数组p的设置（有的人p数组记录行，有的记录列）和你下标的访问有关，有的人从1开始，有的从0开始，思路一样就对了。</p></blockquote><h3 id="4-3-计算最优解的值，通常采用自底向上的方法"><a href="#4-3-计算最优解的值，通常采用自底向上的方法" class="headerlink" title="4.3 计算最优解的值，通常采用自底向上的方法"></a>4.3 计算最优解的值，通常采用自底向上的方法</h3><p>变量解释：</p><ul><li>二维数组m，存储最优值的方案</li><li>二维数组n，记录分割点的位置</li><li>一维数组p，录矩阵的规格信息<blockquote><p>还是举个例子解释下，假设三个矩阵分别是&lt;10,100&gt;、&lt;100,5&gt;、&lt;5,50&gt;；<br>m规格是&lt;3,3&gt;, n是&lt;3,3&gt;<br>&lt;10,100&gt;、&lt;100,5&gt;、&lt;5,50&gt;<br>对应p[0] = 10, p[1] = 100, p[2] = 5, p[3] = 50;<br>第一个行元素加上所有的列，也可以是所有行加上最后一个列</p></blockquote></li></ul><p><strong>这里使用自底向上的动态规划实现</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JuZhengLianChen</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 这里都固定一些值</span></span><br><span class="line">        <span class="keyword">int</span> n = <span class="number">6</span>;</span><br><span class="line">        <span class="comment">//矩阵 &lt;30,35&gt;&lt;35,15&gt;&lt;15,5&gt;&lt;5,10&gt;&lt;10,20&gt;&lt;20,25&gt;</span></span><br><span class="line">        <span class="keyword">int</span>[] p = &#123;<span class="number">30</span>, <span class="number">35</span>, <span class="number">15</span>, <span class="number">5</span>, <span class="number">10</span>, <span class="number">20</span>, <span class="number">25</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span>[][] m = <span class="keyword">new</span> <span class="keyword">int</span>[n][n];</span><br><span class="line">        <span class="keyword">int</span>[][] s = <span class="keyword">new</span> <span class="keyword">int</span>[n][n];</span><br><span class="line">        matrixMultply(p, m, s, n);</span><br><span class="line">        dispaly(<span class="number">0</span>, n-<span class="number">1</span>, s);</span><br><span class="line">        <span class="comment">// 读者可以尝试输出s和m的内容进行对比</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">matrixMultply</span><span class="params">(<span class="keyword">int</span>[] p, <span class="keyword">int</span>[][] m, <span class="keyword">int</span>[][] s, <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 这里省略m和s的初始化</span></span><br><span class="line">        <span class="comment">// j表示按长度的末尾位置</span></span><br><span class="line">        <span class="keyword">int</span> j = <span class="number">0</span>, mid;</span><br><span class="line">        <span class="comment">// 从子问题，比较短的开始求解。</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> len = <span class="number">2</span>; len&lt;=n; ++len)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i&lt; (n -len +<span class="number">1</span>); ++i)&#123;</span><br><span class="line">                j = len + i - <span class="number">1</span>;</span><br><span class="line">                m[i][j] = m[i+<span class="number">1</span>][j] + p[i]*p[i+<span class="number">1</span>]*p[j+<span class="number">1</span>];</span><br><span class="line">                s[i][j] = i + <span class="number">1</span>;</span><br><span class="line">                <span class="comment">// 对[i, j]中进行一个一个划分</span></span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k = i + <span class="number">1</span>; k&lt; j; ++k)&#123;</span><br><span class="line">                    mid = m[i][k] + m[k+<span class="number">1</span>][j] + p[i]*p[k]*p[j+<span class="number">1</span>];</span><br><span class="line">                    <span class="keyword">if</span> (mid &lt; m[i][j])&#123;</span><br><span class="line">                        m[i][j] = mid;</span><br><span class="line">                        s[i][j] = k + <span class="number">1</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 递归输出最优解，结合动态规划的逆向过程，不难想出</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">dispaly</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="keyword">int</span>[][] s)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (i == j)&#123;</span><br><span class="line">            System.out.print(<span class="string">"A"</span> + i);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            System.out.print(<span class="string">"&lt;"</span>);</span><br><span class="line">            dispaly(i, s[i][j]-<span class="number">1</span>, s);</span><br><span class="line">            dispaly(s[i][j], j, s);</span><br><span class="line">            System.out.print(<span class="string">"&gt;"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="4-4-构造最优解"><a href="#4-4-构造最优解" class="headerlink" title="4.4 构造最优解"></a>4.4 构造最优解</h3><p>用矩阵连乘的例子来说，就是找出其中一个分割的解方案，其实上面我已经给出答案了，通过在求解过程中额外加入的s数组进行一定的处理就能算出结果。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;1-动态规划的核心&quot;&gt;&lt;a href=&quot;#1-动态规划的核心&quot; class=&quot;headerlink&quot; title=&quot;1. 动态规划的核心&quot;&gt;&lt;/a&gt;1. 动态规划的核心&lt;/h2&gt;&lt;hr&gt;
&lt;p&gt;怎么理解动态规划，假设读者会分治，可以发现，分治法重复多次计算相同的子
      
    
    </summary>
    
      <category term="算法" scheme="http://wulingqi.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="动态规划" scheme="http://wulingqi.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>linux软链接和硬链接的区别</title>
    <link href="http://wulingqi.github.io/2018/04/22/Linux/linux-ln/"/>
    <id>http://wulingqi.github.io/2018/04/22/Linux/linux-ln/</id>
    <published>2018-04-22T04:26:22.000Z</published>
    <updated>2018-04-22T06:26:38.009Z</updated>
    
    <content type="html"><![CDATA[<p>引言：这里bz当读者都知道这两个链接的用法了，那么进入正题吧。</p><hr><h2 id="1-硬链接"><a href="#1-硬链接" class="headerlink" title="1. 硬链接"></a>1. 硬链接</h2><blockquote><p>套一下别人的概念吧：由于linux下的文件是通过索引节点（Inode）来识别文件，硬链接可以认为是一个指针，指向文件索引节点的指针，系统并不为它重新分配inode。每添加一个一个硬链接，文件的链接数就加1。<br>不足：尽管硬链接节省空间，也是Linux系统整合文件系统的传统方式，但是存在一下不足之处：（1）不可以在不同文件系统的文件间建立链接（2）只有超级用户才可以为目录创建硬链接。</p></blockquote><hr><h2 id="2-软链接"><a href="#2-软链接" class="headerlink" title="2. 软链接"></a>2. 软链接</h2><blockquote><p>同理：软链接克服了硬链接的不足，没有任何文件系统的限制，任何用户可以创建指向目录的符号链接。因而现在更为广泛使用，它具有更大的灵活性，甚至可以跨越不同机器、不同网络对文件进行链接。<br>缺点：因为链接文件包含有原文件的路径信息，所以当原文件从一个目录下移到其他目录中，再访问链接文件，系统就找不到了，而硬链接就没有这个缺陷，你想怎么移就怎么移；还有它要系统分配额外的空间用于建立新的索引节点和保存原文件的路径。</p></blockquote><hr><h2 id="3-通过例子来看看一些问题吧"><a href="#3-通过例子来看看一些问题吧" class="headerlink" title="3. 通过例子来看看一些问题吧"></a>3. 通过例子来看看一些问题吧</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 创建test文件夹，用来保存我们将要链接的文件</span></span><br><span class="line">mkdir test</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建要用来测试软链接的soft文件，并写入内容soft</span></span><br><span class="line">vim test/soft</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建要用来测试硬链接的hard文件，并写入内容hard</span></span><br><span class="line">vim test/hard</span><br><span class="line"></span><br><span class="line"><span class="comment">// 为soft创建软链接</span></span><br><span class="line">ln -s test/soft test.soft</span><br><span class="line"></span><br><span class="line"><span class="comment">// 为hard创建硬链接</span></span><br><span class="line">ln test/hard test.hard</span><br><span class="line"></span><br><span class="line"><span class="comment">// 试试通过软链接修改内容，在内容后加上.link</span></span><br><span class="line">vim test.soft</span><br><span class="line">vim test.hard</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查看test目录下的内容都发生了改变，那么，我们来研究下两者连接的原理</span></span><br><span class="line"><span class="comment">// 分别删除test目录下的soft和hard文件</span></span><br><span class="line">rm -rf test/soft</span><br><span class="line">rm -rf test/hard</span><br><span class="line"></span><br><span class="line"><span class="comment">// 然后通过各自的软硬链接访问下，发现硬链接还是能访问到，</span></span><br><span class="line"><span class="comment">// 而软链接gg了，找不到文件，这就是他们的区别之一</span></span><br></pre></td></tr></table></figure><blockquote><p>软链接就像window下的快捷方式，把原文件删除了，就gg了，而硬链接怎么比喻呢，似乎不好比喻那么就详细解释吧。</p></blockquote><hr><h2 id="研究研究"><a href="#研究研究" class="headerlink" title="研究研究"></a>研究研究</h2><p>前言：建议了解下inode以及linux下的文件管理方式</p><p>使用命令stat查看下test两个文件和两个链接文件的属性，并且提取了部分信息：</p><table><thead><tr><th style="text-align:center">文件名(路径)</th><th style="text-align:center">inode</th><th style="text-align:center">Links(链接数)</th></tr></thead><tbody><tr><td style="text-align:center">test/soft</td><td style="text-align:center">920416</td><td style="text-align:center">1</td></tr><tr><td style="text-align:center">test.soft</td><td style="text-align:center">920415</td><td style="text-align:center">1</td></tr><tr><td style="text-align:center">test/hard</td><td style="text-align:center">920149</td><td style="text-align:center">2</td></tr><tr><td style="text-align:center">test.hard</td><td style="text-align:center">920149</td><td style="text-align:center">2</td></tr></tbody></table><blockquote><p>查找文件分三个步骤：先是通过文件名找到对应的inode； 再通过inode获取相关的文件信息；最后根据inode信息找到文件所在的block。<br>也就是说，这里的目录名只是类似对用户友善的标识，linux系统其实是通过inode来区分文件信息的。<br>看表格，软链接创建后系统为test.soft分配了一个inode，这个inode信息指向test下的soft的文件名，而硬链接系统并没有再分配别的inode，而是使用同一个inode信息，可能后台维护一个表吧，了解不深，不清楚。<br>通过链接数可以看出，保存信息的inode被几个文件名所指向，其中硬链接使不同的用户名指向同一个inode信息，而在linux中，如果inode的连接数不为零，系统救不会回收这个inode号码和block区域。所以，这也就能解释为什么删除一个硬链接的文件名，所对应的文件信息还能找到，而软链接就找不到了。因为软链接中的test.soft 依赖 test文件下的soft的node信息，也就是依赖。</p></blockquote><hr><p>详细的inode解释，比较好懂的可以看阮一峰老师的<a href="http://www.ruanyifeng.com/blog/2011/12/inode.html" target="_blank" rel="noopener">理解inode</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;引言：这里bz当读者都知道这两个链接的用法了，那么进入正题吧。&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&quot;1-硬链接&quot;&gt;&lt;a href=&quot;#1-硬链接&quot; class=&quot;headerlink&quot; title=&quot;1. 硬链接&quot;&gt;&lt;/a&gt;1. 硬链接&lt;/h2&gt;&lt;blockquote&gt;
&lt;p
      
    
    </summary>
    
      <category term="linux" scheme="http://wulingqi.github.io/categories/linux/"/>
    
    
  </entry>
  
  <entry>
    <title>Tesseract使用jTessBoxEditor进行简单样本训练</title>
    <link href="http://wulingqi.github.io/2018/04/21/python/pythonPhotoRescognition/"/>
    <id>http://wulingqi.github.io/2018/04/21/python/pythonPhotoRescognition/</id>
    <published>2018-04-21T01:06:35.000Z</published>
    <updated>2018-04-21T10:18:36.716Z</updated>
    
    <content type="html"><![CDATA[<p>前言：bz近来在搞数学建模，官方给了几个g的数据，bz dowload下来后发现三个文件夹，打开两个，excel表格数据，嗯，简单，可以，觉得我的任务差不多能解决了，嗯，第三个文件夹，懵逼.jpg，图片数据（天哪，你们不能统一点给数据格式么），无奈谷歌python的图像文字识别方面的功能，于是有了以下历程。</p><hr><h2 id="1-python包"><a href="#1-python包" class="headerlink" title="1. python包"></a>1. python包</h2><ul><li>pillow</li><li>pytesseract</li></ul><hr><h2 id="2-安装Tesseract"><a href="#2-安装Tesseract" class="headerlink" title="2. 安装Tesseract"></a>2. 安装Tesseract</h2><p>1.Windows<br>访问<a href="https://digi.bib.uni-mannheim.de/tesseract/" target="_blank" rel="noopener">下载地址</a>，在安装的过程中，会有提示的安装相应的语言包，如果没有可以自行去<a href="https://github.com/tesseract-ocr/tessdata" target="_blank" rel="noopener">下载地址</a>，下载你想要的xxx.traineddata文件放到tessseract目录下的tessdata文件中</p><p>2.Linux（在下用的就是ArchLinux）（别问我为什么写两个，后面你就知道了）<br>不同版本的linux的仓库都有相应的tesseract，自行谷歌下载，同样，语言包和window下的地址一样，自行下载放到/usr/share/tessdata或者/usr/share/xxxx/tessdata目录下。</p><hr><h2 id="3-直接使用Tesseract的中文语言包"><a href="#3-直接使用Tesseract的中文语言包" class="headerlink" title="3. 直接使用Tesseract的中文语言包"></a>3. 直接使用Tesseract的中文语言包</h2><p>如果没有特别注释，window和linux一样<br>打开pycharm，写入以下代码<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> pytesseract</span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"></span><br><span class="line">image = Image.open(<span class="string">'D:\\xxx\\PyWorkSpace\\data\\zzz.jpg'</span>)</span><br><span class="line"></span><br><span class="line">code = pytesseract.image_to_string(image, lang=<span class="string">'chi_sim'</span>)</span><br><span class="line"></span><br><span class="line">print(code)</span><br></pre></td></tr></table></figure></p><blockquote><p>额么么么。图片我就不粘贴了，准确率0，嗯。。。</p></blockquote><hr><h2 id="4-我们还是来训练样本吧"><a href="#4-我们还是来训练样本吧" class="headerlink" title="4. 我们还是来训练样本吧"></a>4. 我们还是来训练样本吧</h2><p>前言：先将所需要的图片转换成tif格式，然后使用<a href="https://sourceforge.net/projects/vietocr/files/jTessBoxEditor/" target="_blank" rel="noopener">jTessBoxEditor</a>工具（需要再java jre下再能运行）合并这几张图片。tools-&gt;Merge tiff<br>。</p><blockquote><p>注意：图片合并后的格式：[langname].[fontname].exp[num]，langname是定义语言的名称，fontname是定义的字体名称，后面都会用到。</p></blockquote><hr><h3 id="4-1-tesseract识别，生成box文件"><a href="#4-1-tesseract识别，生成box文件" class="headerlink" title="4.1 tesseract识别，生成box文件"></a>4.1 tesseract识别，生成box文件</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tesseract chi.font.exp0.tif chi.font.exp0 -l chi_sim batch.nochop makebox</span><br></pre></td></tr></table></figure><blockquote><p>注意：这里的chi_sim是中文语言包，使用时为了提高识别率，如果tessdata中没有可以去掉-l chi_sim，就会默认eng的语言包，也得保证tessdata下有eng.traineddata文件。</p></blockquote><hr><h3 id="4-2-使用jTessBoxEditor"><a href="#4-2-使用jTessBoxEditor" class="headerlink" title="4.2 使用jTessBoxEditor"></a>4.2 使用jTessBoxEditor</h3><p>通过open打开对应的tif文件，会自动打开对应的box文件。</p><ol><li>在box Coordinate修改错误的内容</li><li>box view可以查看</li><li>修改完后记得save，save，save</li></ol><hr><h3 id="4-3-trainning"><a href="#4-3-trainning" class="headerlink" title="4.3 trainning"></a>4.3 trainning</h3><p>使用box文件生成.tr文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tesseract chi.font.exp0.tif chi.font.exp0 -l chi_sim nobatch box.train</span><br></pre></td></tr></table></figure><hr><h3 id="4-4-character-set"><a href="#4-4-character-set" class="headerlink" title="4.4 character set"></a>4.4 character set</h3><p>到上面windown下都没什么问题，到这就有问题了，生成unicharset文件<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">unicharset_extractor chi.font.exp0.box</span><br></pre></td></tr></table></figure></p><blockquote><p>window下提示我U_FILE_ACCESS_ERROR的问题，给出的解释是：The requested file cannot be foud.lz弄了一下午也不清楚是什么问题，就放弃了，转到了archlinux重新搞一遍，这边就过了。如果有什么解决方法，求告知。</p></blockquote><hr><h3 id="4-5-font-properties"><a href="#4-5-font-properties" class="headerlink" title="4.5 font_properties"></a>4.5 font_properties</h3><p>定义字体特征文件，创建一个名称为 font_properties 的字体特征文件<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">window:</span><br><span class="line"><span class="built_in">echo</span> font 0 0 0 0 0 &gt;font_properties</span><br><span class="line"></span><br><span class="line">linux:</span><br><span class="line">vim font_properties</span><br><span class="line">font 0 0 0 0 0</span><br></pre></td></tr></table></figure></p><blockquote><p>这里的font就是之前的fontname</p></blockquote><hr><h2 id="5-Clustering"><a href="#5-Clustering" class="headerlink" title="5. Clustering"></a>5. Clustering</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">shapeclustering -F font_properties -U unicharset chi.font.exp0.tr</span><br><span class="line"></span><br><span class="line">mftraining -F font_properties -U unicharset -O chi.unicharset chi.font.exp0.tr</span><br><span class="line"></span><br><span class="line">cntraining chi.font.exp0.tr</span><br></pre></td></tr></table></figure><ul><li>修改生成的4个文件（inttemp、pffmtable、normproto、shapetable）名称为[langname].xxx，比如：chi.inttemp、chi.pffmtable、chi.normproto、chi.shapetable。</li></ul><blockquote><p>注意：这里的mftraining可能会遇到存储空间的问题，详见<a href="https://groups.google.com/forum/#!msg/tesseract-ocr/eQ6HQdVE7Cw/3o1XPn2Q0CkJ" target="_blank" rel="noopener">Google 论坛</a></p></blockquote><hr><h3 id="5-1-生成-traineddata-语言文件"><a href="#5-1-生成-traineddata-语言文件" class="headerlink" title="5.1 生成.traineddata 语言文件"></a>5.1 生成.traineddata 语言文件</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">combine_tessdata chi.</span><br></pre></td></tr></table></figure><blockquote><p>最后将chi.traineddata文件拷贝到tessdata目录下就可以了</p></blockquote><hr><h2 id="6-使用chi-traineddata"><a href="#6-使用chi-traineddata" class="headerlink" title="6. 使用chi.traineddata"></a>6. 使用chi.traineddata</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pytesseract</span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"></span><br><span class="line">image = Image.open(<span class="string">'D:\\507\\PyWorkSpace\\data\\zzz.jpg'</span>)</span><br><span class="line"></span><br><span class="line">code = pytesseract.image_to_string(image, lang=<span class="string">'chi'</span>)</span><br><span class="line"></span><br><span class="line">print(code)</span><br></pre></td></tr></table></figure><blockquote><p>数字准确率100%，但是中文还是不行，有待提高。</p></blockquote><hr><p>参考：<br><a href="http://xiaosheng.me/2015/12/18/article11/" target="_blank" rel="noopener">Tesseract训练</a><br><a href="https://blog.csdn.net/firehood_/article/details/8433077" target="_blank" rel="noopener">Tesseract-OCR 字符识别—样本训练</a></p><hr><h2 id="7-资源链接："><a href="#7-资源链接：" class="headerlink" title="7. 资源链接："></a>7. 资源链接：</h2><p><a href="https://digi.bib.uni-mannheim.de/tesseract/" target="_blank" rel="noopener">window Tesseract</a><br><a href="https://github.com/tesseract-ocr/tessdata" target="_blank" rel="noopener">语言包</a><br><a href="https://sourceforge.net/projects/vietocr/files/jTessBoxEditor/" target="_blank" rel="noopener">jTessBoxEditor</a><br><a href="https://github.com/tesseract-ocr/" target="_blank" rel="noopener">tesseract-ocr</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;前言：bz近来在搞数学建模，官方给了几个g的数据，bz dowload下来后发现三个文件夹，打开两个，excel表格数据，嗯，简单，可以，觉得我的任务差不多能解决了，嗯，第三个文件夹，懵逼.jpg，图片数据（天哪，你们不能统一点给数据格式么），无奈谷歌python的图像文字
      
    
    </summary>
    
      <category term="python" scheme="http://wulingqi.github.io/categories/python/"/>
    
    
      <category term="tesseract" scheme="http://wulingqi.github.io/tags/tesseract/"/>
    
      <category term="图像识别" scheme="http://wulingqi.github.io/tags/%E5%9B%BE%E5%83%8F%E8%AF%86%E5%88%AB/"/>
    
  </entry>
  
  <entry>
    <title>人性弱点之使人喜欢你的六种方法</title>
    <link href="http://wulingqi.github.io/2018/04/18/Literature/human-weakness-two/"/>
    <id>http://wulingqi.github.io/2018/04/18/Literature/human-weakness-two/</id>
    <published>2018-04-18T06:39:44.000Z</published>
    <updated>2018-04-28T11:27:18.923Z</updated>
    
    <content type="html"><![CDATA[<p>引言：这里没有读后感，也没有具体内容，只是记录一些觉得令我觉得不错的语句</p><hr><h2 id="如果这样做，你将到处受欢迎"><a href="#如果这样做，你将到处受欢迎" class="headerlink" title="如果这样做，你将到处受欢迎"></a>如果这样做，你将到处受欢迎</h2><hr><ul><li>如果我们只是想使人注意，使人对我们发生兴趣，我们永远不会有很多真诚的朋友···朋友，真正的朋友，不是那样造成的。</li><li>一个不关心别人，对别人不感兴趣的人，他的生活必遭受重大的阻碍，困难，同时会给别人带来极大的损害，困扰。所有人类的失败，都是由于这些人才发生的。 –<code>阿得洛（著作：生活对你的意义）</code></li><li>假如我们相交朋友，应该先出来替别人做些事 – 需要时间、精力、公义、体恤的事。</li></ul><blockquote><p>来个小插曲：你来回答一个问题，如何优雅地询问别人的生日？（答案末尾哦（有点短，不要偷偷看后面好嘛），可能有更好的也说不定，请务必教我）</p></blockquote><ul><li>要别人对我们发生兴趣时，我们先要对别人发生兴趣。 –<code>西罗斯（罗马诗人）</code></li></ul><blockquote><p>真诚的对别人发生兴趣</p></blockquote><hr><blockquote><p>来自书里的解决方法： 我见了朋友，就问他们是否相信人的生日跟每个人的性格，个性有关？然后我请他告诉我他的出生年月日（然后<del>偷偷</del>悄悄记上，嘿嘿。）</p></blockquote><hr><h2 id="如何给人好印象"><a href="#如何给人好印象" class="headerlink" title="如何给人好印象"></a>如何给人好印象</h2><hr><ul><li>如果你希望别人用一副高兴、欢愉的神情来接待你，那么你自己先要用这样的神情去对待别人。</li><li>行动该是追随着一个人自己的感受。。。。可是事实上，行动和感受，是并道而驰的。所以，你需要快乐时，可以强迫自己快乐起来。</li><li>人们都想知道要如何寻求快乐，这里有一条途径，或许可以把你带去快乐的境界。那就是让自己知道，快乐是出自自己内在的心情，不需要向外界寻求的。</li><li>大多数人所获得的快乐，跟他意念所想到的相差不多。 – <code>林肯</code></li><li>你要时时把自己想象作怀有才干，待人诚恳，有益于社会的一个有用的人。你有了这种想法后，会时时刻刻的改变你自己，使你的人格渐渐变成这种典型。你必需知道，一个人的思维力，能形成一股极大的力量。</li><li>保持一种正确的心理状态——勇敢、诚实，和乐观。正确的思想，能启发创造力。所以有很多的事情，都是由理想、欲望而来的。凡你真诚的祈求，都会获得完全的应验。我们想要获得什么成就，只要把这种意念孕育在我们心里，我们就会有这样的收获！放松你凝重的脸色，抬起头，我们就是明天的主宰。</li><li>因为没有给人微笑的人，更需要别人给他微笑。</li></ul><hr><h2 id="你要避免发生麻烦，就请这样做"><a href="#你要避免发生麻烦，就请这样做" class="headerlink" title="你要避免发生麻烦，就请这样做"></a>你要避免发生麻烦，就请这样做</h2><hr><ul><li>人们都重视自己的名字，尽量设法让自己的名字流传下去，甚至愿意付出任何的代价。</li></ul><blockquote><p>你要记住你所接触中，每一个人的姓名。</p></blockquote><hr><h2 id="如何养成优美而得人好感的谈吐"><a href="#如何养成优美而得人好感的谈吐" class="headerlink" title="如何养成优美而得人好感的谈吐"></a>如何养成优美而得人好感的谈吐</h2><hr><ul><li>很少人能拒受那专心注意所包含的谄媚。 –<code>伍福特</code></li><li>一桩成功的生意往来，没有什么神秘的诀窍······专心静听着对着你讲话的人，那是最重要的，再也偶没有比这个更重要的了！</li><li>最爱挑剔的人，最激烈的批评者，往往会在一个怀有忍耐、同情的静听者面前软化下来！</li><li>有若干出名的任务，曾这样跟我说，······他们所喜欢的，不是善于谈话的人，是那些静听的人，即是一般普通人也如此，都喜欢人家听他讲话。</li><li>需要记住：跟你说话的人，对他自己来讲，他的需要、他的问题，比你的问题要重要上百倍。他的牙痛，对他来讲，要比发生天灾死了数百万人还要重要的多。他注意自己头上一个小疮愈，比注意发生一桩大地震还来的多。</li></ul><blockquote><p>做一个善于静听的人，鼓励别人多谈谈他们自己。</p></blockquote><hr><h2 id="如何使人感到兴趣"><a href="#如何使人感到兴趣" class="headerlink" title="如何使人感到兴趣"></a>如何使人感到兴趣</h2><hr><ul><li>深入人们心底的最佳途径，就是对那人讲他知道得最多的事物。 – <code>罗斯福</code></li></ul><blockquote><p>就别人的兴趣谈论。</p></blockquote><hr><h2 id="如何使人很快的喜欢你"><a href="#如何使人很快的喜欢你" class="headerlink" title="如何使人很快的喜欢你"></a>如何使人很快的喜欢你</h2><hr><ul><li>自重的欲望，是人们天性中最急切的需求。 – <code>社威教授</code></li><li>人们天性的至深本质，是渴求为人所重视。 – <code>贾姆斯博士</code></li><li>最重要的定律：你希望别人怎样带你，你就该怎样去对待别人。</li><li>有一条明显的真理，就是你所遇到的任何人，几乎每个人，都觉得自己某方面比你优秀。可是有一个方法，可以深入他的心底–就是让他觉得你承认他在自己的小天地里，是高贵重要的，要真诚的承认。</li><li>狄克斯女士访问一个重婚者，这个人曾经获得十三个女人的芳心，和她们银行卡里的存款，问他获得女人爱情的方法–他说并没有什么诡计，你只要对女人谈论她自己就行了。</li><li>对一个男人谈论他自己的事，他会静静的听数小时之久。 – <code>英国首相狄瑞理</code></li></ul><blockquote><p>使别人感觉到他的重要–必须真诚的这样做。</p></blockquote><hr><hr><h2 id="总结下："><a href="#总结下：" class="headerlink" title="总结下："></a>总结下：</h2><ol><li>真诚的对别人发生兴趣</li><li>微笑</li><li>记住你所接触中，每一个人的姓名</li><li>做一个善于静听的人，鼓励别人多谈谈他们自己</li><li>就别人的兴趣谈论</li><li>是别人感觉到他的重要–必须要真诚的这样做。</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;引言：这里没有读后感，也没有具体内容，只是记录一些觉得令我觉得不错的语句&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&quot;如果这样做，你将到处受欢迎&quot;&gt;&lt;a href=&quot;#如果这样做，你将到处受欢迎&quot; class=&quot;headerlink&quot; title=&quot;如果这样做，你将到处受欢迎&quot;&gt;&lt;/
      
    
    </summary>
    
      <category term="文学范" scheme="http://wulingqi.github.io/categories/%E6%96%87%E5%AD%A6%E8%8C%83/"/>
    
    
      <category term="卡耐基" scheme="http://wulingqi.github.io/tags/%E5%8D%A1%E8%80%90%E5%9F%BA/"/>
    
  </entry>
  
  <entry>
    <title>(转)IntelliJ IDEA(Android Studio)中如何减少对c盘的占用(相关核心文件和目录介绍)</title>
    <link href="http://wulingqi.github.io/2018/04/17/idea/configuration-path/"/>
    <id>http://wulingqi.github.io/2018/04/17/idea/configuration-path/</id>
    <published>2018-04-17T15:14:47.000Z</published>
    <updated>2018-04-17T15:23:27.880Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>引言：博主无聊之余，偶然发现c盘竟然快满了，立志要清理文件，看到idea的配置竟然占了2个多G，然后就与下面的博主展开了无声的交流。</p></blockquote><p>原文：<a href="https://blog.csdn.net/qq_27093465/article/details/52385643" target="_blank" rel="noopener"> IntelliJ IDEA(Android Studio)中如何设置使得占用C盘空间尽量少(相关核心文件和目录介绍)</a></p><blockquote><p>这下好了，全家桶都能把配置路径挪出去了。（开心.jpg）</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;引言：博主无聊之余，偶然发现c盘竟然快满了，立志要清理文件，看到idea的配置竟然占了2个多G，然后就与下面的博主展开了无声的交流。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;原文：&lt;a href=&quot;https://blog.csdn.net/qq
      
    
    </summary>
    
      <category term="idea" scheme="http://wulingqi.github.io/categories/idea/"/>
    
    
  </entry>
  
  <entry>
    <title>人性的弱点之待人的基本技巧</title>
    <link href="http://wulingqi.github.io/2018/04/16/Literature/human-weakness/"/>
    <id>http://wulingqi.github.io/2018/04/16/Literature/human-weakness/</id>
    <published>2018-04-16T14:11:46.000Z</published>
    <updated>2018-04-18T06:43:23.518Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>更新：2018-4-18</p></blockquote><p>引言：这里没有读后感，也没有具体内容，只是记录一些觉得令我觉得不错的语句</p><h2 id="如欲采蜜，勿蹴蜂房"><a href="#如欲采蜜，勿蹴蜂房" class="headerlink" title="如欲采蜜，勿蹴蜂房"></a>如欲采蜜，勿蹴蜂房</h2><ul><li>批评是没有用的，因它诗人增加一层防御，而且竭力的替自己辩护。</li><li>批评也是危险的，它会伤害一个人的自尊和自重的感觉，并激起他的反抗</li><li>人类自然的天性，是做错事只会责备别人，而绝不会责备自己，我们每个人都是如此。</li><li>我们需要了解，我们要矫正或谴责的人，他也会为自己辩护，而反过来谴责我们。</li><li>不要评议人，免得为人所评议 –<code>格言</code></li><li>不要批评他们，我们在相同的情形下，也会像他们一样。（换位思考，换做是我们，我们做的没准比他们还差，换位思考他们所处的环境）</li><li>你所认识的人，你愿意他改变、调整，或是进步吗？是的，那是最好不过的。可是为什么不从你自己先开始呢？从自私的立场来说，从自己开始要比改进别人，获益跟多。</li><li>当我们要应付一个人的时候，应该记住，我们不是应付理论的动物，而是应付感情的动物。</li><li>他成功的秘诀是：“我不说任何人的不好！”他又这样说：“而说我所知道的每一个人的好处！”</li></ul><blockquote><p>不要批评，责怪或抱怨</p></blockquote><h2 id="与人相处的大秘窍"><a href="#与人相处的大秘窍" class="headerlink" title="与人相处的大秘窍"></a>与人相处的大秘窍</h2><ul><li>我能叫你去做任何事情的唯一方法，那就是把你所需要的给你。</li><li>人类天性至深的本质，就是渴求为人所重视。 –<code>威利·贾姆士</code></li><li>寻求自重感的欲望，是人类和动物间，一项重要的差别。</li><li>许多精神错乱的人，在他疯癫中，找到了真实世界中无法获得的自重感。</li><li>世界上最容易摧毁一个人志向的，那就是上司所给他的批评。我从来不批评任何人，我只给人们工作的激励。我是急于称赞，而迟于寻错，如果说我喜欢什么的话，那就是诚于嘉许，宽裕称道。 –<code>司华伯</code></li><li>赞赏和谄媚的区别在······那很容易识别出来，赞赏是出于真诚，而谄媚是虚伪的。一个出于由衷，一个出于嘴裹；一个是不自私的，一个是自私的。一个是为人们所钦佩的，一个是令人不耻而扬弃的。</li><li>别怕攻击你的敌人，提防谄媚你的朋友。 –<code>奥伯利根将军</code></li><li>凡我所遇到的人，有胜过我的地方，我就学他那些好的地方。 –<code>爱默逊</code></li></ul><blockquote><p>献出你真实，诚恳的赞赏</p></blockquote><h2 id="左右逢源的方法"><a href="#左右逢源的方法" class="headerlink" title="左右逢源的方法"></a>左右逢源的方法</h2><ul><li>当我去钓鱼的时候，我不想我所需要的，而想它们所需要的。</li><li>世界上唯一能影响对方的方法，就是谈论他所要的，而且还告诉他，如何才能得到它</li><li>但有一件事是确定的，你捐款，是因为你需要些什么的缘故。</li><li>明天你要劝说某人去做某件事，在你尚未开口前，不妨自己先问：“我如何能使他做这件事？”</li><li>如果有一个成功秘诀的话，那就是如何判断得到对方“立场”的能力，由他的观点设想，正同由你的观点一样。 –<code>亨利·福特</code></li><li>表现自己，那是人性最主要的需要。 –<code>威立姆·温德</code></li></ul><blockquote><p>引起别人的渴望</p></blockquote><hr><h2 id="至此，结束这一篇的阅读。"><a href="#至此，结束这一篇的阅读。" class="headerlink" title="至此，结束这一篇的阅读。"></a>至此，结束这一篇的阅读。</h2><pre><code>完结撒花（花.jpg）</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;更新：2018-4-18&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;引言：这里没有读后感，也没有具体内容，只是记录一些觉得令我觉得不错的语句&lt;/p&gt;
&lt;h2 id=&quot;如欲采蜜，勿蹴蜂房&quot;&gt;&lt;a href=&quot;#如欲采蜜，勿蹴蜂房&quot; class=&quot;he
      
    
    </summary>
    
      <category term="文学范" scheme="http://wulingqi.github.io/categories/%E6%96%87%E5%AD%A6%E8%8C%83/"/>
    
    
      <category term="卡耐基" scheme="http://wulingqi.github.io/tags/%E5%8D%A1%E8%80%90%E5%9F%BA/"/>
    
  </entry>
  
  <entry>
    <title>hexo的Unable to create index.lock File exits问题</title>
    <link href="http://wulingqi.github.io/2018/04/16/hexo-some-quesions/"/>
    <id>http://wulingqi.github.io/2018/04/16/hexo-some-quesions/</id>
    <published>2018-04-16T13:56:31.000Z</published>
    <updated>2018-04-16T14:08:46.594Z</updated>
    
    <content type="html"><![CDATA[<p>引言：今天写博客时忘记hexo g就push了，所以我就强制ctrl + c暂停push，后面再push 也就是hexo d时gg了<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Error: fatal: Unable to create <span class="string">'D:/507/Blog/blog/.deploy_git/.git/index.lock'</span>: File exists.</span><br></pre></td></tr></table></figure></p><blockquote><p>ememem, 解决方法很简单按意思是无法创建锁文件，了解原理后，到指定的文件路径把这个锁文件删掉就行了。<br>解释：在hexo d文件的过程中，会产生临时文件index.lock锁文件来锁住相应的资源，push时在lock释放前不能使用相关资源，hexo在发布过程结束后会自动删除锁文件，但是如果我强制退出，此文件不会被删除，这时候手动删除此文件，重新hexo d就行了。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;引言：今天写博客时忘记hexo g就push了，所以我就强制ctrl + c暂停push，后面再push 也就是hexo d时gg了&lt;br&gt;&lt;figure class=&quot;highlight sh&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;sp
      
    
    </summary>
    
      <category term="hexo" scheme="http://wulingqi.github.io/categories/hexo/"/>
    
    
      <category term="随笔" scheme="http://wulingqi.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>设计模式之观察者模式</title>
    <link href="http://wulingqi.github.io/2018/04/16/DesignPatterns/observer/"/>
    <id>http://wulingqi.github.io/2018/04/16/DesignPatterns/observer/</id>
    <published>2018-04-16T12:59:03.000Z</published>
    <updated>2018-04-16T13:50:52.348Z</updated>
    
    <content type="html"><![CDATA[<p>引言：以下代码使用java实现</p><h2 id="1-是什么"><a href="#1-是什么" class="headerlink" title="1.是什么"></a>1.是什么</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>观察者模式又被称为发布订阅模式，属于行为模式的一种，定义了一种一对多的依赖关系，让多个观察对象同时监听某一个主题对象，一旦主题对象状态变化时，就会通知所有的观察者对象，不管观察者对象是否需要这个信息。</p><p><code>盗用一下Head First上的类图</code><br><a href="/images/DesignPattern/Observer.png"><img src="/images/DesignPattern/Observer.png" alt=""></a></p><h2 id="2-使用场景，优势在哪（可以先看观察者的简单使用，比较好理解）"><a href="#2-使用场景，优势在哪（可以先看观察者的简单使用，比较好理解）" class="headerlink" title="2.使用场景，优势在哪（可以先看观察者的简单使用，比较好理解）"></a>2.使用场景，优势在哪（可以先看观察者的简单使用，比较好理解）</h2><h3 id="使用的场景有以下"><a href="#使用的场景有以下" class="headerlink" title="使用的场景有以下"></a>使用的场景有以下</h3><ol><li>关联行为的场景，注意不是组合，关联行为可拆分，可以取消关联</li><li>一对多的事件触发</li><li>其它</li></ol><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><p>观察者模式提供了一种对象设计，让主题和观察者之间松耦合</p><ol><li>关于观察者的一切，主题只知道观察者实现了某个接口（Observer）接口。主题不需要知道观察者的具体类是谁等其它细节。</li><li>任何时候我们都可以增加新的观察者。因为主题唯一依赖的东西是一个实现Observer接口的对象列表，所以我们可以随时增加观察者。</li><li>有新的类型的观察者出现时，我们不需要修改主题代码。主题只需要以同样的方式发送给实现了Observer接口的对象消息就行了。</li><li>改变主题或观察者其中一方，并不会影响另一方。因为两者是松耦合的，所以只要他们之间的接口仍然被遵守，我们就可以自由地改变他们。</li></ol><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ol><li>如果一个观察者有很多直接和间接的观察者，所有通知一遍很费时间</li><li>如果被观察者之间有循环依赖，会触发他们间进行循环调用，导致系统崩溃，使用时注意点</li><li>如果对观察者的通知是通过另外的线程进 行异步投递的话，系统必须保证投递是以自恰的方式进行的。（这句没理解，等后面读四人帮的书后再改改）</li></ol><h2 id="3-观察者模式的简单使用"><a href="#3-观察者模式的简单使用" class="headerlink" title="3. 观察者模式的简单使用"></a>3. 观察者模式的简单使用</h2><p>这种发布订阅的形式，我们用新闻给QQ用户和微信用户统一发送新闻。新闻栏是被观察者，就是我们说的主题，用户就是观察者</p><h3 id="抽象观察者（Observer）"><a href="#抽象观察者（Observer）" class="headerlink" title="抽象观察者（Observer）"></a>抽象观察者（Observer）</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Observer.java</span><br><span class="line"></span><br><span class="line"><span class="comment">// 观察者接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Observer</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 更新的方法，主题将要调用的方法。</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(String message)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="具体实现接口的观察者（XXXObserver）"><a href="#具体实现接口的观察者（XXXObserver）" class="headerlink" title="具体实现接口的观察者（XXXObserver）"></a>具体实现接口的观察者（XXXObserver）</h3><p>QQ用户观察者</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">QQObserver.java</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">QQObserver</span> <span class="keyword">implements</span> <span class="title">Observer</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// QQ用户</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">QQObserver</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = <span class="string">"QQ "</span> + name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(String message)</span></span>&#123;</span><br><span class="line">        System.out.println(name + <span class="string">" : "</span> + message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>微信用户观察者</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">WeiXinObserver.java</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WeiXinObserver</span> <span class="keyword">implements</span> <span class="title">Observer</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 微信用户</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">WeiXinObserver</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = <span class="string">"Weixin "</span> + name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(String message)</span></span>&#123;</span><br><span class="line">        System.out.println(name + <span class="string">" : "</span> + message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="抽象被观察者，或者说是主题（Subject）"><a href="#抽象被观察者，或者说是主题（Subject）" class="headerlink" title="抽象被观察者，或者说是主题（Subject）"></a>抽象被观察者，或者说是主题（Subject）</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Subject.java</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Subject</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 新闻订阅</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加QQ或微信订阅者</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">registered</span><span class="params">(Observer observer)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除订阅者</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">removed</span><span class="params">(Observer observer)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通知订阅者更新的消息</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">notify</span><span class="params">(String message)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="具体观察者"><a href="#具体观察者" class="headerlink" title="具体观察者"></a>具体观察者</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">ImplSubject.java</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ImplSubject</span> <span class="keyword">implements</span> <span class="title">Subject</span></span>&#123;</span><br><span class="line">    <span class="comment">// 存储订阅者信息</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;Observer&gt; userList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registered</span><span class="params">(Observer observer)</span> </span>&#123;</span><br><span class="line">        userList.add(observer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removed</span><span class="params">(Observer observer)</span> </span>&#123;</span><br><span class="line">        userList.remove(observer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">notify</span><span class="params">(String message)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (Observer observer : userList)&#123;</span><br><span class="line">            <span class="comment">// 调用观察者的update</span></span><br><span class="line">            observer.update(message);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="客户端调用"><a href="#客户端调用" class="headerlink" title="客户端调用"></a>客户端调用</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">Client.java</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建新闻栏</span></span><br><span class="line">        Subject newInformation = <span class="keyword">new</span> ImplSubject();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// QQ用户注册</span></span><br><span class="line">        QQObserver qq1 = <span class="keyword">new</span> QQObserver(<span class="string">"wulingqi"</span>);</span><br><span class="line">        QQObserver qq2 = <span class="keyword">new</span> QQObserver(<span class="string">"leiyanrui"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 微信用户注册</span></span><br><span class="line">        WeiXinObserver weiXin1 = <span class="keyword">new</span> WeiXinObserver(<span class="string">"yaonan"</span>);</span><br><span class="line">        WeiXinObserver weixin2 = <span class="keyword">new</span> WeiXinObserver(<span class="string">"huangzizhong"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 订阅wulingqi新闻</span></span><br><span class="line">        newInformation.registered(qq1);</span><br><span class="line">        newInformation.registered(qq2);</span><br><span class="line">        newInformation.registered(weiXin1);</span><br><span class="line">        newInformation.registered(weixin2);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 发送新闻</span></span><br><span class="line">        newInformation.notify(<span class="string">"wulingqi博客更新啦"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">QQ wulingqi : wulingqi博客更新啦</span><br><span class="line">QQ leiyanrui : wulingqi博客更新啦</span><br><span class="line">Weixin yaonan : wulingqi博客更新啦</span><br><span class="line">Weixin huangzizhong : wulingqi博客更新啦</span><br></pre></td></tr></table></figure></p><blockquote><p>松耦合，我们可以通过观察者接口产生不同的用户类型，也可以通过被观察者（主题）接口产生不同的版块，新闻，娱乐，推送的公众号等，双方不会产生影响。具体的原因见第2点的解释。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;引言：以下代码使用java实现&lt;/p&gt;
&lt;h2 id=&quot;1-是什么&quot;&gt;&lt;a href=&quot;#1-是什么&quot; class=&quot;headerlink&quot; title=&quot;1.是什么&quot;&gt;&lt;/a&gt;1.是什么&lt;/h2&gt;&lt;h3 id=&quot;定义&quot;&gt;&lt;a href=&quot;#定义&quot; class=&quot;heade
      
    
    </summary>
    
      <category term="设计模式" scheme="http://wulingqi.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="观察者模式" scheme="http://wulingqi.github.io/tags/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Oracle dense_rank函数问题解决中ing</title>
    <link href="http://wulingqi.github.io/2018/04/15/Oracle/dense-rank/"/>
    <id>http://wulingqi.github.io/2018/04/15/Oracle/dense-rank/</id>
    <published>2018-04-15T11:37:46.000Z</published>
    <updated>2018-04-15T12:08:24.846Z</updated>
    
    <content type="html"><![CDATA[<p>引言：苦逼博主在leetCode刷题时遇到的问题</p><blockquote><p>Oracle函数dense_rank() over([partition by xxx] order by xxx [desc])是用来排序连续可重复的，比如</p></blockquote><table><thead><tr><th style="text-align:right">id</th><th>得分</th><th style="text-align:right">名次</th></tr></thead><tbody><tr><td style="text-align:right">2</td><td>10</td><td style="text-align:right">1</td></tr><tr><td style="text-align:right">3</td><td>9</td><td style="text-align:right">2</td></tr><tr><td style="text-align:right">5</td><td>9</td><td style="text-align:right">2</td></tr><tr><td style="text-align:right">1</td><td>9</td><td style="text-align:right">2</td></tr><tr><td style="text-align:right">4</td><td>7</td><td style="text-align:right">3</td></tr></tbody></table><p>就是上表，连续可重复的名次，但是排序的过程竟然有细微的精度问题，请看下面这题<br><a href="https://leetcode.com/problems/rank-scores/description/" target="_blank" rel="noopener">Rank Scores</a></p><p>鉴于大概你们懒得打开，我直接贴图吧<br><a href="/images/LeetCode/RankScorePro.png"><img src="/images/LeetCode/RankScorePro.png" alt=""></a></p><p>看起来很简单，Oracle直接<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">select s.score as &quot;Score&quot;, dense_rank() over(order by s.score desc) as &quot;Rank&quot; from Scores s;</span><br></pre></td></tr></table></figure></p><p>那么恭喜你过了9个case，第十个gg了，上图发现<br><a href="/images/LeetCode/RankScoreOut.png"><img src="/images/LeetCode/RankScoreOut.png" alt=""></a></p><blockquote><p>注意：竟然是死在了精度问题，输出了几个精度那么高的数，嗯嗯嗯，看数据，嗯嗯嗯，两位数是么，嗯嗯嗯</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">select round(s.score, 2) as &quot;Score&quot;, dense_rank() over(order by s.score desc) as &quot;Rank&quot; from Scores s;</span><br></pre></td></tr></table></figure><blockquote><p>哈哈哈，卡过了。</p></blockquote><p>好吧，讲正经的，就是为了突出这个函数排序时会有精度问题？我也不是很确定，所以老老实实用别的方法吧。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">select  </span><br><span class="line">  Score,  </span><br><span class="line">  (select count(distinct Score) from Scores where Score &gt;= s.Score) as Rank  </span><br><span class="line">from Scores s  </span><br><span class="line">order by Score desc</span><br></pre></td></tr></table></figure><blockquote><p>嗯，上面这个用Oracle交同样的精度问题，MySql交没错，。。。</p></blockquote><h2 id="所以，总结，这题Oracle有毒，函数也没确定是否会导致精度问题"><a href="#所以，总结，这题Oracle有毒，函数也没确定是否会导致精度问题" class="headerlink" title="所以，总结，这题Oracle有毒，函数也没确定是否会导致精度问题"></a>所以，总结，这题Oracle有毒，函数也没确定是否会导致精度问题</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;引言：苦逼博主在leetCode刷题时遇到的问题&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Oracle函数dense_rank() over([partition by xxx] order by xxx [desc])是用来排序连续可重复的，比如&lt;/p&gt;
&lt;/blockq
      
    
    </summary>
    
      <category term="Oracle" scheme="http://wulingqi.github.io/categories/Oracle/"/>
    
    
      <category term="随笔" scheme="http://wulingqi.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
      <category term="leetCode" scheme="http://wulingqi.github.io/tags/leetCode/"/>
    
  </entry>
  
  <entry>
    <title>2018搬瓦工搭建ss（小笔记）</title>
    <link href="http://wulingqi.github.io/2018/04/15/vps-ss/"/>
    <id>http://wulingqi.github.io/2018/04/15/vps-ss/</id>
    <published>2018-04-15T09:01:26.000Z</published>
    <updated>2018-04-17T04:24:58.063Z</updated>
    
    <content type="html"><![CDATA[<ol><li>购买和搭建ss看这个教程<a href="https://www.cnlinode.com/ban_wa_gong_mei_you_shadowsocks_xuan_xiang_le_zen_me_ban_san_zhong_fang_fa_da_jian_ss_jiao_cheng/" target="_blank" rel="noopener">搬瓦工没有shadowsocks选项了怎么办？三种方法搭建SS教程！</a>建议选择第三个</li><li>ss的详细配置看下面这个<br><a href="https://teddysun.com/342.html/comment-page-1" target="_blank" rel="noopener">Shadowsocks Python版一键安装脚本</a></li></ol><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># 上面包含几条命令和路径</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 卸载</span></span><br><span class="line">./shadowsocks.sh unistall</span><br><span class="line"></span><br><span class="line"><span class="comment"># 配置文件路径</span></span><br><span class="line">/etc/shaowsocks-python/config.json</span><br><span class="line"></span><br><span class="line"><span class="comment">#启动</span></span><br><span class="line">/etc/init.d/shadowsocks-python start</span><br><span class="line"><span class="comment">#停止</span></span><br><span class="line">/etc/init.d/shadowsocks-python stop</span><br><span class="line"><span class="comment">#状态</span></span><br><span class="line">/etc/init.d/shadowsocks-python status</span><br></pre></td></tr></table></figure><blockquote><p>注意：putty或git连接vps的密码是root password modification生成的复杂密码<br>git连接命令： ssh -p 端口号 user@ip</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ol&gt;
&lt;li&gt;购买和搭建ss看这个教程&lt;a href=&quot;https://www.cnlinode.com/ban_wa_gong_mei_you_shadowsocks_xuan_xiang_le_zen_me_ban_san_zhong_fang_fa_da_jian_ss
      
    
    </summary>
    
    
      <category term="随笔" scheme="http://wulingqi.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>java编程思想 内部类学习笔记（注意其中的jdk版本问题）</title>
    <link href="http://wulingqi.github.io/2018/04/14/notes/innernal-class/"/>
    <id>http://wulingqi.github.io/2018/04/14/notes/innernal-class/</id>
    <published>2018-04-14T15:11:26.000Z</published>
    <updated>2018-04-22T12:39:11.190Z</updated>
    
    <content type="html"><![CDATA[<p>引言：这里使用的都是Effective java里的例子，并且按照其目录顺序进行讲解（枯燥无味，没什么好玩的，毕竟只是笔记，尽量讲的简单，例子也需要注意，因为是直接拷贝effective java的例子稍加修改，所以不一定能运行（只对于print输出方面，其它正常无误）</p><h2 id="创建内部类"><a href="#创建内部类" class="headerlink" title="创建内部类"></a>创建内部类</h2><p>直接上例子：<br>…</p><blockquote><p>注意：如果在外部类外非静态方法创建内部类（还没讲到其它类型的内部类都默认普通内部类），具体声明对象的类型格式为：OuterClassName.InnerClassName</p></blockquote><h2 id="使用-this与-new"><a href="#使用-this与-new" class="headerlink" title="使用.this与.new"></a>使用.this与.new</h2><p>例子1：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DotThis</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123; System.out.println(<span class="string">"DotThis.f()"</span>); &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Inner</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> DotThis <span class="title">outer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="comment">// ClassName.this生成对外部类对象的引用</span></span><br><span class="line">            <span class="keyword">return</span> DotThis.<span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Inner <span class="title">inner</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="keyword">new</span> Inner(); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        DotThis dt = <span class="keyword">new</span> DotThis();</span><br><span class="line">        DotThis.Inner dti = dt.inner();</span><br><span class="line">        <span class="comment">// outer获取DotThis对象的引用调用f函数</span></span><br><span class="line">        dti.outer().f();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>例子2：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DotNew</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Inner</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        DotNew dn = <span class="keyword">new</span> DotNew();</span><br><span class="line">        <span class="comment">// 外部类的引用dn使用.new语法</span></span><br><span class="line">        DotNew.Inner dni = dn.new Inner();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果要用其它对象去创建某个内部类对象，需要用外部类实例引用对内部类进行.new语法，但是，如果创建的是嵌套类（静态内部类，后面会讲），那么就不需要对外部类对象引用。</p><blockquote><p>注意：在拥有外部类对象前是不可能创建内部类对象的（静态内部类除外），因为内部类对象会隐式产生连接到外部类对象的引用，而静态内部类不需要产生对外部类对象的引用。</p></blockquote><h2 id="内部类与向上转型"><a href="#内部类与向上转型" class="headerlink" title="内部类与向上转型"></a>内部类与向上转型</h2><p>（有个内容还不清楚，暂时不写）</p><h2 id="在方法和作用域内的内部类"><a href="#在方法和作用域内的内部类" class="headerlink" title="在方法和作用域内的内部类"></a>在方法和作用域内的内部类</h2><p>使用这种内部类的理由有两个：</p><ol><li>实现某类型的接口，可以创建并返回对其的引用。</li><li>要解决一个复杂的问题，想创建一个类来辅助你的解决方案，但是又不希望这个类是公共可用的</li></ol><blockquote><p>注意： 在某个方法或者作用域内声明的内部类，方法或者范围外部不能访问</p></blockquote><p>例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Parcel5</span> </span>&#123;</span><br><span class="line">    <span class="comment">// destination方法中创建PDestination内部类</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Destination <span class="title">destination</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="class"><span class="keyword">class</span> <span class="title">PDestination</span> <span class="keyword">implements</span> <span class="title">Destination</span> </span>&#123;</span><br><span class="line">            <span class="keyword">private</span> String label;</span><br><span class="line">            <span class="function"><span class="keyword">private</span> <span class="title">PDestination</span><span class="params">(String whereTo)</span> </span>&#123;</span><br><span class="line">                label = whereTo;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> String <span class="title">readLabel</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> label; &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> PDestination(s);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Parcel5 p = <span class="keyword">new</span> Parcel5();</span><br><span class="line">        Destination d = p.destination(<span class="string">"Tasmania"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="匿名内部类"><a href="#匿名内部类" class="headerlink" title="匿名内部类"></a>匿名内部类</h2><p>直接看例子了解语法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Parcel7</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 这里返回匿名内部类的引用</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Contents <span class="title">contents</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Contents() &#123; <span class="comment">// Insert a class definition</span></span><br><span class="line">            <span class="keyword">private</span> <span class="keyword">int</span> i = <span class="number">11</span>;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">value</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> i; &#125;</span><br><span class="line">        &#125;; <span class="comment">// Semicolon required in this case</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Parcel7 p = <span class="keyword">new</span> Parcel7();</span><br><span class="line">        Contents c = p.contents();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 上述匿名内部类其实是下面例子的简化形式</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Parcel7b</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 这里对应上面匿名内部类的内容</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">MyContents</span> <span class="keyword">implements</span> <span class="title">Contents</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> i = <span class="number">11</span>;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">value</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> i; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 对应返回匿名内部类的引用</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Contents <span class="title">contents</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="keyword">new</span> MyContents(); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Parcel7b p = <span class="keyword">new</span> Parcel7b();</span><br><span class="line">        Contents c = p.contents();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注意：如果匿名内部类要使用一个在外部定义的对象，那么这个对象必须是final类型的，看下面例子：</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span></span>&#123;</span><br><span class="line">    <span class="comment">// final变量 c 和 a</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> c = <span class="number">2</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> A <span class="title">creatA</span><span class="params">(<span class="keyword">final</span> <span class="keyword">int</span> a)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> A()&#123;</span><br><span class="line">            <span class="keyword">int</span> b = a;</span><br><span class="line">            <span class="keyword">int</span> d = c;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>但是注意一点，是在匿名内部类内使用才必须是final，但是如果是下面这样，不需要final（ememem，这是对的么？不对啊，得看是什么版本的jdk版本，jdf1.8开始竟然没有这个限制了，ememem，坑我，再注意，没这个限制并不是意味着这个不是final，而是系统默认添加，用来简化代码而已，java将这个功能称为：Effectively final，改变值还是会报错的）看下面jdk1.8的官方文档</p></blockquote><p><a href="/images/Inner.png"><img src="/images/Inner.png" alt=""></a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span>&#123;</span><br><span class="line">    String a;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">A</span><span class="params">(String a)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.a = a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span></span>&#123;</span><br><span class="line">    <span class="comment">// final变量 c 和 a</span></span><br><span class="line">    <span class="keyword">final</span> String c = <span class="string">"zzz"</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> A <span class="title">creatA</span><span class="params">(String a)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> A(a)&#123;</span><br><span class="line">            String b = a;</span><br><span class="line">            String d = c;  </span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注意：我上面也说了，new A(a)中的a并不在内部类中，所以不必声明fianl，String b = a在低版本中是会报错的，因为a并不是final，而在1.8开始由于effective final的存在，如果不改变其值就不会gg。</p></blockquote><h2 id="嵌套类（静态内部类）"><a href="#嵌套类（静态内部类）" class="headerlink" title="嵌套类（静态内部类）"></a>嵌套类（静态内部类）</h2><p>用static修饰词修饰，意味着：</p><ol><li>要创建嵌套类对象，并不需要其外围类的对象</li><li>不能凶嵌套类的对象中访问非静态的外围类对象（没有特殊的this引用，使得它类似于一个static方法）</li></ol><blockquote><p>注意：普通内部类和嵌套类还有一个区别，普通内部类的字段与方法，只能放在类的外部层次上，所以普通的内部类不能有static数据和static字段，也不能包含嵌套类，但是嵌套类可以包含这些。</p></blockquote><p>还是看个例子吧</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Parcel11</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ParcelContents</span> <span class="keyword">implements</span> <span class="title">Contents</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> i = <span class="number">11</span>;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">value</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> i; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 静态内部类</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ParcelDestination</span></span></span><br><span class="line"><span class="class">            <span class="keyword">implements</span> <span class="title">Destination</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> String label;</span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="title">ParcelDestination</span><span class="params">(String whereTo)</span> </span>&#123;</span><br><span class="line">            label = whereTo;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">readLabel</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> label; &#125;</span><br><span class="line">        <span class="comment">// Nested classes can contain other static elements:</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">int</span> x = <span class="number">10</span>;</span><br><span class="line">        <span class="comment">// 内部再嵌套一个嵌套类</span></span><br><span class="line">        <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">AnotherLevel</span> </span>&#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">            <span class="keyword">static</span> <span class="keyword">int</span> x = <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Destination <span class="title">destination</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ParcelDestination(s);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Contents <span class="title">contents</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ParcelContents();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Contents c = contents();</span><br><span class="line">        Destination d = destination(<span class="string">"Tasmania"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="接口内部的类"><a href="#接口内部的类" class="headerlink" title="接口内部的类"></a>接口内部的类</h2><p>正常情况下，不能再接口内部放置任何代码（当然，这指的是jdk1.8以下的版本），但嵌套类可以作为接口的一部分，放到接口中的任何类都自动的是public和static的，所以嵌套类置于接口的命名空间内，就拥有嵌套类的那两个特性。甚至可在嵌套类内实现外围接口。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ClassInInterface</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">howdy</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">// 嵌套类于接口中，并且实现接口方法</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Test</span> <span class="keyword">implements</span> <span class="title">ClassInInterface</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">howdy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"Howdy!"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">new</span> Test().howdy();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>所以，这就有个好处，如果你要创建某些公共代码，使得它们可以被某个接口的所有不同实现类所共用，那么使用接口的嵌套类会显得很方便。</p><blockquote><p>但是注意：jdk1.8中引入了接口的默认方法，所以也能在接口不使用嵌套类的情况下进行公共代码的实现，具体区别和优势有待考察。</p></blockquote></blockquote><h2 id="从多重嵌套的内部类中访问外部类的成员（注意，这里不是嵌套类）"><a href="#从多重嵌套的内部类中访问外部类的成员（注意，这里不是嵌套类）" class="headerlink" title="从多重嵌套的内部类中访问外部类的成员（注意，这里不是嵌套类）"></a>从多重嵌套的内部类中访问外部类的成员（注意，这里不是嵌套类）</h2><p>一个内部类被嵌套多少层并不重要，它能透明的访问所有它所嵌入的外围类的所有成员，看以下例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MNA</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">g</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">B</span> </span>&#123;</span><br><span class="line">            <span class="function"><span class="keyword">void</span> <span class="title">h</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                g();</span><br><span class="line">                f();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MultiNestingAccess</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MNA mna = <span class="keyword">new</span> MNA();</span><br><span class="line">        MNA.A mnaa = mna.new A();</span><br><span class="line">        MNA.A.B mnaab = mnaa.new B();</span><br><span class="line">        mnaab.h();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="为什么需要内部类"><a href="#为什么需要内部类" class="headerlink" title="为什么需要内部类"></a>为什么需要内部类</h2><p><code>其中一个最吸引人的原因是：每一个内部类都能独立地继承一个（或者接口）的实现，无论外围类是否已经继承（或者接口）某个实现，对于内部类没有影响</code></p><p>所以可以考虑一种情形：必须在一个类中以某种方式实现两个接口，由于接口的灵活性，两种选择：单一类或者内部类，看以下例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">A</span> </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">B</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// X单一类实现</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">X</span> <span class="keyword">implements</span> <span class="title">A</span>, <span class="title">B</span> </span>&#123;&#125;</span><br><span class="line"><span class="comment">// Y使用内部类实现</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Y</span> <span class="keyword">implements</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    <span class="function">B <span class="title">makeB</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">// Anonymous inner class:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> B() &#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MultiInterfaces</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">takesA</span><span class="params">(A a)</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">takesB</span><span class="params">(B b)</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        X x = <span class="keyword">new</span> X();</span><br><span class="line">        Y y = <span class="keyword">new</span> Y();</span><br><span class="line">        takesA(x);</span><br><span class="line">        takesA(y);</span><br><span class="line">        takesB(x);</span><br><span class="line">        takesB(y.makeB());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注意：这里使用的是两个不同的接口，但是如果我需要同意接口的两种不同的实现呢，读者自行考虑吧，虽然我也不确定这个例子是否合适，哈哈。还有一个问题，不同的接口是没事了，但如果是抽象类或者具体的类呢，那不就只能使用内部类才能实现多重继承了，看以下例子：</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">E</span> </span>&#123;&#125;</span><br><span class="line"><span class="comment">// 继承类D</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Z</span> <span class="keyword">extends</span> <span class="title">D</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 内部类实现对E的继承，&#123;&#125;里可以填实现细节</span></span><br><span class="line">    <span class="function">E <span class="title">makeE</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="keyword">new</span> E() &#123;&#125;; &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MultiImplementation</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">takesD</span><span class="params">(D d)</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">takesE</span><span class="params">(E e)</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Z z = <span class="keyword">new</span> Z();</span><br><span class="line">        takesD(z);</span><br><span class="line">        takesE(z.makeE());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>一开始我也会想，直接声明父类变量使用不是更好，后来想想也不是不对，前提是我们不会对父类的函数进行重写，而且这里内部类继承的不是抽象类么，如果外部类不是抽象类肯定要实现重写函数的不是么，所以解开了我所想的。</p></blockquote><p>如果不需要解决多重继承的问题的问题，那么自然可以用别的方式，而不需要使用内部类，但是如果使用内部类，还可以获得其他一些特性：</p><blockquote><ol><li>内部类可以有多个实例，每个实例都有自己的状态信息，并且与其外围类对象的信息相互独立</li><li>在单个外围类中，可以让多个内部类以不同的方式实现同一个接口，或者继承容一个类（就像我上面举的实现同一个接口的问题）</li><li>创建内部类对象的时刻并不依赖外围类对象的创建（这里不是指不需要外围类就能直接创建内部类，之前也讲过，除了嵌套类，在创建内部类之前，都得拥有外部类对象，那么这里是什么意思呢，就是如果你用继承的话，要想使用父类的内容，必须是依赖外部类的，比如不同的父类内容必须是不同的外部类实例，而内部类只要有一个外部类实例，就能创建一堆彼此间相互独立地内部类实例，我觉得是这个意思）</li><li>内部类没有令人迷惑的“is-a”关系，就是一个独立地实体。<br>举个妮子： 有个父类接口中有display()方法用来实现数据内容的输出，如果没有内部类，我子类继承了并实现了，输出相应的姓名，年龄，身高，体重，性别。但是，这只是我想看的，我想给室友看的不想包括性别，给他介绍对象（男的也介绍，嘎嘎嘎），那我要怎么办，再写一个类重写？只要用内部类就能拥有另一种实现，noGenderDisplay()。只有内部类才有这种灵活性。</li></ol></blockquote><h2 id="闭包与回调"><a href="#闭包与回调" class="headerlink" title="闭包与回调"></a>闭包与回调</h2><p>闭包：是一个可调用的对象，它记录了一些信息，这些信息来自于创建它的作用域。通过这个定义，可以看出内部类是面向对象的闭包，因为它不仅包含外围类对象（创建内部类的作用域）的信息，还自动拥有一个指向此外围类对象的引用，在此作用域内，内部类有权操作所有的成员，包括private成员</p><blockquote><p>通过内部类提供闭包的功能是优良的解决方案，它比指针更灵活，更安全，如下：</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Incrementable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">increment</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Very simple to just implement the interface:</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Callee1</span> <span class="keyword">implements</span> <span class="title">Incrementable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">increment</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        i++;</span><br><span class="line">        print(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyIncrement</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">increment</span><span class="params">()</span> </span>&#123; print(<span class="string">"Other operation"</span>); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">(MyIncrement mi)</span> </span>&#123; mi.increment(); &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// If your class must implement increment() in</span></span><br><span class="line"><span class="comment">// some other way, you must use an inner class:</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Callee2</span> <span class="keyword">extends</span> <span class="title">MyIncrement</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">increment</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.increment();</span><br><span class="line">        i++;</span><br><span class="line">        print(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 通过内部类实现自己期望的increment函数的使用</span></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Closure</span> <span class="keyword">implements</span> <span class="title">Incrementable</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">increment</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 外部的引用使用外围类的函数</span></span><br><span class="line">            Callee2.<span class="keyword">this</span>.increment();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">Incrementable <span class="title">getCallbackReference</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Closure();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Caller</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Incrementable callbackReference;</span><br><span class="line">    Caller(Incrementable cbh) &#123; callbackReference = cbh; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">go</span><span class="params">()</span> </span>&#123; callbackReference.increment(); &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Callbacks</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Callee1 c1 = <span class="keyword">new</span> Callee1();</span><br><span class="line">        Callee2 c2 = <span class="keyword">new</span> Callee2();</span><br><span class="line">        MyIncrement.f(c2);</span><br><span class="line">        Caller caller1 = <span class="keyword">new</span> Caller(c1);</span><br><span class="line">        Caller caller2 = <span class="keyword">new</span> Caller(c2.getCallbackReference());</span><br><span class="line">        caller1.go();</span><br><span class="line">        caller1.go();</span><br><span class="line">        caller2.go();</span><br><span class="line">        caller2.go();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Output:</span></span><br><span class="line"><span class="comment">Other operation</span></span><br><span class="line"><span class="comment">1</span></span><br><span class="line"><span class="comment">1</span></span><br><span class="line"><span class="comment">2</span></span><br><span class="line"><span class="comment">Other operation</span></span><br><span class="line"><span class="comment">2</span></span><br><span class="line"><span class="comment">Other operation</span></span><br><span class="line"><span class="comment">3</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><blockquote><p>注意：Callee2中所有的除了getCallbackReferrence以外都是private。想要建立与外部的连接，只能使用接口Increamentable进行实现。内部类Closure实现了接口，并且返回Callee2的钩子，并且是安全的，只能调用increament函数，没有其它的功能。</p></blockquote><p>回调： 这里有个写的挺清楚的，请看<a href="http://www.cnblogs.com/heshuchao/p/5376298.html" target="_blank" rel="noopener">Bro__超</a></p><h2 id="内部类的继承"><a href="#内部类的继承" class="headerlink" title="内部类的继承"></a>内部类的继承</h2><p>这里问题复杂点，因为非静态内部类的构造器必须连接到外围类的引用，所以继承内部类也需要外部类实例的参与，见下面例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWord</span> <span class="keyword">extends</span> <span class="title">A</span>.<span class="title">B</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 外部类A的实例a调用super，提供必要的引用</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HelloWord</span><span class="params">(A a)</span></span>&#123;</span><br><span class="line">        a.<span class="keyword">super</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        A a = <span class="keyword">new</span> A();</span><br><span class="line">        HelloWord helloWord = <span class="keyword">new</span> HelloWord(a);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">B</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="内部类是可以被覆盖么"><a href="#内部类是可以被覆盖么" class="headerlink" title="内部类是可以被覆盖么"></a>内部类是可以被覆盖么</h2><ol><li>继承某个外围类时，就算子类重写父类的内部类，内部类的实现也不会被覆盖，调用的方法遵循声明的类型。</li><li>如果明确继承父类的内部类，并且重写内部类，则覆盖</li></ol><p>看下面两个例子：</p><p>例子1：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Egg</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Yolk y;</span><br><span class="line">    <span class="keyword">protected</span> <span class="class"><span class="keyword">class</span> <span class="title">Yolk</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Yolk</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"Egg.Yolk()"</span>); &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Egg</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"New Egg()"</span>);</span><br><span class="line">        y = <span class="keyword">new</span> Yolk();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BigEgg</span> <span class="keyword">extends</span> <span class="title">Egg</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Yolk</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Yolk</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"BigEgg.Yolk()"</span>); &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> BigEgg();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>说明继承了某个外围类时，内部类保持独立的个体，两个独立地实体。</p></blockquote><p>例子2：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Egg</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Yolk y;</span><br><span class="line">    <span class="keyword">protected</span> <span class="class"><span class="keyword">class</span> <span class="title">Yolk</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"this is egg.Yolk"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insertYolk</span><span class="params">(Yolk yy)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.y = yy;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 调用覆盖的f()</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">g</span><span class="params">()</span></span>&#123;</span><br><span class="line">        y.f();</span><br><span class="line">        Yolk yy = <span class="keyword">new</span> Yolk();</span><br><span class="line">        yy.f();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BigEgg</span> <span class="keyword">extends</span> <span class="title">Egg</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    Yolk y;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Yolk</span> <span class="keyword">extends</span> <span class="title">Egg</span>.<span class="title">Yolk</span></span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"this is BigEgg.Yolk"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BigEgg</span><span class="params">()</span></span>&#123;</span><br><span class="line">        y = <span class="keyword">new</span> Yolk();</span><br><span class="line">        insertYolk(y);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Egg egg = <span class="keyword">new</span> BigEgg();</span><br><span class="line">        egg.g();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">output:</span><br><span class="line"><span class="keyword">this</span> is BigEgg.Yolk</span><br><span class="line"><span class="keyword">this</span> is Egg.Yolk</span><br></pre></td></tr></table></figure><blockquote><p>注意：其实父类还是保持着自己独立地实现，其实就和类继承一样，没什么差别，和类联系起来就行了。</p></blockquote><h2 id="局部内部类"><a href="#局部内部类" class="headerlink" title="局部内部类"></a>局部内部类</h2><blockquote><p>注意：不带有访问修饰词</p></blockquote><p><code>局部内部类和匿名内部类有相同的能力，那么为何还有用匿名内部类，因为，匿名内部类只能实例初始化，没有自己的构造器或者重载的构造器。所以，使用局部内部类的理由只有一个：不止使用同一种实例化方式实例化对象时</code></p><p>看例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//定义在方法里</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Parcel5</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Destionation <span class="title">destionation</span><span class="params">(String str)</span></span>&#123;</span><br><span class="line">        <span class="class"><span class="keyword">class</span> <span class="title">PDestionation</span> <span class="keyword">implements</span> <span class="title">Destionation</span></span>&#123;</span><br><span class="line">            <span class="keyword">private</span> String label;</span><br><span class="line">            <span class="function"><span class="keyword">private</span> <span class="title">PDestionation</span><span class="params">(String whereTo)</span></span>&#123;</span><br><span class="line">                label = whereTo;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> String <span class="title">readLabel</span><span class="params">()</span></span>&#123;</span><br><span class="line">                <span class="keyword">return</span> label;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> PDestionation(str);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Parcel5 parcel5 = <span class="keyword">new</span> Parcel5();</span><br><span class="line">        Destionation d = parcel5.destionation(<span class="string">"chenssy"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//定义在作用域内</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Parcel6</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">internalTracking</span><span class="params">(<span class="keyword">boolean</span> b)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(b)&#123;</span><br><span class="line">            <span class="class"><span class="keyword">class</span> <span class="title">TrackingSlip</span></span>&#123;</span><br><span class="line">                <span class="keyword">private</span> String id;</span><br><span class="line">                TrackingSlip(String s) &#123;</span><br><span class="line">                    id = s;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="function">String <span class="title">getSlip</span><span class="params">()</span></span>&#123;</span><br><span class="line">                    <span class="keyword">return</span> id;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            TrackingSlip ts = <span class="keyword">new</span> TrackingSlip(<span class="string">"chenssy"</span>);</span><br><span class="line">            String string = ts.getSlip();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">track</span><span class="params">()</span></span>&#123;</span><br><span class="line">        internalTracking(<span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Parcel6 parcel6 = <span class="keyword">new</span> Parcel6();</span><br><span class="line">        parcel6.track();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>总的来说内部类分为几种：</p><ol><li>普通内部类</li><li>嵌套类</li><li>匿名内部类</li><li>局部内部类</li></ol><h2 id="部分使用场景"><a href="#部分使用场景" class="headerlink" title="部分使用场景"></a>部分使用场景</h2><ol><li>当某个类除了它的外部类，不再被其他类使用（比如：数据库连接池）</li><li>解决一些非面向对象的语句块</li><li>一些多算法的场合</li><li>适当使用内部类，使得代码更加灵活和富有扩展性</li><li><a href="https://blog.csdn.net/hivon/article/details/606312" target="_blank" rel="noopener">详细的上面四中场合</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;引言：这里使用的都是Effective java里的例子，并且按照其目录顺序进行讲解（枯燥无味，没什么好玩的，毕竟只是笔记，尽量讲的简单，例子也需要注意，因为是直接拷贝effective java的例子稍加修改，所以不一定能运行（只对于print输出方面，其它正常无误）&lt;/
      
    
    </summary>
    
      <category term="java" scheme="http://wulingqi.github.io/categories/java/"/>
    
    
  </entry>
  
  <entry>
    <title>抽象类和接口(非blog，Not recommended)(更新中)</title>
    <link href="http://wulingqi.github.io/2018/04/12/notes/abstract-class/"/>
    <id>http://wulingqi.github.io/2018/04/12/notes/abstract-class/</id>
    <published>2018-04-12T08:54:54.000Z</published>
    <updated>2018-04-17T11:37:26.326Z</updated>
    
    <content type="html"><![CDATA[<h2 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h2><h3 id="什么是抽象类"><a href="#什么是抽象类" class="headerlink" title="什么是抽象类"></a>什么是抽象类</h3><p>首先了解什么是抽象方法，抽象方法就是只声明，没有具体实现，eg如下:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">zzz</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure></p><p>必须用abstract进行修饰，如果一个类中含有抽象方法，那么称这个类为抽象方法，抽象方法必须也用abstract进行修饰。</p><blockquote><p>注意： 抽象方法不能用来创建对象。这里来自某blog的大佬说在java编程思想中对抽象类的定义为“包含抽象方法的类”，但是后面看源码时有的抽象类其实内部什么方法都没有，然而还是声明成抽象类。算了，细节问题不要在意。</p></blockquote><h3 id="有什么用，用在哪"><a href="#有什么用，用在哪" class="headerlink" title="有什么用，用在哪:"></a>有什么用，用在哪:</h3><p>怎么说，按我的理解，就是为了继承实现多态的，多态的概念就不用解释了</p><h3 id="怎么用？-不可能教你怎么用的，自己看书，自己谷歌"><a href="#怎么用？-不可能教你怎么用的，自己看书，自己谷歌" class="headerlink" title="怎么用？(不可能教你怎么用的，自己看书，自己谷歌)"></a>怎么用？(不可能教你怎么用的，自己看书，自己谷歌)</h3><h3 id="注意的问题"><a href="#注意的问题" class="headerlink" title="注意的问题"></a>注意的问题</h3><ol><li>访问修饰符里虽然也有提到过，但是抽象类的方法必须为public或者protected，毕竟子类必须有能够访问的能力进行事项</li><li>如果子类继承了抽象父类，如果没有全部重写父类的所有抽象方法，那么子类依然是抽象类，依然不能实例化。</li></ol><h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><h3 id="什么是接口"><a href="#什么是接口" class="headerlink" title="什么是接口"></a>什么是接口</h3><p>怎么说，可以理解为纯粹的抽象类吧，接口泛指别人调用的方法或者函数，是对行为的抽象（下面对比的时候会解释的）</p><h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><ol><li>接口中可以含有 变量和方法。但是要注意，接口中的变量会被隐式地指定为public static final变量（并且只能是public static final变量，用private修饰会报编译错误），而方法会被隐式地指定为public abstract方法且只能是public abstract方法（用其他关键字，比如private、protected、static、 final等修饰会报编译错误），并且接口中所有的方法不能有具体的实现，也就是说，接口中的方法必须都是抽象方法。从这里可以隐约看出接口和抽象类的区别，接口是一种极度抽象的类型，它比抽象类更加“抽象”，并且一般情况下不在接口中定义变量。</li><li>重点： 第1个注意点中，只适合老版本，jdk1.8以下的版本，在jdk1.8中接口加入了新概念，扩展了接口的含义：默认方法和静态方法，默认方法使得接口有点类似traits吧，不过要实现的目标不一样。默认方法使得开发者可以在不破坏二进制兼容性的前提下，王现存的接口中添加新的方法，即不强制实现了该接口的类也可同时实现这个新加的方法。（可以通过转换调用）可以看出，默认方法和抽象方法之间的区别在于抽象方法需要实现，而默认方法不需要。接口提供的默认方法会被接口的实现类继承或者覆写。看个简单的例子</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">interface</span> <span class="title">Defaulable</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Interfaces now allow default methods, the implementer may or </span></span><br><span class="line">    <span class="comment">// may not implement (override) them.</span></span><br><span class="line">    <span class="function"><span class="keyword">default</span> String <span class="title">notRequired</span><span class="params">()</span> </span>&#123; </span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Default implementation"</span>; </span><br><span class="line">    &#125;        </span><br><span class="line">&#125;</span><br><span class="line">        </span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultableImpl</span> <span class="keyword">implements</span> <span class="title">Defaulable</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">OverridableImpl</span> <span class="keyword">implements</span> <span class="title">Defaulable</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">notRequired</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Overridden implementation"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//例子来源：（其实是我懒得写）</span></span><br><span class="line"><span class="comment">//作者：杜琪</span></span><br><span class="line"><span class="comment">//链接：https://www.jianshu.com/p/5b800057f2d8</span></span><br><span class="line"><span class="comment">//著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span></span><br></pre></td></tr></table></figure><p><code>此默认方法扩充了Collection的方法，比如stream(), parallelStream()等，Stream也是java8的一大亮点，专注于对集合对象进行各种流弊的操作，可以很方便写出高性能的并发程序，偏题了。</code></p><h2 id="那么，抽象类和接口的区别"><a href="#那么，抽象类和接口的区别" class="headerlink" title="那么，抽象类和接口的区别"></a>那么，抽象类和接口的区别</h2><p>语法层面上的区别（jdk1.8以下版本)</p><ul><li>抽象类可以提供成员方法的实现细节，而接口中只能存在public abstract 方法；</li><li>抽象类中的成员变量可以是各种类型的，而接口中的成员变量只能是public static final类型的；</li><li>接口中不能含有静态代码块以及静态方法，而抽象类可以有静态代码块和静态方法；</li><li>一个类只能继承一个抽象类，而一个类却可以实现多个接口。</li></ul><p>设计层面上的区别(<a href="http://www.importnew.com/18780.html" target="_blank" rel="noopener">那么多字，肯定不是我自己写的（别想太多，点我）</a>)</p><ol><li>抽象类是对一种事物的抽象，即对类抽象，而接口是对行为的抽象。抽象类是对整个类整体进行抽象，包括属性、行为，但是接口却是对类局部（行为）进行抽象。举个简单的例子，飞机和鸟是不同类的事物，但是它们都有一个共性，就是都会飞。那么在设计的时候，可以将飞机设计为一个类Airplane，将鸟设计为一个类Bird，但是不能将 飞行 这个特性也设计为类，因此它只是一个行为特性，并不是对一类事物的抽象描述。此时可以将 飞行 设计为一个接口Fly，包含方法fly( )，然后Airplane和Bird分别根据自己的需要实现Fly这个接口。然后至于有不同种类的飞机，比如战斗机、民用飞机等直接继承Airplane即可，对于鸟也是类似的，不同种类的鸟直接继承Bird类即可。从这里可以看出，继承是一个 “是不是”的关系，而 接口 实现则是 “有没有”的关系。如果一个类继承了某个抽象类，则子类必定是抽象类的种类，而接口实现则是有没有、具备不具备的关系，比如鸟是否能飞（或者是否具备飞行这个特点），能飞行则可以实现这个接口，不能飞行就不实现这个接口。</li><li>设计层面不同，抽象类作为很多子类的父类，它是一种模板式设计。而接口是一种行为规范，它是一种辐射式设计。什么是模板式设计？最简单例子，大家都用过ppt里面的模板，如果用模板A设计了ppt B和ppt C，ppt B和ppt C公共的部分就是模板A了，如果它们的公共部分需要改动，则只需要改动模板A就可以了，不需要重新对ppt B和ppt C进行改动。而辐射式设计，比如某个电梯都装了某种报警器，一旦要更新报警器，就必须全部更新。也就是说对于抽象类，如果需要添加新的方法，可以直接在抽象类中添加具体的实现，子类可以不进行变更；而对于接口则不行，如果接口进行了变更，则所有实现这个接口的类都必须进行相应的改动。</li></ol><blockquote><p>简单来说，抽象类就是个模板类，接口是一种行为规范，就像上面说的辐射式设计，但是，对于新版本的jdk1.8，个人感觉也具有一定模板式设计了，都引入的默认方法了，和抽象类中非抽象方法有什么区别。但是，其设计层面的区别还主要是接口是对行为的抽象，新版本的小疑问以后再做考虑。</p></blockquote><h2 id="接口其它应用"><a href="#接口其它应用" class="headerlink" title="接口其它应用"></a>接口其它应用</h2><p>应用很多，有与设计模式相关的适配器，工厂模式等，具体详细请看java便构成思想，还有接口为什么优于抽象类等相关问题请看effective java。</p><h2 id="补充：-对上面新版本中接口不就是抽象类的进行解释"><a href="#补充：-对上面新版本中接口不就是抽象类的进行解释" class="headerlink" title="补充： 对上面新版本中接口不就是抽象类的进行解释"></a>补充： 对上面新版本中接口不就是抽象类的进行解释</h2><p>详细见<a href="https://my.oschina.net/benhaile/blog/176007" target="_blank" rel="noopener">开源中国</a></p><h1 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h1><p><a href="http://www.importnew.com/18780.html" target="_blank" rel="noopener">http://www.importnew.com/18780.html</a><br><a href="https://www.jianshu.com/p/038f0b356e9a" target="_blank" rel="noopener">https://www.jianshu.com/p/038f0b356e9a</a><br><a href="http://arthur503.github.io/blog/2013/10/10/Java-access-control.html" target="_blank" rel="noopener">http://arthur503.github.io/blog/2013/10/10/Java-access-control.html</a><br><a href="https://www.ibm.com/developerworks/cn/java/j-lo-java8streamapi/" target="_blank" rel="noopener">https://www.ibm.com/developerworks/cn/java/j-lo-java8streamapi/</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;抽象类&quot;&gt;&lt;a href=&quot;#抽象类&quot; class=&quot;headerlink&quot; title=&quot;抽象类&quot;&gt;&lt;/a&gt;抽象类&lt;/h2&gt;&lt;h3 id=&quot;什么是抽象类&quot;&gt;&lt;a href=&quot;#什么是抽象类&quot; class=&quot;headerlink&quot; title=&quot;什么是抽象类&quot;&gt;&lt;
      
    
    </summary>
    
      <category term="java" scheme="http://wulingqi.github.io/categories/java/"/>
    
    
      <category term="java笔记" scheme="http://wulingqi.github.io/tags/java%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>Java访问权限修饰符(非blog，Not recommended)(更新中)</title>
    <link href="http://wulingqi.github.io/2018/04/12/notes/ppt/"/>
    <id>http://wulingqi.github.io/2018/04/12/notes/ppt/</id>
    <published>2018-04-12T08:51:23.000Z</published>
    <updated>2018-04-17T11:36:15.957Z</updated>
    
    <content type="html"><![CDATA[<p>引言：java中有四种访问修饰符，public，protected，defaul（实际上没有这个关键词（大概懂我意思吧），就是默认的同一包内访问权限。），private，用于对方法，属性，类的修饰，但是部分可用。</p><p>访问权限和使用类别见一下两个表格</p><p><code>表格(一)</code></p><table><thead><tr><th style="text-align:center">修饰符</th><th style="text-align:center">修饰成员变量和函数</th><th style="text-align:center">修饰类</th></tr></thead><tbody><tr><td style="text-align:center">public</td><td style="text-align:center">yes</td><td style="text-align:center">yes</td></tr><tr><td style="text-align:center">protected</td><td style="text-align:center">yes</td><td style="text-align:center">no</td></tr><tr><td style="text-align:center">default</td><td style="text-align:center">yes</td><td style="text-align:center">yes</td></tr><tr><td style="text-align:center">private</td><td style="text-align:center">yes</td><td style="text-align:center">no</td></tr></tbody></table><p><code>表格(二)</code></p><table><thead><tr><th style="text-align:center">修饰符</th><th style="text-align:center">当前类</th><th style="text-align:center">同一包内</th><th style="text-align:center">子孙类</th><th style="text-align:center">其它包</th></tr></thead><tbody><tr><td style="text-align:center">public</td><td style="text-align:center">yes</td><td style="text-align:center">yes</td><td style="text-align:center">yes</td><td style="text-align:center">yes</td></tr><tr><td style="text-align:center">protected</td><td style="text-align:center">yes</td><td style="text-align:center">yes</td><td style="text-align:center">yes</td><td style="text-align:center">no</td></tr><tr><td style="text-align:center">default</td><td style="text-align:center">yes</td><td style="text-align:center">yes</td><td style="text-align:center">no</td><td style="text-align:center">no</td></tr><tr><td style="text-align:center">private</td><td style="text-align:center">yes</td><td style="text-align:center">no</td><td style="text-align:center">no</td><td style="text-align:center">no</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;引言：java中有四种访问修饰符，public，protected，defaul（实际上没有这个关键词（大概懂我意思吧），就是默认的同一包内访问权限。），private，用于对方法，属性，类的修饰，但是部分可用。&lt;/p&gt;
&lt;p&gt;访问权限和使用类别见一下两个表格&lt;/p&gt;
&lt;p
      
    
    </summary>
    
      <category term="java" scheme="http://wulingqi.github.io/categories/java/"/>
    
    
      <category term="java笔记" scheme="http://wulingqi.github.io/tags/java%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>easyMock的简单使用（详细参考官方文档，第二问更新中）</title>
    <link href="http://wulingqi.github.io/2018/04/09/mock/easyMock-simple-use/"/>
    <id>http://wulingqi.github.io/2018/04/09/mock/easyMock-simple-use/</id>
    <published>2018-04-09T12:14:44.000Z</published>
    <updated>2018-04-14T01:01:51.745Z</updated>
    
    <content type="html"><![CDATA[<p>引言： 本文采取的例子来自 <a href="https://veerasundar.com/blog/2012/06/easymock-tutorial-getting-started/" target="_blank" rel="noopener">EasyMock tutorial – Getting Started</a>（就是原文啦）</p><h2 id="什么是Mock？"><a href="#什么是Mock？" class="headerlink" title="什么是Mock？"></a>什么是Mock？</h2><p>Mock其实就是模拟或者Stud，当你调用一个不好在测试中创建的对象时，Mock框架为你模拟一个和真实对象类似的数据类完成相应的行为。</p><blockquote><p>比如说：我接下来要写的股票问题，首先，股价时刻都在变动，我们一旦获取了当前的股价，并不代表一定是正确的数据，因为真实的股价是时刻都在变动的，所以我们要模拟一个检索股票的接口来获取数据，而不是去访问真实的服务器。</p></blockquote><h2 id="与PowerMock和JMock相比"><a href="#与PowerMock和JMock相比" class="headerlink" title="与PowerMock和JMock相比"></a>与PowerMock和JMock相比</h2><p>如今比较流行的工具JMock，EasyMock，Mockito等都有一个共同的缺点，就是不能mock静态，final，私有方法(但是可以mock类哦，前提类内部也没有以上属性的方法），而PowerMock能够完美的弥补以上三个Mock的不足（扩充而不是替代，可以提高代码测试的覆盖率，天哪，我到底为什么才知道），自行百度吧。（似乎还有个全能的Jmokit，等研究好了再补充）<br>某个工作的<a href="https://blog.coding.net/blog/mock-testing-tools" target="_blank" rel="noopener">作者遇到坑</a>，但是本萌现在还看不懂，大概因为用的是PowerMock，本萌还没学</p><h3 id="简单用法："><a href="#简单用法：" class="headerlink" title="简单用法："></a>简单用法：</h3><p>这里我们用一个简单的例子来简单的入门easyMock的用法。</p><h3 id="股票计算应用"><a href="#股票计算应用" class="headerlink" title="股票计算应用"></a>股票计算应用</h3><p>引言：首先，这个应用有一个接口，两个实体类和一个测试类。</p><ol><li>Stock类是用来表示股票的信息，含股票名和数量（我们可以想象成数据库所学的emp类）</li><li>Portfolio类保存不同股票的信息（想象成emplist一样，里面存着各种人员的信息），这个类中有一个计算所有股票价格的总和的方法getTotalValue()，我们要测试的就是这个方法。</li><li>StockMarket接口，也就是股市的意思，就是我们要模拟的接口，模拟这个接口里getPrice的数据</li></ol><p>内容：<br>上代码，首先是实体类Stock<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">Stock.java</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Stock</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Stock类用来存储股票的信息，名字和类型, 联想一下就是实体类emp</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> quantity;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Stock</span> <span class="params">(String name, <span class="keyword">int</span> quantity)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.quantity = quantity;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getQuantity</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> quantity;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setQuantity</span><span class="params">(<span class="keyword">int</span> quantity)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.quantity = quantity;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>然后是Protfolio类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Protfolio</span> </span>&#123;</span><br><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment">     *注意：硬编码依赖不是好的实践，我们不应该在此初始化stockMarket对象，</span></span><br><span class="line"><span class="comment"> *我们应该在使用测试代码的时候注入进来。(这里就先这样了）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 某个投资的名，这里不重要</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 模拟的接口，这里就当成是实际存在的进行使用</span></span><br><span class="line">    <span class="keyword">private</span> StockMarket stockMarket;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 保存股票的信息</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;Stock&gt; stocks = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 计算所有股票是价格，并返回</span></span><br><span class="line"><span class="comment">     * sock保存的各个股票的数量乘以通过接口stockMarket模拟获取的价格求和</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getTotalValue</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">double</span> value = <span class="number">0.0</span>;</span><br><span class="line">        <span class="keyword">for</span> (Stock stock: <span class="keyword">this</span>.stocks)&#123;</span><br><span class="line">            value += (stockMarket.getPrice(stock.getName()) * stock.getQuantity());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addStock</span><span class="params">(Stock stock)</span></span>&#123;</span><br><span class="line">        stocks.add(stock);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> StockMarket <span class="title">getStockMarket</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> stockMarket;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setStockMarket</span><span class="params">(StockMarket stockMarket)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.stockMarket = stockMarket;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Stock&gt; <span class="title">getStocks</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> stocks;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setStocks</span><span class="params">(List&lt;Stock&gt; stocks)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.stocks = stocks;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上就是所有业务的逻辑，很简单吧，sock股票信息，Port进行处理，stockMarket获取价格</p><p><code>然后是Junit和EasyMock测试Portfolio中的getTotalValue()方法</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">ProtfolioTest.java</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.wlq.easymock.dao.StockMarket;</span><br><span class="line"><span class="keyword">import</span> com.wlq.easymock.entity.Protfolio;</span><br><span class="line"><span class="keyword">import</span> com.wlq.easymock.entity.Stock;</span><br><span class="line"><span class="keyword">import</span> org.easymock.EasyMock;</span><br><span class="line"><span class="keyword">import</span> org.junit.Before;</span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.junit.Assert.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProtfolioTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Protfolio protfolio;</span><br><span class="line">    <span class="keyword">private</span> StockMarket marketMock;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Before</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUp</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        protfolio = <span class="keyword">new</span> Protfolio();</span><br><span class="line">        protfolio.setName(<span class="string">"wlq's portfolip."</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 模拟创建（StockMarket）股市的实例</span></span><br><span class="line">        marketMock = EasyMock.createMock(StockMarket.class);</span><br><span class="line">        <span class="comment">// 将模拟实例对象赋给股票列表</span></span><br><span class="line">        protfolio.setStockMarket(marketMock);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getTotalValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 用我们期望的返回值来配置模拟对象，当getPrice参数是EBAY时，返回的数值为42.00</span></span><br><span class="line">        EasyMock.expect(marketMock.getPrice(<span class="string">"EBAY"</span>)).andReturn(<span class="number">42.00</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 这个replay不要忘记，将mock进行重放，否则会IllegalStateException</span></span><br><span class="line">        <span class="comment">//异常和一个没有什么帮助的错误消息：</span></span><br><span class="line">        <span class="comment">//missing behavior definition for the preceding method call。</span></span><br><span class="line">        EasyMock.replay(marketMock);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 开始测试</span></span><br><span class="line">        Stock ebayStock = <span class="keyword">new</span> Stock(<span class="string">"EBAY"</span>, <span class="number">2</span>);</span><br><span class="line">        protfolio.addStock(ebayStock);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 这里使用的是org.junit下的断言，在4.12的javadoc中中已经没有没有junit.framework的</span></span><br><span class="line">        <span class="comment">// 内容了，但是为了兼容，4.12版本中还会对其进行保留</span></span><br><span class="line">        <span class="comment">// 在junit4中这个方法似乎被弃用了可以添加第三个参数代表误差</span></span><br><span class="line">        <span class="comment">// 弃用： assertEquals(84.00, protfolio.getTotalValue());</span></span><br><span class="line">        assertEquals(<span class="number">84.00</span>, protfolio.getTotalValue(), <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h2><ol><li>先 EasyMock.createMock(xxxx.class) 创建模拟接口返回的对象</li><li>然后就是正常使用接口的实例操作</li><li>配置模拟对象，在什么条件下做什么 EasyMock.expect(模拟的对象实例.xxx方法()).xxx返回的东西或者要做的事()</li><li>EasyMock.replay(实例对象)</li><li>开始正常逻辑测试。</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;引言： 本文采取的例子来自 &lt;a href=&quot;https://veerasundar.com/blog/2012/06/easymock-tutorial-getting-started/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;EasyMock t
      
    
    </summary>
    
      <category term="java" scheme="http://wulingqi.github.io/categories/java/"/>
    
    
      <category term="Junit" scheme="http://wulingqi.github.io/tags/Junit/"/>
    
      <category term="easyMock" scheme="http://wulingqi.github.io/tags/easyMock/"/>
    
  </entry>
  
  <entry>
    <title>IDEA中dependencies和libraries的区别</title>
    <link href="http://wulingqi.github.io/2018/04/09/idea/dependencies-and-libraries/"/>
    <id>http://wulingqi.github.io/2018/04/09/idea/dependencies-and-libraries/</id>
    <published>2018-04-09T11:50:06.000Z</published>
    <updated>2018-04-09T12:13:55.871Z</updated>
    
    <content type="html"><![CDATA[<p>我觉得，idea中的dependencies和eclipse中的build path差不多，在eclipse中先将jar文件放入某个lib文件夹下然后add build path</p><pre><code>其实通过意思可以看出，dependencies是依赖，libraries是库，dependencies中添加jar包或者目录就是eclipse中的buildpath，libraries就是集中包的一个目录，用来集中批量管理包。（目前理解就是这些，有错求指正）</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;我觉得，idea中的dependencies和eclipse中的build path差不多，在eclipse中先将jar文件放入某个lib文件夹下然后add build path&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;其实通过意思可以看出，dependencies是依赖，libra
      
    
    </summary>
    
    
      <category term="随笔" scheme="http://wulingqi.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
      <category term="idea" scheme="http://wulingqi.github.io/tags/idea/"/>
    
  </entry>
  
  <entry>
    <title>idea-webApp简单运行环境配置</title>
    <link href="http://wulingqi.github.io/2018/04/08/idea/idea-webApp-simple/"/>
    <id>http://wulingqi.github.io/2018/04/08/idea/idea-webApp-simple/</id>
    <published>2018-04-08T04:41:10.000Z</published>
    <updated>2018-04-09T12:03:15.858Z</updated>
    
    <content type="html"><![CDATA[<ol><li>首先在web下创建两个目录，分别为lib和classes，classe保存编译后的.class文件，lib保存需要的jar包。</li><li>打开project Setting, 选择modules，点击paths，把两个path路径改成第一步骤下的classes路径。</li><li>点击path旁边的dependencies进行Tomcat的添加，点击+选择Library，选择Tomcat进行添加。或者先在librarys添加相应的包，再去dependencies添加。</li><li>配置Tomcat文件，edit Configurations，点击+，选择Tomcat，local Tomcat，Server部分进行相关配置，然后对deployment点击+添加artifact，webxxxxx啥的。</li><li>运行下试试。</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ol&gt;
&lt;li&gt;首先在web下创建两个目录，分别为lib和classes，classe保存编译后的.class文件，lib保存需要的jar包。&lt;/li&gt;
&lt;li&gt;打开project Setting, 选择modules，点击paths，把两个path路径改成第一步骤下的clas
      
    
    </summary>
    
      <category term="java" scheme="http://wulingqi.github.io/categories/java/"/>
    
    
      <category term="随笔" scheme="http://wulingqi.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
      <category term="applet" scheme="http://wulingqi.github.io/tags/applet/"/>
    
      <category term="idea" scheme="http://wulingqi.github.io/tags/idea/"/>
    
  </entry>
  
  <entry>
    <title>javaIO流的总结（更新中）</title>
    <link href="http://wulingqi.github.io/2018/04/07/IO/javaIO-summary/"/>
    <id>http://wulingqi.github.io/2018/04/07/IO/javaIO-summary/</id>
    <published>2018-04-07T14:11:28.000Z</published>
    <updated>2018-04-14T15:16:55.733Z</updated>
    
    <content type="html"><![CDATA[<p>引言：这里不会讲各种流的详细用法。</p><p><a href="/images/javaIO.png"><img src="/images/javaIO.png" alt="我的流结构"></a></p><blockquote><p>注意：original Stream（也称为节点流） 和 wrapper Stream（也称为处理流）未包装类和包装类。</p></blockquote><blockquote><p>java可分为输出流和输入流，根据流类型，可分为字符流和字节流，如下表：</p></blockquote><table><thead><tr><th style="text-align:center">分类</th><th style="text-align:center">字节流</th><th>字符流</th></tr></thead><tbody><tr><td style="text-align:center">输入流</td><td style="text-align:center">InputStream</td><td>Reader</td></tr><tr><td style="text-align:center">输出流</td><td style="text-align:center">OutputStream</td><td>Writer</td></tr></tbody></table><blockquote><p>实际使用中我们一般不会用到上面说的四类，而是使用继承它们的子类，不同的子类负责着不同的功能，以便于我开发不同的应用。<br>用途主要有以下几种：</p></blockquote><ul><li>文件访问</li><li>网络访问</li><li>内存缓存访问</li><li>线程内部通信</li><li>缓冲</li><li>过滤</li><li>解析</li><li>读写文本，基本数据类型，对象</li></ul><h3 id="Java-IO-类概述表"><a href="#Java-IO-类概述表" class="headerlink" title="Java IO 类概述表"></a>Java IO 类概述表</h3><p><img src="/images/IO.png" alt=""></p><blockquote><p>该表使用自并发编程网的<a href="http://ifeve.com/java-io-3/" target="_blank" rel="noopener">javaIO</a></p></blockquote><blockquote><p>各做基类流继承下去的分为两类，节点的流和处理流：<br>字节节点流只具有读取字节内容的方法，比如FileInputStream流和FileOutputStream流只能向文件中读取或者向文件中写入字节，对于各种类型的数据，如果是写入文件，必须转换成字节数组后写入文件，若是读取，那么就得转换成相应的类型。 而处理流，例如DataOutputStream提供了各种对象中写入类型的方法，方便编程人员。</p></blockquote><h2 id="1-字节流"><a href="#1-字节流" class="headerlink" title="1. 字节流"></a>1. 字节流</h2><h3 id="1-1-InputStream作为基类"><a href="#1-1-InputStream作为基类" class="headerlink" title="1.1 InputStream作为基类"></a>1.1 InputStream作为基类</h3><h4 id="1-1-1-ByteArrayInputStream"><a href="#1-1-1-ByteArrayInputStream" class="headerlink" title="1.1.1 ByteArrayInputStream"></a>1.1.1 ByteArrayInputStream</h4><blockquote><p>内部通过建立字节数组buf缓冲区来读取保存数据</p></blockquote><p>适用场景:<br>此流是内存操作流，这个流可实现类似内存虚拟文件的功能，将数据暂存在缓存区中，可以使程序不需要产生相应的临时文件，避免从存储介质上读取，提升效率。</p><p>注意:<br>此流没有提供close关闭流的操作，当没有对其的强引用时，就会自动被GC，但是也会导致内存溢出，可以使用org.apache.commons.io.IoUtiles关闭流</p><h4 id="1-1-2-FileInputStream"><a href="#1-1-2-FileInputStream" class="headerlink" title="1.1.2 FileInputStream"></a>1.1.2 FileInputStream</h4><blockquote><p>把一个文件作为文件输入流，实现对文件的读取操作，访问硬盘</p></blockquote><p>适用场景:<br>从名字上就能看出应用，对硬盘上的文件的存取</p><h4 id="1-1-3-SocketInputStream"><a href="#1-1-3-SocketInputStream" class="headerlink" title="1.1.3 SocketInputStream"></a>1.1.3 SocketInputStream</h4><blockquote><p>就和名字一样，适用于网络通信中。</p></blockquote><h4 id="1-1-4-PipeInputStream"><a href="#1-1-4-PipeInputStream" class="headerlink" title="1.1.4 PipeInputStream"></a>1.1.4 PipeInputStream</h4><blockquote><p>通多创建管道实现线程间的通信</p></blockquote><h4 id="1-1-5-BufferedInputStream"><a href="#1-1-5-BufferedInputStream" class="headerlink" title="1.1.5 BufferedInputStream"></a>1.1.5 BufferedInputStream</h4><blockquote><p>本质是通过一个内部缓冲数组实现的，默认大小8192，实现滑动读取的功能，事先把size大小的数据从磁盘中读取到缓冲区上，然后实际操作都在缓冲区中进行，如果数据超过缓冲区，那么将重新载入数据。减少了磁盘IO，提高了效率。</p></blockquote><p>用途：<br>因为其缓存的功能，可以起到改善效率的作用。通过源码可以看出，构造器的形参是InputStream，所以可以对其进行改善效率，包括FileInputStream等，比如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">BufferedInputStream bufferedInputStream = <span class="keyword">new</span> BufferedInputStream(<span class="keyword">new</span> FileInputStream(<span class="string">"zzz.txt"</span>));</span><br></pre></td></tr></table></figure><h4 id="1-1-6-DataInputStream"><a href="#1-1-6-DataInputStream" class="headerlink" title="1.1.6 DataInputStream"></a>1.1.6 DataInputStream</h4><blockquote><p>封装了对字节流的解析，实现了对基本数据类型的基本操作和对读取UTF格式的方法，当然，读取字符的还有Rread等相关的字符流。</p></blockquote><h4 id="1-1-7-PushbackInputStream"><a href="#1-1-7-PushbackInputStream" class="headerlink" title="1.1.7 PushbackInputStream"></a>1.1.7 PushbackInputStream</h4><blockquote><p>回推流，把从缓存区中读出来的数据再原路推回去，没有破坏输入流里的内容结构。</p></blockquote><p>注意：<br>PushbackInputStream对象会使得InputStream对象（用于创建PushbackInputStream对象）的mark()或reset()方法无效。对于准备使用mark()或reset()方法的任何流来说，都应当使用markSupported()方法进行检查。</p><h4 id="1-1-8-ObjectInputStream与ObjectOutputStream"><a href="#1-1-8-ObjectInputStream与ObjectOutputStream" class="headerlink" title="1.1.8 ObjectInputStream与ObjectOutputStream"></a>1.1.8 ObjectInputStream与ObjectOutputStream</h4><blockquote><p>ObjectOutputStream 将 Java 对象的基本数据类型和图形写入 OutputStream。可以使用 ObjectInputStream 读取（重构）对象。通过在流中使用文件可以实现对象的持久存储。如果流是网络套接字流，则可以在另一台主机上或另一个进程中重构对象。<br>只能将支持 java.io.Serializable 接口的对象写入流中。每个 serializable 对象的类都被编码，编码内容包括类名和类签名、对象的字段值和数组值，以及从初始对象中引用的其他所有对象的闭包。<br>writeObject 方法用于将对象写入流中。所有对象（包括 String 和数组）都可以通过 writeObject 写入。可将多个对象或基元写入流中。必须使用与写入对象时相同的类型和顺序从相应 ObjectInputstream 中读回对象。</p></blockquote><h4 id="1-1-9-SequenceInputStream"><a href="#1-1-9-SequenceInputStream" class="headerlink" title="1.1.9 SequenceInputStream"></a>1.1.9 SequenceInputStream</h4><blockquote><p>合并流，将多个源合并成一个源</p></blockquote><h3 id="1-2-OutputStream作为基类"><a href="#1-2-OutputStream作为基类" class="headerlink" title="1.2 OutputStream作为基类"></a>1.2 OutputStream作为基类</h3><h4 id="1-2-1-PrintStream"><a href="#1-2-1-PrintStream" class="headerlink" title="1.2.1 PrintStream"></a>1.2.1 PrintStream</h4><blockquote><p>PrintStream 是打印输出流，它继承于FilterOutputStream。<br>PrintStream 是用来装饰其它输出流。它能为其他输出流添加了功能，使它们能够方便地打印各种数据值表示形式。<br>与其他输出流不同，PrintStream 永远不会抛出 IOException；它产生的IOException会被自身的函数所捕获并设置错误标记， 用户可以通过 checkError() 返回错误标记，从而查看PrintStream内部是否产生了IOException。<br>另外，PrintStream 提供了自动flush 和 字符集设置功能。所谓自动flush，就是往PrintStream写入的数据会立刻调用flush()函数。</p></blockquote><h4 id="这里对比一下PrintStream和DataOutputStream（原文链接"><a href="#这里对比一下PrintStream和DataOutputStream（原文链接" class="headerlink" title="这里对比一下PrintStream和DataOutputStream（原文链接)"></a>这里对比一下PrintStream和DataOutputStream（<a href="https://www.cnblogs.com/skywang12345/p/io_16.html" target="_blank" rel="noopener">原文链接</a>)</h4><p>相同点：都是继承与FileOutputStream，用于包装其它输出流。<br>不同点：</p><p>(01) PrintStream和DataOutputStream 都可以将数据格式化输出；但它们在“输出字符串”时的编码不同。</p><blockquote><p>PrintStream是输出时采用的是用户指定的编码(创建PrintStream时指定的)，若没有指定，则采用系统默认的字符编码。而DataOutputStream则采用的是UTF-8。<br>关于UTF-8的字符编码可以参考“字符编码(ASCII，Unicode和UTF-8) 和 大小端”<br>关于DataOutputStream的更多内容，可以参考“java io系列15之 DataOutputStream(数据输出流)的认知、源码和示例”</p></blockquote><p>(02) 它们的写入数据时的异常处理机制不同。</p><blockquote><p>DataOutputStream在通过write()向“输出流”中写入数据时，若产生IOException，会抛出。<br>而PrintStream在通过write()向“输出流”中写入数据时，若产生IOException，则会在write()中进行捕获处理；并设置trouble标记(用于表示产生了异常)为true。用户可以通过checkError()返回trouble值，从而检查输出流中是否产生了异常。</p></blockquote><p>(03) 构造函数不同</p><blockquote><p>DataOutputStream的构造函数只有一个：DataOutputStream(OutputStream out)。即它只支持以输出流out作为“DataOutputStream的输出流”。<br>而PrintStream的构造函数有许多：和DataOutputStream一样，支持以输出流out作为“PrintStream输出流”的构造函数；还支持以“File对象”或者“String类型的文件名对象”的构造函数。<br>而且，在PrintStream的构造函数中，能“指定字符集”和“是否支持自动flush()操作”。</p></blockquote><p>(04) 目的不同</p><blockquote><p>DataOutputStream的作用是装饰其它的输出流，它和DataInputStream配合使用：允许应用程序以与机器无关的方式从底层输入流中读写java数据类型。<br>而PrintStream的作用虽然也是装饰其他输出流，但是它的目的不是以与机器无关的方式从底层读写java数据类型；而是为其它输出流提供打印各种数据值表示形式，使其它输出流能方便的通过print(), println()或printf()等输出各种格式的数据。</p></blockquote><h2 id="2-字符流"><a href="#2-字符流" class="headerlink" title="2. 字符流"></a>2. 字符流</h2><h3 id="2-1-Reader作为基类"><a href="#2-1-Reader作为基类" class="headerlink" title="2.1 Reader作为基类"></a>2.1 Reader作为基类</h3><h4 id="2-1-1-CharArrayReader"><a href="#2-1-1-CharArrayReader" class="headerlink" title="2.1.1 CharArrayReader"></a>2.1.1 CharArrayReader</h4><h4 id="2-1-2-InputStreamReader"><a href="#2-1-2-InputStreamReader" class="headerlink" title="2.1.2 InputStreamReader"></a>2.1.2 InputStreamReader</h4><h4 id="2-1-3-FileReader"><a href="#2-1-3-FileReader" class="headerlink" title="2.1.3 FileReader"></a>2.1.3 FileReader</h4><h4 id="2-1-4-PipedReader"><a href="#2-1-4-PipedReader" class="headerlink" title="2.1.4 PipedReader"></a>2.1.4 PipedReader</h4><h4 id="2-1-5-StringReader"><a href="#2-1-5-StringReader" class="headerlink" title="2.1.5 StringReader"></a>2.1.5 StringReader</h4><h4 id="2-1-6-BufferedReader"><a href="#2-1-6-BufferedReader" class="headerlink" title="2.1.6 BufferedReader"></a>2.1.6 BufferedReader</h4><h4 id="2-1-7-LinNumberReader"><a href="#2-1-7-LinNumberReader" class="headerlink" title="2.1.7 LinNumberReader"></a>2.1.7 LinNumberReader</h4><h4 id="2-1-8-PushBackReader"><a href="#2-1-8-PushBackReader" class="headerlink" title="2.1.8 PushBackReader"></a>2.1.8 PushBackReader</h4><h3 id="2-2-Writer作为基类"><a href="#2-2-Writer作为基类" class="headerlink" title="2.2 Writer作为基类"></a>2.2 Writer作为基类</h3><h4 id="2-2-1-PrintWriter"><a href="#2-2-1-PrintWriter" class="headerlink" title="2.2.1 PrintWriter"></a>2.2.1 PrintWriter</h4><h2 id="3-RandomAccessFile"><a href="#3-RandomAccessFile" class="headerlink" title="3. RandomAccessFile"></a>3. RandomAccessFile</h2><h2 id="4-字符和字节流的转换"><a href="#4-字符和字节流的转换" class="headerlink" title="4. 字符和字节流的转换"></a>4. 字符和字节流的转换</h2><h2 id="5-一般使用规则-输入和输出类似"><a href="#5-一般使用规则-输入和输出类似" class="headerlink" title="5.一般使用规则(输入和输出类似)"></a>5.一般使用规则(输入和输出类似)</h2><p>1.按数据来源分类：</p><ul><li>文件：FileInputStream, FileReader</li><li>byte[]: ByteArrayInputStream</li><li>char[]: CharArrayReader</li><li>String: StringBufferInputStream, StringReader</li><li>网络数据流: InputStream, Reader</li></ul><p>2.按是否格式化输出</p><ul><li>格式化输出： PrintStream, PrintWriter</li></ul><p>3.按是否要缓冲</p><ul><li>BufferedInputStream, BufferedReader</li></ul><p>4.按数据格式：</p><ul><li>字节流： InputStream和OutputStream以及它们的子类</li><li>字符流： Reader和Writer以及它们的子类</li></ul><p>5.按输入输出：</p><ul><li>不用写，都懂</li></ul><p>6.特别的：</p><ul><li>Stream到Reader和Writer的转换类： InputStreamReader和OutputStreamWriter</li><li>对象输入输出： ObjectStream, ObjectStream</li><li>进程通信： PipeInputStream, PipeReader</li><li>合并输入： SequenceInputStream</li><li>其它： PushbackInputStream, PushbackReader, LineNumberInputStream, LineNumberReader</li></ul><h2 id="6-构造准则"><a href="#6-构造准则" class="headerlink" title="6. 构造准则"></a>6. 构造准则</h2><pre><code>决定使用哪个类以及它的构造进程的一般准则如下（不考虑特殊需要）：首先，考虑最原始的数据格式是什么： 原则四第二，是输入还是输出：原则五第三，是否需要转换流：原则六第 1 点第四，数据来源（去向）是什么：原则一第五，是否要缓冲：原则三 （特别注明：一定要注意的是 readLine() 是否有定义，有什么比 read, write 更特殊的输入或输出方法）第六，是否要格式化输出：原则二</code></pre><p>借鉴<a href="http://yuanzhitofaraway.lofter.com/post/2b181d_aac8fcf" target="_blank" rel="noopener">远志，志在远方</a></p><p>【1】内存操作流： 用于处理临时存储的信息，程序结束，数据就从内存中消失。</p><ul><li>字节数组：</li><li>ByteArrayInputStream</li><li><p>ByteArrayOutputStream</p></li><li><p>字符数组：</p></li><li>CharArrayReader</li><li><p>CharArrayWriter</p></li><li><p>字符串：</p></li><li>StringReader</li><li>StringWriter</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;引言：这里不会讲各种流的详细用法。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;/images/javaIO.png&quot;&gt;&lt;img src=&quot;/images/javaIO.png&quot; alt=&quot;我的流结构&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;注意：original Stre
      
    
    </summary>
    
      <category term="java" scheme="http://wulingqi.github.io/categories/java/"/>
    
    
      <category term="IO" scheme="http://wulingqi.github.io/tags/IO/"/>
    
  </entry>
  
  <entry>
    <title>java中自动拆装箱的一些问题</title>
    <link href="http://wulingqi.github.io/2018/04/05/essays/auto-unpacking-packing/"/>
    <id>http://wulingqi.github.io/2018/04/05/essays/auto-unpacking-packing/</id>
    <published>2018-04-05T07:08:41.000Z</published>
    <updated>2018-04-14T15:15:44.164Z</updated>
    
    <content type="html"><![CDATA[<p>引言： 直接进入正题，我就当大家都知道什么是拆箱和装箱了，这里主要讨论的是不清楚原理导致产生一些奇怪问题的内容，想看详细介绍的跳到这边：<a href="http://www.cnblogs.com/dolphin0520/p/3780005.html" target="_blank" rel="noopener">深入剖析java中的装箱和拆箱</a>，这边感谢原作者对反编译class文件的解析，让我理解原理，下面会使用原作者的部分内容以及讲解一些原作者没解析的一些内容。</p><h2 id="1-拆箱和装箱时如何实现的"><a href="#1-拆箱和装箱时如何实现的" class="headerlink" title="1. 拆箱和装箱时如何实现的"></a>1. 拆箱和装箱时如何实现的</h2><blockquote><p>通过反编译的文件可以了解到（见下图），装箱时自动调用的是valueof()方法，而拆箱的时候自动调用的是xxxValue()方法。</p></blockquote><p><a href="/images/Integer.png"><img src="/images/Integer.png" alt=""></a></p><h2 id="2-遇到的相关问题"><a href="#2-遇到的相关问题" class="headerlink" title="2. 遇到的相关问题"></a>2. 遇到的相关问题</h2><h3 id="2-1-看下面的代码"><a href="#2-1-看下面的代码" class="headerlink" title="2.1 看下面的代码"></a>2.1 看下面的代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">         </span><br><span class="line">        Integer i1 = <span class="number">100</span>;</span><br><span class="line">        Integer i2 = <span class="number">100</span>;</span><br><span class="line">        Integer i3 = <span class="number">200</span>;</span><br><span class="line">        Integer i4 = <span class="number">200</span>;</span><br><span class="line">         </span><br><span class="line">        System.out.println(i1==i2);</span><br><span class="line">        System.out.println(i3==i4);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><pre><code>结果是：truefalse</code></pre><blockquote><p>神奇吧，出乎意料，以前没有深入了解，有人提到后就去分析了源码，看看Integer valueOf的部分源码实现</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Integer.java</span><br><span class="line"></span><br><span class="line"><span class="meta">@HotSpotIntrinsicCandidate</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Integer <span class="title">valueOf</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)</span><br><span class="line">            <span class="keyword">return</span> IntegerCache.cache[i + (-IntegerCache.low)];</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Integer(i);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><blockquote><p>通过源码的实现可以看出，有IntegerCache类参与，其实是Integer的一个内部类，源码如下：</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">Integer.java</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">IntegerCache</span> </span>&#123;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> low = -<span class="number">128</span>;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> high;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> Integer cache[];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">static</span> &#123;</span><br><span class="line">            <span class="comment">// high value may be configured by property</span></span><br><span class="line">            <span class="keyword">int</span> h = <span class="number">127</span>;</span><br><span class="line">            String integerCacheHighPropValue =</span><br><span class="line">                VM.getSavedProperty(<span class="string">"java.lang.Integer.IntegerCache.high"</span>);</span><br><span class="line">            <span class="keyword">if</span> (integerCacheHighPropValue != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">int</span> i = parseInt(integerCacheHighPropValue);</span><br><span class="line">                    i = Math.max(i, <span class="number">127</span>);</span><br><span class="line">                    <span class="comment">// Maximum array size is Integer.MAX_VALUE</span></span><br><span class="line">                    h = Math.min(i, Integer.MAX_VALUE - (-low) -<span class="number">1</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span>( NumberFormatException nfe) &#123;</span><br><span class="line">                    <span class="comment">// If the property cannot be parsed into an int, ignore it.</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            high = h;</span><br><span class="line"></span><br><span class="line">            cache = <span class="keyword">new</span> Integer[(high - low) + <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">int</span> j = low;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; cache.length; k++)</span><br><span class="line">                cache[k] = <span class="keyword">new</span> Integer(j++);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// range [-128, 127] must be interned (JLS7 5.1.7)</span></span><br><span class="line">            <span class="keyword">assert</span> IntegerCache.high &gt;= <span class="number">127</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="title">IntegerCache</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><blockquote><p>通过源码可以看出，通过valueOf方法创建Integer对象，如果数值在-128到127之间(具体最大值还要看vm的配置)，直接返回IntegerCache中存在的引用，否则返回新的对象，就能解释true和false的问题了。</p></blockquote><h3 id="2-2-那么再来看一个问题"><a href="#2-2-那么再来看一个问题" class="headerlink" title="2.2 那么再来看一个问题"></a>2.2 那么再来看一个问题</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">         </span><br><span class="line">        Double i1 = <span class="number">100.0</span>;</span><br><span class="line">        Double i2 = <span class="number">100.0</span>;</span><br><span class="line">        Double i3 = <span class="number">200.0</span>;</span><br><span class="line">        Double i4 = <span class="number">200.0</span>;</span><br><span class="line">         </span><br><span class="line">        System.out.println(i1==i2);</span><br><span class="line">        System.out.println(i3==i4);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><pre><code>结果是：falsefalse</code></pre><blockquote><p>又错了吧，应该好好再看看源码的，可恶，没错Double类的valueOf源码的实现和Integet不一样，这里就不贴源码了，看的真心疼，大佬们的代码能力真的是很强。回到问题，源码中Double并没有像Integer那个有规定cache数组等相关的操作，大概我们能使用到double的地方的话代表精度很大，没必要吧，所以Double每次的装箱都是返回新的对象。</p></blockquote><p><code>总结下： Integer，Short，Byte，Character，Long这几个类的valueOf类似，Double，Float的类似</code></p><h3 id="2-3-这里原作者还提到了boolean变量，看例子"><a href="#2-3-这里原作者还提到了boolean变量，看例子" class="headerlink" title="2.3 这里原作者还提到了boolean变量，看例子"></a>2.3 这里原作者还提到了boolean变量，看例子</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">         </span><br><span class="line">        Boolean i1 = <span class="keyword">false</span>;</span><br><span class="line">        Boolean i2 = <span class="keyword">false</span>;</span><br><span class="line">        Boolean i3 = <span class="keyword">true</span>;</span><br><span class="line">        Boolean i4 = <span class="keyword">true</span>;</span><br><span class="line">         </span><br><span class="line">        System.out.println(i1==i2);</span><br><span class="line">        System.out.println(i3==i4);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 结果：</span></span><br><span class="line"><span class="keyword">true</span></span><br><span class="line"><span class="keyword">true</span></span><br></pre></td></tr></table></figure><blockquote><p>通过源码可以很直接的看出</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Boolean.java</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Boolean <span class="title">valueOf</span><span class="params">(<span class="keyword">boolean</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (b ? TRUE : FALSE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>emememem，很简单直观，看看True和False</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Boolean.java</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Boolean TRUE = <span class="keyword">new</span> Boolean(<span class="keyword">true</span>);</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Boolean FALSE = <span class="keyword">new</span> Boolean(<span class="keyword">false</span>);</span><br></pre></td></tr></table></figure><blockquote><p>可以看出，是类成员属性</p></blockquote><h3 id="2-4-Integer-i-new-Integer-xxx-和Integer-i-xxx-这两种方式的区别。（没错，这里copy原文）"><a href="#2-4-Integer-i-new-Integer-xxx-和Integer-i-xxx-这两种方式的区别。（没错，这里copy原文）" class="headerlink" title="2.4 Integer i = new Integer(xxx)和Integer i =xxx;这两种方式的区别。（没错，这里copy原文）"></a>2.4 Integer i = new Integer(xxx)和Integer i =xxx;这两种方式的区别。（没错，这里copy原文）</h3><p>当然，这个题目属于比较宽泛类型的。但是要点一定要答上，我总结一下主要有以下这两点区别：</p><ol><li>第一种方式不会触发自动装箱的过程；而第二种方式会触发；</li><li>在执行效率和资源占用上的区别。第二种方式的执行效率和资源占用在一般性情况下要优于第一种情况（注意这并不是绝对的）。</li></ol><h3 id="2-5-看下面完整的例子"><a href="#2-5-看下面完整的例子" class="headerlink" title="2.5 看下面完整的例子"></a>2.5 看下面完整的例子</h3><p>这里就当做读者都了解 == 和 equals 的区别了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 引用原作者的例子强行解释</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">         </span><br><span class="line">        Integer a = <span class="number">1</span>;</span><br><span class="line">        Integer b = <span class="number">2</span>;</span><br><span class="line">        Integer c = <span class="number">3</span>;</span><br><span class="line">        Integer d = <span class="number">3</span>;</span><br><span class="line">        Integer e = <span class="number">321</span>;</span><br><span class="line">        Integer f = <span class="number">321</span>;</span><br><span class="line">        Long g = <span class="number">3L</span>;</span><br><span class="line">        Long h = <span class="number">2L</span>;</span><br><span class="line">         </span><br><span class="line">        System.out.println(c==d);          <span class="comment">//1.true </span></span><br><span class="line">        System.out.println(e==f);          <span class="comment">//2.false</span></span><br><span class="line">        System.out.println(c==(a+b));      <span class="comment">//3.true</span></span><br><span class="line">        System.out.println(c.equals(a+b)); <span class="comment">//4.true</span></span><br><span class="line">        System.out.println(g==(a+b));      <span class="comment">//5.true</span></span><br><span class="line">        System.out.println(g.equals(a+b)); <span class="comment">//6.false</span></span><br><span class="line">        System.out.println(g.equals(a+h)); <span class="comment">//7.true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>这里挑几点讲解</p><ol><li>第3点，1+2触发自动拆箱，和c比较的是数值是否相等</li><li>第4点，a+b先触发拆箱求和后再触发装箱，调用valueOf方法</li><li>这里对比第6点和第7点：a+b通过拆装箱最后还是Integer类型，g调用的是Long类型的equals，看下面的源码，先比较的是类型，由于类型不对，所以false；这里看看第7点，h是long类型，所以a+b会隐式转换成long的类型，与g类型相同。</li></ol></blockquote><p>相关类型的的equals源码<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Integer.java</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> Integer) &#123;</span><br><span class="line">            <span class="keyword">return</span> value == ((Integer)obj).intValue();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">Long.java</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> Long) &#123;</span><br><span class="line">            <span class="keyword">return</span> value == ((Long)obj).longValue();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;引言： 直接进入正题，我就当大家都知道什么是拆箱和装箱了，这里主要讨论的是不清楚原理导致产生一些奇怪问题的内容，想看详细介绍的跳到这边：&lt;a href=&quot;http://www.cnblogs.com/dolphin0520/p/3780005.html&quot; target=&quot;_
      
    
    </summary>
    
      <category term="java" scheme="http://wulingqi.github.io/categories/java/"/>
    
    
      <category term="随笔" scheme="http://wulingqi.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>关于java.lang.UnsupportedOperationException异常</title>
    <link href="http://wulingqi.github.io/2018/04/05/essays/asListException/"/>
    <id>http://wulingqi.github.io/2018/04/05/essays/asListException/</id>
    <published>2018-04-05T03:37:56.000Z</published>
    <updated>2018-04-05T07:01:37.834Z</updated>
    
    <content type="html"><![CDATA[<p>引言： 这里感谢我们的组长提出这个问题，然后我去查看源码后发现了导致这个问题的原因。</p><h2 id="1-是什么，原因"><a href="#1-是什么，原因" class="headerlink" title="1. 是什么，原因"></a>1. 是什么，原因</h2><p>在调用Arrays类的aslist函数把数组转换成List集合不能对其进行添加删除等操作，否则抛出UnsupportedOperationException的异常，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">zzz.java</span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">zzz</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Integer[] arr = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line">        List&lt;Integer&gt; list = Arrays.asList(arr);</span><br><span class="line">        list.add(<span class="number">3</span>);  <span class="comment">//error</span></span><br><span class="line">        list.remove(<span class="number">2</span>);  <span class="comment">//error</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行代码将抛出一下错误：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Exception in thread <span class="string">"main"</span> java.lang.UnsupportedOperationException</span><br><span class="line">at java.base/java.util.AbstractList.add(AbstractList.java:<span class="number">153</span>)</span><br><span class="line">at java.base/java.util.AbstractList.add(AbstractList.java:<span class="number">111</span>)</span><br><span class="line">at Test.zzz.main(zzz.java:<span class="number">10</span>)</span><br></pre></td></tr></table></figure><p>根据字面意思，unsupportedOperationException就是对该实例不支持相应的函数操作。</p><blockquote><p>也许有人问，list接口明明提供相应的接口，并且ArrayList明明实现了add等操作函数，为什么不支持。问题就在这，aslist返回的ArrayList实例并不是我们之前学的Arraylist的实例，而是Arrays类的静态内部类的实例，看源码</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Arrays.java</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">List&lt;T&gt; <span class="title">asList</span><span class="params">(T... a)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;&gt;(a);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><blockquote><p>asList的源码，跟踪ArrayList的创建方法，继续看源码。只需要注意继承和实现类和接口还有实现的相关函数，直接跳到解析部分：</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br></pre></td><td class="code"><pre><span class="line">Arrays.java</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@serial</span> include</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayList</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractList</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">RandomAccess</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span></span></span><br><span class="line"><span class="class">    </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">2764017481108945198L</span>;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> E[] a;</span><br><span class="line"></span><br><span class="line">        ArrayList(E[] array) &#123;</span><br><span class="line">            a = Objects.requireNonNull(array);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> a.length;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> Object[] toArray() &#123;</span><br><span class="line">            <span class="keyword">return</span> Arrays.copyOf(a, a.length, Object[].class);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">        <span class="keyword">public</span> &lt;T&gt; T[] toArray(T[] a) &#123;</span><br><span class="line">            <span class="keyword">int</span> size = size();</span><br><span class="line">            <span class="keyword">if</span> (a.length &lt; size)</span><br><span class="line">                <span class="keyword">return</span> Arrays.copyOf(<span class="keyword">this</span>.a, size,</span><br><span class="line">                                     (Class&lt;? extends T[]&gt;) a.getClass());</span><br><span class="line">            System.arraycopy(<span class="keyword">this</span>.a, <span class="number">0</span>, a, <span class="number">0</span>, size);</span><br><span class="line">            <span class="keyword">if</span> (a.length &gt; size)</span><br><span class="line">                a[size] = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">return</span> a;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> a[index];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> E <span class="title">set</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</span><br><span class="line">            E oldValue = a[index];</span><br><span class="line">            a[index] = element;</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">            E[] a = <span class="keyword">this</span>.a;</span><br><span class="line">            <span class="keyword">if</span> (o == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a.length; i++)</span><br><span class="line">                    <span class="keyword">if</span> (a[i] == <span class="keyword">null</span>)</span><br><span class="line">                        <span class="keyword">return</span> i;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a.length; i++)</span><br><span class="line">                    <span class="keyword">if</span> (o.equals(a[i]))</span><br><span class="line">                        <span class="keyword">return</span> i;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> indexOf(o) &gt;= <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Spliterator&lt;E&gt; <span class="title">spliterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> Spliterators.spliterator(a, Spliterator.ORDERED);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">forEach</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> E&gt; action)</span> </span>&#123;</span><br><span class="line">            Objects.requireNonNull(action);</span><br><span class="line">            <span class="keyword">for</span> (E e : a) &#123;</span><br><span class="line">                action.accept(e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">replaceAll</span><span class="params">(UnaryOperator&lt;E&gt; operator)</span> </span>&#123;</span><br><span class="line">            Objects.requireNonNull(operator);</span><br><span class="line">            E[] a = <span class="keyword">this</span>.a;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a.length; i++) &#123;</span><br><span class="line">                a[i] = operator.apply(a[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Comparator&lt;? <span class="keyword">super</span> E&gt; c)</span> </span>&#123;</span><br><span class="line">            Arrays.sort(a, c);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Iterator&lt;E&gt; <span class="title">iterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ArrayItr&lt;&gt;(a);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayItr</span>&lt;<span class="title">E</span>&gt; <span class="keyword">implements</span> <span class="title">Iterator</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> cursor;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> E[] a;</span><br><span class="line"></span><br><span class="line">        ArrayItr(E[] a) &#123;</span><br><span class="line">            <span class="keyword">this</span>.a = a;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> cursor &lt; a.length;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> E <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">int</span> i = cursor;</span><br><span class="line">            <span class="keyword">if</span> (i &gt;= a.length) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">            &#125;</span><br><span class="line">            cursor = i + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">return</span> a[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><blockquote><p>调用的是Arrays.java内部类的构造方法ArrayList，然而这个静态内部类并没有实现add等相关的方法，怀着好奇心，继续研究源码，发现这个内部类并没有直接实现List接口，而是通过继承AbstractList<e>来间接实现List接口，我们来看看AbstractList的add和remove源码部分：</e></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">AbstractList.java</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><blockquote><p>真相大白有没有，Arrays的静态内部类ArrayList并没有改写从AbstractList继承的源码，那么调用add和remove等相关函数时，就会调用AbstractList实现的相关方法，然而内容只有抛出异常，没有其它相关的实现操作。</p></blockquote><h2 id="2-那么如何操作转换呢"><a href="#2-那么如何操作转换呢" class="headerlink" title="2. 那么如何操作转换呢"></a>2. 那么如何操作转换呢</h2><p>我这里知道的有两种，欢迎━(<em>｀∀´</em>)ノ亻!补充</p><ol><li>使用Iterator迭代器，迭代访问赋值</li><li>直接使用new ArrayList(Collection&lt;? extends E&gt; c)构造方法，这里注意，ArrayList并没有提供集合以外的参数构造，所以一开始的Integer类型的数组老老实实的迭代添加吧(偷笑), 为什么迭代器，而不是for， get来，效率问题，谷歌去。</li></ol><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>asList调用的是Arrays.java的静态内部类的构造方法，然而那个方法并没有实现add等相关修改数量大小的方法，也许这就是他们想要的目的，但是内容还是能通过set修改。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;引言： 这里感谢我们的组长提出这个问题，然后我去查看源码后发现了导致这个问题的原因。&lt;/p&gt;
&lt;h2 id=&quot;1-是什么，原因&quot;&gt;&lt;a href=&quot;#1-是什么，原因&quot; class=&quot;headerlink&quot; title=&quot;1. 是什么，原因&quot;&gt;&lt;/a&gt;1. 是什么，原因&lt;/
      
    
    </summary>
    
      <category term="java" scheme="http://wulingqi.github.io/categories/java/"/>
    
    
      <category term="随笔" scheme="http://wulingqi.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
</feed>
